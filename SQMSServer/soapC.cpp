/* soapC.cpp
   Generated by gSOAP 2.8.21 from cp850.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.21 2015-03-16 04:33:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns2__Duration:
		return soap_in_ns2__Duration(soap, NULL, NULL, "ns2:Duration");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE__ns2__alarm_type:
		return soap_in__ns2__alarm_type(soap, NULL, NULL, "ns2:alarm-type");
	case SOAP_TYPE__ns2__alarm_severity:
		return soap_in__ns2__alarm_severity(soap, NULL, NULL, "ns2:alarm-severity");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns2__polarity:
		return soap_in_ns2__polarity(soap, NULL, NULL, "ns2:polarity");
	case SOAP_TYPE_ns2__testSignalObjectPath:
		return soap_in_ns2__testSignalObjectPath(soap, NULL, NULL, "ns2:testSignalObjectPath");
	case SOAP_TYPE_ns2__testSignalOutputMode:
		return soap_in_ns2__testSignalOutputMode(soap, NULL, NULL, "ns2:testSignalOutputMode");
	case SOAP_TYPE_ns2__lastAtmosConfigPushErrorType:
		return soap_in_ns2__lastAtmosConfigPushErrorType(soap, NULL, NULL, "ns2:lastAtmosConfigPushErrorType");
	case SOAP_TYPE_ns2__lastAtmosConfigPushStatus:
		return soap_in_ns2__lastAtmosConfigPushStatus(soap, NULL, NULL, "ns2:lastAtmosConfigPushStatus");
	case SOAP_TYPE_ns2__testSignalType:
		return soap_in_ns2__testSignalType(soap, NULL, NULL, "ns2:testSignalType");
	case SOAP_TYPE_ns2__bedChannelId:
		return soap_in_ns2__bedChannelId(soap, NULL, NULL, "ns2:bedChannelId");
	case SOAP_TYPE_ns2__acmod:
		return soap_in_ns2__acmod(soap, NULL, NULL, "ns2:acmod");
	case SOAP_TYPE_ns2__audioStreamType:
		return soap_in_ns2__audioStreamType(soap, NULL, NULL, "ns2:audioStreamType");
	case SOAP_TYPE_ns2__atmosContentStatus:
		return soap_in_ns2__atmosContentStatus(soap, NULL, NULL, "ns2:atmosContentStatus");
	case SOAP_TYPE_ns2__shelfType:
		return soap_in_ns2__shelfType(soap, NULL, NULL, "ns2:shelfType");
	case SOAP_TYPE_ns2__crossoverFilterType:
		return soap_in_ns2__crossoverFilterType(soap, NULL, NULL, "ns2:crossoverFilterType");
	case SOAP_TYPE_ns2__crossoverType:
		return soap_in_ns2__crossoverType(soap, NULL, NULL, "ns2:crossoverType");
	case SOAP_TYPE_ns2__crossoverSlope:
		return soap_in_ns2__crossoverSlope(soap, NULL, NULL, "ns2:crossoverSlope");
	case SOAP_TYPE_ns2__CueType:
		return soap_in_ns2__CueType(soap, NULL, NULL, "ns2:CueType");
	case SOAP_TYPE_ns2__TransferType:
		return soap_in_ns2__TransferType(soap, NULL, NULL, "ns2:TransferType");
	case SOAP_TYPE_ns2__StorageType:
		return soap_in_ns2__StorageType(soap, NULL, NULL, "ns2:StorageType");
	case SOAP_TYPE_ns2__Category:
		return soap_in_ns2__Category(soap, NULL, NULL, "ns2:Category");
	case SOAP_TYPE_ns2__CueMarkerType:
		return soap_in_ns2__CueMarkerType(soap, NULL, NULL, "ns2:CueMarkerType");
	case SOAP_TYPE_ns2__LensFormat:
		return soap_in_ns2__LensFormat(soap, NULL, NULL, "ns2:LensFormat");
	case SOAP_TYPE_ns2__ErrorType:
		return soap_in_ns2__ErrorType(soap, NULL, NULL, "ns2:ErrorType");
	case SOAP_TYPE_ns2__MPAARating:
		return soap_in_ns2__MPAARating(soap, NULL, NULL, "ns2:MPAARating");
	case SOAP_TYPE_ns2__timeZone:
		return soap_in_ns2__timeZone(soap, NULL, NULL, "ns2:timeZone");
	case SOAP_TYPE_ns2__filterID:
		return soap_in_ns2__filterID(soap, NULL, NULL, "ns2:filterID");
	case SOAP_TYPE_ns2__UUID:
		return soap_in_ns2__UUID(soap, NULL, NULL, "ns2:UUID");
	case SOAP_TYPE_ns2__keyValuePair:
		return soap_in_ns2__keyValuePair(soap, NULL, NULL, "ns2:keyValuePair");
	case SOAP_TYPE_ns2__audioStreamInfo:
		return soap_in_ns2__audioStreamInfo(soap, NULL, NULL, "ns2:audioStreamInfo");
	case SOAP_TYPE_ns2__fault:
		return soap_in_ns2__fault(soap, NULL, NULL, "ns2:fault");
	case SOAP_TYPE_ns2__macro:
		return soap_in_ns2__macro(soap, NULL, NULL, "ns2:macro");
	case SOAP_TYPE_ns2__allPassFilter:
		return soap_in_ns2__allPassFilter(soap, NULL, NULL, "ns2:allPassFilter");
	case SOAP_TYPE_ns2__parametricFilter:
		return soap_in_ns2__parametricFilter(soap, NULL, NULL, "ns2:parametricFilter");
	case SOAP_TYPE_ns2__shelfFilter:
		return soap_in_ns2__shelfFilter(soap, NULL, NULL, "ns2:shelfFilter");
	case SOAP_TYPE_ns2__crossoverFilter:
		return soap_in_ns2__crossoverFilter(soap, NULL, NULL, "ns2:crossoverFilter");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns4__deleteWayFilterRequest:
		return soap_in_PointerTo_ns4__deleteWayFilterRequest(soap, NULL, NULL, "ns4:deleteWayFilterRequest");
	case SOAP_TYPE_PointerTo_ns4__setWayFilterRequest:
		return soap_in_PointerTo_ns4__setWayFilterRequest(soap, NULL, NULL, "ns4:setWayFilterRequest");
	case SOAP_TYPE_PointerTo_ns4__getWayFiltersRequest:
		return soap_in_PointerTo_ns4__getWayFiltersRequest(soap, NULL, NULL, "ns4:getWayFiltersRequest");
	case SOAP_TYPE_PointerTo_ns4__getWayParamsRequest:
		return soap_in_PointerTo_ns4__getWayParamsRequest(soap, NULL, NULL, "ns4:getWayParamsRequest");
	case SOAP_TYPE_PointerTo_ns4__setWayParamsRequest:
		return soap_in_PointerTo_ns4__setWayParamsRequest(soap, NULL, NULL, "ns4:setWayParamsRequest");
	case SOAP_TYPE_PointerTo_ns4__getSystemVersionsRequest:
		return soap_in_PointerTo_ns4__getSystemVersionsRequest(soap, NULL, NULL, "ns4:getSystemVersionsRequest");
	case SOAP_TYPE_PointerTo_ns4__getCertificateRequest:
		return soap_in_PointerTo_ns4__getCertificateRequest(soap, NULL, NULL, "ns4:getCertificateRequest");
	case SOAP_TYPE_PointerTo_ns3__performSystemUpgradeRequest:
		return soap_in_PointerTo_ns3__performSystemUpgradeRequest(soap, NULL, NULL, "ns3:performSystemUpgradeRequest");
	case SOAP_TYPE_PointerTo_ns3__enableAutoEqModeRequest:
		return soap_in_PointerTo_ns3__enableAutoEqModeRequest(soap, NULL, NULL, "ns3:enableAutoEqModeRequest");
	case SOAP_TYPE_PointerTo_ns3__isAutoEqModeEnabledRequest:
		return soap_in_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, NULL, NULL, "ns3:isAutoEqModeEnabledRequest");
	case SOAP_TYPE_PointerTo_ns3__setTimeZoneRequest:
		return soap_in_PointerTo_ns3__setTimeZoneRequest(soap, NULL, NULL, "ns3:setTimeZoneRequest");
	case SOAP_TYPE_PointerTo_ns3__getTimeZoneRequest:
		return soap_in_PointerTo_ns3__getTimeZoneRequest(soap, NULL, NULL, "ns3:getTimeZoneRequest");
	case SOAP_TYPE_PointerTo_ns3__getDeviceAlarmsRequest:
		return soap_in_PointerTo_ns3__getDeviceAlarmsRequest(soap, NULL, NULL, "ns3:getDeviceAlarmsRequest");
	case SOAP_TYPE_PointerTo_ns3__getDeviceInfoRequest:
		return soap_in_PointerTo_ns3__getDeviceInfoRequest(soap, NULL, NULL, "ns3:getDeviceInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__enableGlobalEqRequest:
		return soap_in_PointerTo_ns3__enableGlobalEqRequest(soap, NULL, NULL, "ns3:enableGlobalEqRequest");
	case SOAP_TYPE_PointerTo_ns3__isGlobalEqEnabledRequest:
		return soap_in_PointerTo_ns3__isGlobalEqEnabledRequest(soap, NULL, NULL, "ns3:isGlobalEqEnabledRequest");
	case SOAP_TYPE_PointerTo_ns3__enableBassManagementRequest:
		return soap_in_PointerTo_ns3__enableBassManagementRequest(soap, NULL, NULL, "ns3:enableBassManagementRequest");
	case SOAP_TYPE_PointerTo_ns3__isBassManagementEnabledRequest:
		return soap_in_PointerTo_ns3__isBassManagementEnabledRequest(soap, NULL, NULL, "ns3:isBassManagementEnabledRequest");
	case SOAP_TYPE_PointerTo_ns3__setTestSignalModeRequest:
		return soap_in_PointerTo_ns3__setTestSignalModeRequest(soap, NULL, NULL, "ns3:setTestSignalModeRequest");
	case SOAP_TYPE_PointerTo_ns3__getTestSignalModeRequest:
		return soap_in_PointerTo_ns3__getTestSignalModeRequest(soap, NULL, NULL, "ns3:getTestSignalModeRequest");
	case SOAP_TYPE_PointerTo_ns3__setTestSignalOutputRequest:
		return soap_in_PointerTo_ns3__setTestSignalOutputRequest(soap, NULL, NULL, "ns3:setTestSignalOutputRequest");
	case SOAP_TYPE_PointerTo_ns3__getTestSignalOutputRequest:
		return soap_in_PointerTo_ns3__getTestSignalOutputRequest(soap, NULL, NULL, "ns3:getTestSignalOutputRequest");
	case SOAP_TYPE_PointerTo_ns3__setAtmosConfigRequest:
		return soap_in_PointerTo_ns3__setAtmosConfigRequest(soap, NULL, NULL, "ns3:setAtmosConfigRequest");
	case SOAP_TYPE_PointerTo_ns3__getAtmosConfigRequest:
		return soap_in_PointerTo_ns3__getAtmosConfigRequest(soap, NULL, NULL, "ns3:getAtmosConfigRequest");
	case SOAP_TYPE_PointerTo_ns3__getAtmosConfigInfoRequest:
		return soap_in_PointerTo_ns3__getAtmosConfigInfoRequest(soap, NULL, NULL, "ns3:getAtmosConfigInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__getAudioStreamInfoRequest:
		return soap_in_PointerTo_ns3__getAudioStreamInfoRequest(soap, NULL, NULL, "ns3:getAudioStreamInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__isAtmosContentRequest:
		return soap_in_PointerTo_ns3__isAtmosContentRequest(soap, NULL, NULL, "ns3:isAtmosContentRequest");
	case SOAP_TYPE_PointerTo_ns3__setMuteRequest:
		return soap_in_PointerTo_ns3__setMuteRequest(soap, NULL, NULL, "ns3:setMuteRequest");
	case SOAP_TYPE_PointerTo_ns3__getMuteRequest:
		return soap_in_PointerTo_ns3__getMuteRequest(soap, NULL, NULL, "ns3:getMuteRequest");
	case SOAP_TYPE_PointerTo_ns3__setGainRequest:
		return soap_in_PointerTo_ns3__setGainRequest(soap, NULL, NULL, "ns3:setGainRequest");
	case SOAP_TYPE_PointerTo_ns3__getGainRequest:
		return soap_in_PointerTo_ns3__getGainRequest(soap, NULL, NULL, "ns3:getGainRequest");
	case SOAP_TYPE_PointerTo_ns3__setCurrentMacroRequest:
		return soap_in_PointerTo_ns3__setCurrentMacroRequest(soap, NULL, NULL, "ns3:setCurrentMacroRequest");
	case SOAP_TYPE_PointerTo_ns3__getCurrentMacroRequest:
		return soap_in_PointerTo_ns3__getCurrentMacroRequest(soap, NULL, NULL, "ns3:getCurrentMacroRequest");
	case SOAP_TYPE_PointerTo_ns3__listMacrosRequest:
		return soap_in_PointerTo_ns3__listMacrosRequest(soap, NULL, NULL, "ns3:listMacrosRequest");
	case SOAP_TYPE_PointerTons2__fault:
		return soap_in_PointerTons2__fault(soap, NULL, NULL, "ns2:fault");
	case SOAP_TYPE_PointerTons2__allPassFilter:
		return soap_in_PointerTons2__allPassFilter(soap, NULL, NULL, "ns2:allPassFilter");
	case SOAP_TYPE_PointerTons2__parametricFilter:
		return soap_in_PointerTons2__parametricFilter(soap, NULL, NULL, "ns2:parametricFilter");
	case SOAP_TYPE_PointerTons2__shelfFilter:
		return soap_in_PointerTons2__shelfFilter(soap, NULL, NULL, "ns2:shelfFilter");
	case SOAP_TYPE_PointerTons2__crossoverFilter:
		return soap_in_PointerTons2__crossoverFilter(soap, NULL, NULL, "ns2:crossoverFilter");
	case SOAP_TYPE_PointerTo_ns2__alarm:
		return soap_in_PointerTo_ns2__alarm(soap, NULL, NULL, "ns2:alarm");
	case SOAP_TYPE_PointerTons2__keyValuePair:
		return soap_in_PointerTons2__keyValuePair(soap, NULL, NULL, "ns2:keyValuePair");
	case SOAP_TYPE_PointerTons2__testSignalObjectPath:
		return soap_in_PointerTons2__testSignalObjectPath(soap, NULL, NULL, "ns2:testSignalObjectPath");
	case SOAP_TYPE_PointerTons2__bedChannelId:
		return soap_in_PointerTons2__bedChannelId(soap, NULL, NULL, "ns2:bedChannelId");
	case SOAP_TYPE_PointerTons2__lastAtmosConfigPushErrorType:
		return soap_in_PointerTons2__lastAtmosConfigPushErrorType(soap, NULL, NULL, "ns2:lastAtmosConfigPushErrorType");
	case SOAP_TYPE_PointerTons2__lastAtmosConfigPushStatus:
		return soap_in_PointerTons2__lastAtmosConfigPushStatus(soap, NULL, NULL, "ns2:lastAtmosConfigPushStatus");
	case SOAP_TYPE_PointerTons2__audioStreamInfo:
		return soap_in_PointerTons2__audioStreamInfo(soap, NULL, NULL, "ns2:audioStreamInfo");
	case SOAP_TYPE_PointerTons2__macro:
		return soap_in_PointerTons2__macro(soap, NULL, NULL, "ns2:macro");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__UUID:
		return soap_in_PointerTons2__UUID(soap, NULL, NULL, "ns2:UUID");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:timeZone"))
		{	*type = SOAP_TYPE_ns2__timeZone;
			return soap_in_ns2__timeZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:filterID"))
		{	*type = SOAP_TYPE_ns2__filterID;
			return soap_in_ns2__filterID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UUID"))
		{	*type = SOAP_TYPE_ns2__UUID;
			return soap_in_ns2__UUID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:keyValuePair"))
		{	*type = SOAP_TYPE_ns2__keyValuePair;
			return soap_in_ns2__keyValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:audioStreamInfo"))
		{	*type = SOAP_TYPE_ns2__audioStreamInfo;
			return soap_in_ns2__audioStreamInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:fault"))
		{	*type = SOAP_TYPE_ns2__fault;
			return soap_in_ns2__fault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:macro"))
		{	*type = SOAP_TYPE_ns2__macro;
			return soap_in_ns2__macro(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:allPassFilter"))
		{	*type = SOAP_TYPE_ns2__allPassFilter;
			return soap_in_ns2__allPassFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:parametricFilter"))
		{	*type = SOAP_TYPE_ns2__parametricFilter;
			return soap_in_ns2__parametricFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:shelfFilter"))
		{	*type = SOAP_TYPE_ns2__shelfFilter;
			return soap_in_ns2__shelfFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:crossoverFilter"))
		{	*type = SOAP_TYPE_ns2__crossoverFilter;
			return soap_in_ns2__crossoverFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Duration"))
		{	*type = SOAP_TYPE_ns2__Duration;
			return soap_in_ns2__Duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:alarm-type"))
		{	*type = SOAP_TYPE__ns2__alarm_type;
			return soap_in__ns2__alarm_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:alarm-severity"))
		{	*type = SOAP_TYPE__ns2__alarm_severity;
			return soap_in__ns2__alarm_severity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:polarity"))
		{	*type = SOAP_TYPE_ns2__polarity;
			return soap_in_ns2__polarity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:testSignalObjectPath"))
		{	*type = SOAP_TYPE_ns2__testSignalObjectPath;
			return soap_in_ns2__testSignalObjectPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:testSignalOutputMode"))
		{	*type = SOAP_TYPE_ns2__testSignalOutputMode;
			return soap_in_ns2__testSignalOutputMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:lastAtmosConfigPushErrorType"))
		{	*type = SOAP_TYPE_ns2__lastAtmosConfigPushErrorType;
			return soap_in_ns2__lastAtmosConfigPushErrorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:lastAtmosConfigPushStatus"))
		{	*type = SOAP_TYPE_ns2__lastAtmosConfigPushStatus;
			return soap_in_ns2__lastAtmosConfigPushStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:testSignalType"))
		{	*type = SOAP_TYPE_ns2__testSignalType;
			return soap_in_ns2__testSignalType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:bedChannelId"))
		{	*type = SOAP_TYPE_ns2__bedChannelId;
			return soap_in_ns2__bedChannelId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:acmod"))
		{	*type = SOAP_TYPE_ns2__acmod;
			return soap_in_ns2__acmod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:audioStreamType"))
		{	*type = SOAP_TYPE_ns2__audioStreamType;
			return soap_in_ns2__audioStreamType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:atmosContentStatus"))
		{	*type = SOAP_TYPE_ns2__atmosContentStatus;
			return soap_in_ns2__atmosContentStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:shelfType"))
		{	*type = SOAP_TYPE_ns2__shelfType;
			return soap_in_ns2__shelfType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:crossoverFilterType"))
		{	*type = SOAP_TYPE_ns2__crossoverFilterType;
			return soap_in_ns2__crossoverFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:crossoverType"))
		{	*type = SOAP_TYPE_ns2__crossoverType;
			return soap_in_ns2__crossoverType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:crossoverSlope"))
		{	*type = SOAP_TYPE_ns2__crossoverSlope;
			return soap_in_ns2__crossoverSlope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CueType"))
		{	*type = SOAP_TYPE_ns2__CueType;
			return soap_in_ns2__CueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TransferType"))
		{	*type = SOAP_TYPE_ns2__TransferType;
			return soap_in_ns2__TransferType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StorageType"))
		{	*type = SOAP_TYPE_ns2__StorageType;
			return soap_in_ns2__StorageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Category"))
		{	*type = SOAP_TYPE_ns2__Category;
			return soap_in_ns2__Category(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CueMarkerType"))
		{	*type = SOAP_TYPE_ns2__CueMarkerType;
			return soap_in_ns2__CueMarkerType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LensFormat"))
		{	*type = SOAP_TYPE_ns2__LensFormat;
			return soap_in_ns2__LensFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ErrorType"))
		{	*type = SOAP_TYPE_ns2__ErrorType;
			return soap_in_ns2__ErrorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MPAARating"))
		{	*type = SOAP_TYPE_ns2__MPAARating;
			return soap_in_ns2__MPAARating(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns4:deleteWayFilterResponse"))
		{	*type = SOAP_TYPE__ns4__deleteWayFilterResponse;
			return soap_in__ns4__deleteWayFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:deleteWayFilterRequest"))
		{	*type = SOAP_TYPE__ns4__deleteWayFilterRequest;
			return soap_in__ns4__deleteWayFilterRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:setWayFilterResponse"))
		{	*type = SOAP_TYPE__ns4__setWayFilterResponse;
			return soap_in__ns4__setWayFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:setWayFilterRequest"))
		{	*type = SOAP_TYPE__ns4__setWayFilterRequest;
			return soap_in__ns4__setWayFilterRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getWayFiltersResponse"))
		{	*type = SOAP_TYPE__ns4__getWayFiltersResponse;
			return soap_in__ns4__getWayFiltersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getWayFiltersRequest"))
		{	*type = SOAP_TYPE__ns4__getWayFiltersRequest;
			return soap_in__ns4__getWayFiltersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getWayParamsResponse"))
		{	*type = SOAP_TYPE__ns4__getWayParamsResponse;
			return soap_in__ns4__getWayParamsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getWayParamsRequest"))
		{	*type = SOAP_TYPE__ns4__getWayParamsRequest;
			return soap_in__ns4__getWayParamsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:setWayParamsResponse"))
		{	*type = SOAP_TYPE__ns4__setWayParamsResponse;
			return soap_in__ns4__setWayParamsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:setWayParamsRequest"))
		{	*type = SOAP_TYPE__ns4__setWayParamsRequest;
			return soap_in__ns4__setWayParamsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getSystemVersionsResponse"))
		{	*type = SOAP_TYPE__ns4__getSystemVersionsResponse;
			return soap_in__ns4__getSystemVersionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getSystemVersionsRequest"))
		{	*type = SOAP_TYPE__ns4__getSystemVersionsRequest;
			return soap_in__ns4__getSystemVersionsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getCertificateResponse"))
		{	*type = SOAP_TYPE__ns4__getCertificateResponse;
			return soap_in__ns4__getCertificateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:getCertificateRequest"))
		{	*type = SOAP_TYPE__ns4__getCertificateRequest;
			return soap_in__ns4__getCertificateRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:performSystemUpgradeResponse"))
		{	*type = SOAP_TYPE__ns3__performSystemUpgradeResponse;
			return soap_in__ns3__performSystemUpgradeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:performSystemUpgradeRequest"))
		{	*type = SOAP_TYPE__ns3__performSystemUpgradeRequest;
			return soap_in__ns3__performSystemUpgradeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:enableAutoEqModeResponse"))
		{	*type = SOAP_TYPE__ns3__enableAutoEqModeResponse;
			return soap_in__ns3__enableAutoEqModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:enableAutoEqModeRequest"))
		{	*type = SOAP_TYPE__ns3__enableAutoEqModeRequest;
			return soap_in__ns3__enableAutoEqModeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isAutoEqModeEnabledResponse"))
		{	*type = SOAP_TYPE__ns3__isAutoEqModeEnabledResponse;
			return soap_in__ns3__isAutoEqModeEnabledResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isAutoEqModeEnabledRequest"))
		{	*type = SOAP_TYPE__ns3__isAutoEqModeEnabledRequest;
			return soap_in__ns3__isAutoEqModeEnabledRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setTimeZoneResponse"))
		{	*type = SOAP_TYPE__ns3__setTimeZoneResponse;
			return soap_in__ns3__setTimeZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setTimeZoneRequest"))
		{	*type = SOAP_TYPE__ns3__setTimeZoneRequest;
			return soap_in__ns3__setTimeZoneRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getTimeZoneResponse"))
		{	*type = SOAP_TYPE__ns3__getTimeZoneResponse;
			return soap_in__ns3__getTimeZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getTimeZoneRequest"))
		{	*type = SOAP_TYPE__ns3__getTimeZoneRequest;
			return soap_in__ns3__getTimeZoneRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getDeviceAlarmsResponse"))
		{	*type = SOAP_TYPE__ns3__getDeviceAlarmsResponse;
			return soap_in__ns3__getDeviceAlarmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getDeviceAlarmsRequest"))
		{	*type = SOAP_TYPE__ns3__getDeviceAlarmsRequest;
			return soap_in__ns3__getDeviceAlarmsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getDeviceInfoResponse"))
		{	*type = SOAP_TYPE__ns3__getDeviceInfoResponse;
			return soap_in__ns3__getDeviceInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getDeviceInfoRequest"))
		{	*type = SOAP_TYPE__ns3__getDeviceInfoRequest;
			return soap_in__ns3__getDeviceInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:enableGlobalEqResponse"))
		{	*type = SOAP_TYPE__ns3__enableGlobalEqResponse;
			return soap_in__ns3__enableGlobalEqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:enableGlobalEqRequest"))
		{	*type = SOAP_TYPE__ns3__enableGlobalEqRequest;
			return soap_in__ns3__enableGlobalEqRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isGlobalEqEnabledResponse"))
		{	*type = SOAP_TYPE__ns3__isGlobalEqEnabledResponse;
			return soap_in__ns3__isGlobalEqEnabledResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isGlobalEqEnabledRequest"))
		{	*type = SOAP_TYPE__ns3__isGlobalEqEnabledRequest;
			return soap_in__ns3__isGlobalEqEnabledRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:enableBassManagementResponse"))
		{	*type = SOAP_TYPE__ns3__enableBassManagementResponse;
			return soap_in__ns3__enableBassManagementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:enableBassManagementRequest"))
		{	*type = SOAP_TYPE__ns3__enableBassManagementRequest;
			return soap_in__ns3__enableBassManagementRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isBassManagementEnabledResponse"))
		{	*type = SOAP_TYPE__ns3__isBassManagementEnabledResponse;
			return soap_in__ns3__isBassManagementEnabledResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isBassManagementEnabledRequest"))
		{	*type = SOAP_TYPE__ns3__isBassManagementEnabledRequest;
			return soap_in__ns3__isBassManagementEnabledRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setTestSignalModeResponse"))
		{	*type = SOAP_TYPE__ns3__setTestSignalModeResponse;
			return soap_in__ns3__setTestSignalModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setTestSignalModeRequest"))
		{	*type = SOAP_TYPE__ns3__setTestSignalModeRequest;
			return soap_in__ns3__setTestSignalModeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getTestSignalModeResponse"))
		{	*type = SOAP_TYPE__ns3__getTestSignalModeResponse;
			return soap_in__ns3__getTestSignalModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getTestSignalModeRequest"))
		{	*type = SOAP_TYPE__ns3__getTestSignalModeRequest;
			return soap_in__ns3__getTestSignalModeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setTestSignalOutputResponse"))
		{	*type = SOAP_TYPE__ns3__setTestSignalOutputResponse;
			return soap_in__ns3__setTestSignalOutputResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setTestSignalOutputRequest"))
		{	*type = SOAP_TYPE__ns3__setTestSignalOutputRequest;
			return soap_in__ns3__setTestSignalOutputRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getTestSignalOutputResponse"))
		{	*type = SOAP_TYPE__ns3__getTestSignalOutputResponse;
			return soap_in__ns3__getTestSignalOutputResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getTestSignalOutputRequest"))
		{	*type = SOAP_TYPE__ns3__getTestSignalOutputRequest;
			return soap_in__ns3__getTestSignalOutputRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getAtmosConfigInfoResponse"))
		{	*type = SOAP_TYPE__ns3__getAtmosConfigInfoResponse;
			return soap_in__ns3__getAtmosConfigInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getAtmosConfigInfoRequest"))
		{	*type = SOAP_TYPE__ns3__getAtmosConfigInfoRequest;
			return soap_in__ns3__getAtmosConfigInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setAtmosConfigResponse"))
		{	*type = SOAP_TYPE__ns3__setAtmosConfigResponse;
			return soap_in__ns3__setAtmosConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setAtmosConfigRequest"))
		{	*type = SOAP_TYPE__ns3__setAtmosConfigRequest;
			return soap_in__ns3__setAtmosConfigRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getAtmosConfigResponse"))
		{	*type = SOAP_TYPE__ns3__getAtmosConfigResponse;
			return soap_in__ns3__getAtmosConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getAtmosConfigRequest"))
		{	*type = SOAP_TYPE__ns3__getAtmosConfigRequest;
			return soap_in__ns3__getAtmosConfigRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getAudioStreamInfoResponse"))
		{	*type = SOAP_TYPE__ns3__getAudioStreamInfoResponse;
			return soap_in__ns3__getAudioStreamInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getAudioStreamInfoRequest"))
		{	*type = SOAP_TYPE__ns3__getAudioStreamInfoRequest;
			return soap_in__ns3__getAudioStreamInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isAtmosContentResponse"))
		{	*type = SOAP_TYPE__ns3__isAtmosContentResponse;
			return soap_in__ns3__isAtmosContentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:isAtmosContentRequest"))
		{	*type = SOAP_TYPE__ns3__isAtmosContentRequest;
			return soap_in__ns3__isAtmosContentRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setMuteResponse"))
		{	*type = SOAP_TYPE__ns3__setMuteResponse;
			return soap_in__ns3__setMuteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setMuteRequest"))
		{	*type = SOAP_TYPE__ns3__setMuteRequest;
			return soap_in__ns3__setMuteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getMuteResponse"))
		{	*type = SOAP_TYPE__ns3__getMuteResponse;
			return soap_in__ns3__getMuteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getMuteRequest"))
		{	*type = SOAP_TYPE__ns3__getMuteRequest;
			return soap_in__ns3__getMuteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setGainResponse"))
		{	*type = SOAP_TYPE__ns3__setGainResponse;
			return soap_in__ns3__setGainResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setGainRequest"))
		{	*type = SOAP_TYPE__ns3__setGainRequest;
			return soap_in__ns3__setGainRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getGainResponse"))
		{	*type = SOAP_TYPE__ns3__getGainResponse;
			return soap_in__ns3__getGainResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getGainRequest"))
		{	*type = SOAP_TYPE__ns3__getGainRequest;
			return soap_in__ns3__getGainRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setCurrentMacroResponse"))
		{	*type = SOAP_TYPE__ns3__setCurrentMacroResponse;
			return soap_in__ns3__setCurrentMacroResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setCurrentMacroRequest"))
		{	*type = SOAP_TYPE__ns3__setCurrentMacroRequest;
			return soap_in__ns3__setCurrentMacroRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getCurrentMacroResponse"))
		{	*type = SOAP_TYPE__ns3__getCurrentMacroResponse;
			return soap_in__ns3__getCurrentMacroResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:getCurrentMacroRequest"))
		{	*type = SOAP_TYPE__ns3__getCurrentMacroRequest;
			return soap_in__ns3__getCurrentMacroRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:listMacrosResponse"))
		{	*type = SOAP_TYPE__ns3__listMacrosResponse;
			return soap_in__ns3__listMacrosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:listMacrosRequest"))
		{	*type = SOAP_TYPE__ns3__listMacrosRequest;
			return soap_in__ns3__listMacrosRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:alarm"))
		{	*type = SOAP_TYPE__ns2__alarm;
			return soap_in__ns2__alarm(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns2__Duration:
		return soap_out_ns2__Duration(soap, tag, id, (const LONG64 *)ptr, "ns2:Duration");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__ns2__alarm_type:
		return soap_out__ns2__alarm_type(soap, tag, id, (const enum _ns2__alarm_type *)ptr, "ns2:alarm-type");
	case SOAP_TYPE__ns2__alarm_severity:
		return soap_out__ns2__alarm_severity(soap, tag, id, (const enum _ns2__alarm_severity *)ptr, "ns2:alarm-severity");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns2__polarity:
		return soap_out_ns2__polarity(soap, tag, id, (const enum ns2__polarity *)ptr, "ns2:polarity");
	case SOAP_TYPE_ns2__testSignalObjectPath:
		return soap_out_ns2__testSignalObjectPath(soap, tag, id, (const enum ns2__testSignalObjectPath *)ptr, "ns2:testSignalObjectPath");
	case SOAP_TYPE_ns2__testSignalOutputMode:
		return soap_out_ns2__testSignalOutputMode(soap, tag, id, (const enum ns2__testSignalOutputMode *)ptr, "ns2:testSignalOutputMode");
	case SOAP_TYPE_ns2__lastAtmosConfigPushErrorType:
		return soap_out_ns2__lastAtmosConfigPushErrorType(soap, tag, id, (const enum ns2__lastAtmosConfigPushErrorType *)ptr, "ns2:lastAtmosConfigPushErrorType");
	case SOAP_TYPE_ns2__lastAtmosConfigPushStatus:
		return soap_out_ns2__lastAtmosConfigPushStatus(soap, tag, id, (const enum ns2__lastAtmosConfigPushStatus *)ptr, "ns2:lastAtmosConfigPushStatus");
	case SOAP_TYPE_ns2__testSignalType:
		return soap_out_ns2__testSignalType(soap, tag, id, (const enum ns2__testSignalType *)ptr, "ns2:testSignalType");
	case SOAP_TYPE_ns2__bedChannelId:
		return soap_out_ns2__bedChannelId(soap, tag, id, (const enum ns2__bedChannelId *)ptr, "ns2:bedChannelId");
	case SOAP_TYPE_ns2__acmod:
		return soap_out_ns2__acmod(soap, tag, id, (const enum ns2__acmod *)ptr, "ns2:acmod");
	case SOAP_TYPE_ns2__audioStreamType:
		return soap_out_ns2__audioStreamType(soap, tag, id, (const enum ns2__audioStreamType *)ptr, "ns2:audioStreamType");
	case SOAP_TYPE_ns2__atmosContentStatus:
		return soap_out_ns2__atmosContentStatus(soap, tag, id, (const enum ns2__atmosContentStatus *)ptr, "ns2:atmosContentStatus");
	case SOAP_TYPE_ns2__shelfType:
		return soap_out_ns2__shelfType(soap, tag, id, (const enum ns2__shelfType *)ptr, "ns2:shelfType");
	case SOAP_TYPE_ns2__crossoverFilterType:
		return soap_out_ns2__crossoverFilterType(soap, tag, id, (const enum ns2__crossoverFilterType *)ptr, "ns2:crossoverFilterType");
	case SOAP_TYPE_ns2__crossoverType:
		return soap_out_ns2__crossoverType(soap, tag, id, (const enum ns2__crossoverType *)ptr, "ns2:crossoverType");
	case SOAP_TYPE_ns2__crossoverSlope:
		return soap_out_ns2__crossoverSlope(soap, tag, id, (const enum ns2__crossoverSlope *)ptr, "ns2:crossoverSlope");
	case SOAP_TYPE_ns2__CueType:
		return soap_out_ns2__CueType(soap, tag, id, (const enum ns2__CueType *)ptr, "ns2:CueType");
	case SOAP_TYPE_ns2__TransferType:
		return soap_out_ns2__TransferType(soap, tag, id, (const enum ns2__TransferType *)ptr, "ns2:TransferType");
	case SOAP_TYPE_ns2__StorageType:
		return soap_out_ns2__StorageType(soap, tag, id, (const enum ns2__StorageType *)ptr, "ns2:StorageType");
	case SOAP_TYPE_ns2__Category:
		return soap_out_ns2__Category(soap, tag, id, (const enum ns2__Category *)ptr, "ns2:Category");
	case SOAP_TYPE_ns2__CueMarkerType:
		return soap_out_ns2__CueMarkerType(soap, tag, id, (const enum ns2__CueMarkerType *)ptr, "ns2:CueMarkerType");
	case SOAP_TYPE_ns2__LensFormat:
		return soap_out_ns2__LensFormat(soap, tag, id, (const enum ns2__LensFormat *)ptr, "ns2:LensFormat");
	case SOAP_TYPE_ns2__ErrorType:
		return soap_out_ns2__ErrorType(soap, tag, id, (const enum ns2__ErrorType *)ptr, "ns2:ErrorType");
	case SOAP_TYPE_ns2__MPAARating:
		return soap_out_ns2__MPAARating(soap, tag, id, (const enum ns2__MPAARating *)ptr, "ns2:MPAARating");
	case SOAP_TYPE_ns2__timeZone:
		return soap_out_ns2__timeZone(soap, tag, id, (const std::string *)ptr, "ns2:timeZone");
	case SOAP_TYPE_ns2__filterID:
		return soap_out_ns2__filterID(soap, tag, id, (const std::string *)ptr, "ns2:filterID");
	case SOAP_TYPE_ns2__UUID:
		return soap_out_ns2__UUID(soap, tag, id, (const std::string *)ptr, "ns2:UUID");
	case SOAP_TYPE__ns4__deleteWayFilterResponse:
		return ((_ns4__deleteWayFilterResponse *)ptr)->soap_out(soap, "ns4:deleteWayFilterResponse", id, NULL);
	case SOAP_TYPE__ns4__deleteWayFilterRequest:
		return ((_ns4__deleteWayFilterRequest *)ptr)->soap_out(soap, "ns4:deleteWayFilterRequest", id, NULL);
	case SOAP_TYPE__ns4__setWayFilterResponse:
		return ((_ns4__setWayFilterResponse *)ptr)->soap_out(soap, "ns4:setWayFilterResponse", id, NULL);
	case SOAP_TYPE__ns4__setWayFilterRequest:
		return ((_ns4__setWayFilterRequest *)ptr)->soap_out(soap, "ns4:setWayFilterRequest", id, NULL);
	case SOAP_TYPE__ns4__getWayFiltersResponse:
		return ((_ns4__getWayFiltersResponse *)ptr)->soap_out(soap, "ns4:getWayFiltersResponse", id, NULL);
	case SOAP_TYPE__ns4__getWayFiltersRequest:
		return ((_ns4__getWayFiltersRequest *)ptr)->soap_out(soap, "ns4:getWayFiltersRequest", id, NULL);
	case SOAP_TYPE__ns4__getWayParamsResponse:
		return ((_ns4__getWayParamsResponse *)ptr)->soap_out(soap, "ns4:getWayParamsResponse", id, NULL);
	case SOAP_TYPE__ns4__getWayParamsRequest:
		return ((_ns4__getWayParamsRequest *)ptr)->soap_out(soap, "ns4:getWayParamsRequest", id, NULL);
	case SOAP_TYPE__ns4__setWayParamsResponse:
		return ((_ns4__setWayParamsResponse *)ptr)->soap_out(soap, "ns4:setWayParamsResponse", id, NULL);
	case SOAP_TYPE__ns4__setWayParamsRequest:
		return ((_ns4__setWayParamsRequest *)ptr)->soap_out(soap, "ns4:setWayParamsRequest", id, NULL);
	case SOAP_TYPE__ns4__getSystemVersionsResponse:
		return ((_ns4__getSystemVersionsResponse *)ptr)->soap_out(soap, "ns4:getSystemVersionsResponse", id, NULL);
	case SOAP_TYPE__ns4__getSystemVersionsRequest:
		return ((_ns4__getSystemVersionsRequest *)ptr)->soap_out(soap, "ns4:getSystemVersionsRequest", id, NULL);
	case SOAP_TYPE__ns4__getCertificateResponse:
		return ((_ns4__getCertificateResponse *)ptr)->soap_out(soap, "ns4:getCertificateResponse", id, NULL);
	case SOAP_TYPE__ns4__getCertificateRequest:
		return ((_ns4__getCertificateRequest *)ptr)->soap_out(soap, "ns4:getCertificateRequest", id, NULL);
	case SOAP_TYPE__ns3__performSystemUpgradeResponse:
		return ((_ns3__performSystemUpgradeResponse *)ptr)->soap_out(soap, "ns3:performSystemUpgradeResponse", id, NULL);
	case SOAP_TYPE__ns3__performSystemUpgradeRequest:
		return ((_ns3__performSystemUpgradeRequest *)ptr)->soap_out(soap, "ns3:performSystemUpgradeRequest", id, NULL);
	case SOAP_TYPE__ns3__enableAutoEqModeResponse:
		return ((_ns3__enableAutoEqModeResponse *)ptr)->soap_out(soap, "ns3:enableAutoEqModeResponse", id, NULL);
	case SOAP_TYPE__ns3__enableAutoEqModeRequest:
		return ((_ns3__enableAutoEqModeRequest *)ptr)->soap_out(soap, "ns3:enableAutoEqModeRequest", id, NULL);
	case SOAP_TYPE__ns3__isAutoEqModeEnabledResponse:
		return ((_ns3__isAutoEqModeEnabledResponse *)ptr)->soap_out(soap, "ns3:isAutoEqModeEnabledResponse", id, NULL);
	case SOAP_TYPE__ns3__isAutoEqModeEnabledRequest:
		return ((_ns3__isAutoEqModeEnabledRequest *)ptr)->soap_out(soap, "ns3:isAutoEqModeEnabledRequest", id, NULL);
	case SOAP_TYPE__ns3__setTimeZoneResponse:
		return ((_ns3__setTimeZoneResponse *)ptr)->soap_out(soap, "ns3:setTimeZoneResponse", id, NULL);
	case SOAP_TYPE__ns3__setTimeZoneRequest:
		return ((_ns3__setTimeZoneRequest *)ptr)->soap_out(soap, "ns3:setTimeZoneRequest", id, NULL);
	case SOAP_TYPE__ns3__getTimeZoneResponse:
		return ((_ns3__getTimeZoneResponse *)ptr)->soap_out(soap, "ns3:getTimeZoneResponse", id, NULL);
	case SOAP_TYPE__ns3__getTimeZoneRequest:
		return ((_ns3__getTimeZoneRequest *)ptr)->soap_out(soap, "ns3:getTimeZoneRequest", id, NULL);
	case SOAP_TYPE__ns3__getDeviceAlarmsResponse:
		return ((_ns3__getDeviceAlarmsResponse *)ptr)->soap_out(soap, "ns3:getDeviceAlarmsResponse", id, NULL);
	case SOAP_TYPE__ns3__getDeviceAlarmsRequest:
		return ((_ns3__getDeviceAlarmsRequest *)ptr)->soap_out(soap, "ns3:getDeviceAlarmsRequest", id, NULL);
	case SOAP_TYPE__ns3__getDeviceInfoResponse:
		return ((_ns3__getDeviceInfoResponse *)ptr)->soap_out(soap, "ns3:getDeviceInfoResponse", id, NULL);
	case SOAP_TYPE__ns3__getDeviceInfoRequest:
		return ((_ns3__getDeviceInfoRequest *)ptr)->soap_out(soap, "ns3:getDeviceInfoRequest", id, NULL);
	case SOAP_TYPE__ns3__enableGlobalEqResponse:
		return ((_ns3__enableGlobalEqResponse *)ptr)->soap_out(soap, "ns3:enableGlobalEqResponse", id, NULL);
	case SOAP_TYPE__ns3__enableGlobalEqRequest:
		return ((_ns3__enableGlobalEqRequest *)ptr)->soap_out(soap, "ns3:enableGlobalEqRequest", id, NULL);
	case SOAP_TYPE__ns3__isGlobalEqEnabledResponse:
		return ((_ns3__isGlobalEqEnabledResponse *)ptr)->soap_out(soap, "ns3:isGlobalEqEnabledResponse", id, NULL);
	case SOAP_TYPE__ns3__isGlobalEqEnabledRequest:
		return ((_ns3__isGlobalEqEnabledRequest *)ptr)->soap_out(soap, "ns3:isGlobalEqEnabledRequest", id, NULL);
	case SOAP_TYPE__ns3__enableBassManagementResponse:
		return ((_ns3__enableBassManagementResponse *)ptr)->soap_out(soap, "ns3:enableBassManagementResponse", id, NULL);
	case SOAP_TYPE__ns3__enableBassManagementRequest:
		return ((_ns3__enableBassManagementRequest *)ptr)->soap_out(soap, "ns3:enableBassManagementRequest", id, NULL);
	case SOAP_TYPE__ns3__isBassManagementEnabledResponse:
		return ((_ns3__isBassManagementEnabledResponse *)ptr)->soap_out(soap, "ns3:isBassManagementEnabledResponse", id, NULL);
	case SOAP_TYPE__ns3__isBassManagementEnabledRequest:
		return ((_ns3__isBassManagementEnabledRequest *)ptr)->soap_out(soap, "ns3:isBassManagementEnabledRequest", id, NULL);
	case SOAP_TYPE__ns3__setTestSignalModeResponse:
		return ((_ns3__setTestSignalModeResponse *)ptr)->soap_out(soap, "ns3:setTestSignalModeResponse", id, NULL);
	case SOAP_TYPE__ns3__setTestSignalModeRequest:
		return ((_ns3__setTestSignalModeRequest *)ptr)->soap_out(soap, "ns3:setTestSignalModeRequest", id, NULL);
	case SOAP_TYPE__ns3__getTestSignalModeResponse:
		return ((_ns3__getTestSignalModeResponse *)ptr)->soap_out(soap, "ns3:getTestSignalModeResponse", id, NULL);
	case SOAP_TYPE__ns3__getTestSignalModeRequest:
		return ((_ns3__getTestSignalModeRequest *)ptr)->soap_out(soap, "ns3:getTestSignalModeRequest", id, NULL);
	case SOAP_TYPE__ns3__setTestSignalOutputResponse:
		return ((_ns3__setTestSignalOutputResponse *)ptr)->soap_out(soap, "ns3:setTestSignalOutputResponse", id, NULL);
	case SOAP_TYPE__ns3__setTestSignalOutputRequest:
		return ((_ns3__setTestSignalOutputRequest *)ptr)->soap_out(soap, "ns3:setTestSignalOutputRequest", id, NULL);
	case SOAP_TYPE__ns3__getTestSignalOutputResponse:
		return ((_ns3__getTestSignalOutputResponse *)ptr)->soap_out(soap, "ns3:getTestSignalOutputResponse", id, NULL);
	case SOAP_TYPE__ns3__getTestSignalOutputRequest:
		return ((_ns3__getTestSignalOutputRequest *)ptr)->soap_out(soap, "ns3:getTestSignalOutputRequest", id, NULL);
	case SOAP_TYPE__ns3__getAtmosConfigInfoResponse:
		return ((_ns3__getAtmosConfigInfoResponse *)ptr)->soap_out(soap, "ns3:getAtmosConfigInfoResponse", id, NULL);
	case SOAP_TYPE__ns3__getAtmosConfigInfoRequest:
		return ((_ns3__getAtmosConfigInfoRequest *)ptr)->soap_out(soap, "ns3:getAtmosConfigInfoRequest", id, NULL);
	case SOAP_TYPE__ns3__setAtmosConfigResponse:
		return ((_ns3__setAtmosConfigResponse *)ptr)->soap_out(soap, "ns3:setAtmosConfigResponse", id, NULL);
	case SOAP_TYPE__ns3__setAtmosConfigRequest:
		return ((_ns3__setAtmosConfigRequest *)ptr)->soap_out(soap, "ns3:setAtmosConfigRequest", id, NULL);
	case SOAP_TYPE__ns3__getAtmosConfigResponse:
		return ((_ns3__getAtmosConfigResponse *)ptr)->soap_out(soap, "ns3:getAtmosConfigResponse", id, NULL);
	case SOAP_TYPE__ns3__getAtmosConfigRequest:
		return ((_ns3__getAtmosConfigRequest *)ptr)->soap_out(soap, "ns3:getAtmosConfigRequest", id, NULL);
	case SOAP_TYPE__ns3__getAudioStreamInfoResponse:
		return ((_ns3__getAudioStreamInfoResponse *)ptr)->soap_out(soap, "ns3:getAudioStreamInfoResponse", id, NULL);
	case SOAP_TYPE__ns3__getAudioStreamInfoRequest:
		return ((_ns3__getAudioStreamInfoRequest *)ptr)->soap_out(soap, "ns3:getAudioStreamInfoRequest", id, NULL);
	case SOAP_TYPE__ns3__isAtmosContentResponse:
		return ((_ns3__isAtmosContentResponse *)ptr)->soap_out(soap, "ns3:isAtmosContentResponse", id, NULL);
	case SOAP_TYPE__ns3__isAtmosContentRequest:
		return ((_ns3__isAtmosContentRequest *)ptr)->soap_out(soap, "ns3:isAtmosContentRequest", id, NULL);
	case SOAP_TYPE__ns3__setMuteResponse:
		return ((_ns3__setMuteResponse *)ptr)->soap_out(soap, "ns3:setMuteResponse", id, NULL);
	case SOAP_TYPE__ns3__setMuteRequest:
		return ((_ns3__setMuteRequest *)ptr)->soap_out(soap, "ns3:setMuteRequest", id, NULL);
	case SOAP_TYPE__ns3__getMuteResponse:
		return ((_ns3__getMuteResponse *)ptr)->soap_out(soap, "ns3:getMuteResponse", id, NULL);
	case SOAP_TYPE__ns3__getMuteRequest:
		return ((_ns3__getMuteRequest *)ptr)->soap_out(soap, "ns3:getMuteRequest", id, NULL);
	case SOAP_TYPE__ns3__setGainResponse:
		return ((_ns3__setGainResponse *)ptr)->soap_out(soap, "ns3:setGainResponse", id, NULL);
	case SOAP_TYPE__ns3__setGainRequest:
		return ((_ns3__setGainRequest *)ptr)->soap_out(soap, "ns3:setGainRequest", id, NULL);
	case SOAP_TYPE__ns3__getGainResponse:
		return ((_ns3__getGainResponse *)ptr)->soap_out(soap, "ns3:getGainResponse", id, NULL);
	case SOAP_TYPE__ns3__getGainRequest:
		return ((_ns3__getGainRequest *)ptr)->soap_out(soap, "ns3:getGainRequest", id, NULL);
	case SOAP_TYPE__ns3__setCurrentMacroResponse:
		return ((_ns3__setCurrentMacroResponse *)ptr)->soap_out(soap, "ns3:setCurrentMacroResponse", id, NULL);
	case SOAP_TYPE__ns3__setCurrentMacroRequest:
		return ((_ns3__setCurrentMacroRequest *)ptr)->soap_out(soap, "ns3:setCurrentMacroRequest", id, NULL);
	case SOAP_TYPE__ns3__getCurrentMacroResponse:
		return ((_ns3__getCurrentMacroResponse *)ptr)->soap_out(soap, "ns3:getCurrentMacroResponse", id, NULL);
	case SOAP_TYPE__ns3__getCurrentMacroRequest:
		return ((_ns3__getCurrentMacroRequest *)ptr)->soap_out(soap, "ns3:getCurrentMacroRequest", id, NULL);
	case SOAP_TYPE__ns3__listMacrosResponse:
		return ((_ns3__listMacrosResponse *)ptr)->soap_out(soap, "ns3:listMacrosResponse", id, NULL);
	case SOAP_TYPE__ns3__listMacrosRequest:
		return ((_ns3__listMacrosRequest *)ptr)->soap_out(soap, "ns3:listMacrosRequest", id, NULL);
	case SOAP_TYPE__ns2__alarm:
		return ((_ns2__alarm *)ptr)->soap_out(soap, "ns2:alarm", id, NULL);
	case SOAP_TYPE_ns2__keyValuePair:
		return ((ns2__keyValuePair *)ptr)->soap_out(soap, tag, id, "ns2:keyValuePair");
	case SOAP_TYPE_ns2__audioStreamInfo:
		return ((ns2__audioStreamInfo *)ptr)->soap_out(soap, tag, id, "ns2:audioStreamInfo");
	case SOAP_TYPE_ns2__fault:
		return ((ns2__fault *)ptr)->soap_out(soap, tag, id, "ns2:fault");
	case SOAP_TYPE_ns2__macro:
		return ((ns2__macro *)ptr)->soap_out(soap, tag, id, "ns2:macro");
	case SOAP_TYPE_ns2__allPassFilter:
		return ((ns2__allPassFilter *)ptr)->soap_out(soap, tag, id, "ns2:allPassFilter");
	case SOAP_TYPE_ns2__parametricFilter:
		return ((ns2__parametricFilter *)ptr)->soap_out(soap, tag, id, "ns2:parametricFilter");
	case SOAP_TYPE_ns2__shelfFilter:
		return ((ns2__shelfFilter *)ptr)->soap_out(soap, tag, id, "ns2:shelfFilter");
	case SOAP_TYPE_ns2__crossoverFilter:
		return ((ns2__crossoverFilter *)ptr)->soap_out(soap, tag, id, "ns2:crossoverFilter");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns4__deleteWayFilterRequest:
		return soap_out_PointerTo_ns4__deleteWayFilterRequest(soap, tag, id, (_ns4__deleteWayFilterRequest *const*)ptr, "ns4:deleteWayFilterRequest");
	case SOAP_TYPE_PointerTo_ns4__setWayFilterRequest:
		return soap_out_PointerTo_ns4__setWayFilterRequest(soap, tag, id, (_ns4__setWayFilterRequest *const*)ptr, "ns4:setWayFilterRequest");
	case SOAP_TYPE_PointerTo_ns4__getWayFiltersRequest:
		return soap_out_PointerTo_ns4__getWayFiltersRequest(soap, tag, id, (_ns4__getWayFiltersRequest *const*)ptr, "ns4:getWayFiltersRequest");
	case SOAP_TYPE_PointerTo_ns4__getWayParamsRequest:
		return soap_out_PointerTo_ns4__getWayParamsRequest(soap, tag, id, (_ns4__getWayParamsRequest *const*)ptr, "ns4:getWayParamsRequest");
	case SOAP_TYPE_PointerTo_ns4__setWayParamsRequest:
		return soap_out_PointerTo_ns4__setWayParamsRequest(soap, tag, id, (_ns4__setWayParamsRequest *const*)ptr, "ns4:setWayParamsRequest");
	case SOAP_TYPE_PointerTo_ns4__getSystemVersionsRequest:
		return soap_out_PointerTo_ns4__getSystemVersionsRequest(soap, tag, id, (_ns4__getSystemVersionsRequest *const*)ptr, "ns4:getSystemVersionsRequest");
	case SOAP_TYPE_PointerTo_ns4__getCertificateRequest:
		return soap_out_PointerTo_ns4__getCertificateRequest(soap, tag, id, (_ns4__getCertificateRequest *const*)ptr, "ns4:getCertificateRequest");
	case SOAP_TYPE_PointerTo_ns3__performSystemUpgradeRequest:
		return soap_out_PointerTo_ns3__performSystemUpgradeRequest(soap, tag, id, (_ns3__performSystemUpgradeRequest *const*)ptr, "ns3:performSystemUpgradeRequest");
	case SOAP_TYPE_PointerTo_ns3__enableAutoEqModeRequest:
		return soap_out_PointerTo_ns3__enableAutoEqModeRequest(soap, tag, id, (_ns3__enableAutoEqModeRequest *const*)ptr, "ns3:enableAutoEqModeRequest");
	case SOAP_TYPE_PointerTo_ns3__isAutoEqModeEnabledRequest:
		return soap_out_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, tag, id, (_ns3__isAutoEqModeEnabledRequest *const*)ptr, "ns3:isAutoEqModeEnabledRequest");
	case SOAP_TYPE_PointerTo_ns3__setTimeZoneRequest:
		return soap_out_PointerTo_ns3__setTimeZoneRequest(soap, tag, id, (_ns3__setTimeZoneRequest *const*)ptr, "ns3:setTimeZoneRequest");
	case SOAP_TYPE_PointerTo_ns3__getTimeZoneRequest:
		return soap_out_PointerTo_ns3__getTimeZoneRequest(soap, tag, id, (_ns3__getTimeZoneRequest *const*)ptr, "ns3:getTimeZoneRequest");
	case SOAP_TYPE_PointerTo_ns3__getDeviceAlarmsRequest:
		return soap_out_PointerTo_ns3__getDeviceAlarmsRequest(soap, tag, id, (_ns3__getDeviceAlarmsRequest *const*)ptr, "ns3:getDeviceAlarmsRequest");
	case SOAP_TYPE_PointerTo_ns3__getDeviceInfoRequest:
		return soap_out_PointerTo_ns3__getDeviceInfoRequest(soap, tag, id, (_ns3__getDeviceInfoRequest *const*)ptr, "ns3:getDeviceInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__enableGlobalEqRequest:
		return soap_out_PointerTo_ns3__enableGlobalEqRequest(soap, tag, id, (_ns3__enableGlobalEqRequest *const*)ptr, "ns3:enableGlobalEqRequest");
	case SOAP_TYPE_PointerTo_ns3__isGlobalEqEnabledRequest:
		return soap_out_PointerTo_ns3__isGlobalEqEnabledRequest(soap, tag, id, (_ns3__isGlobalEqEnabledRequest *const*)ptr, "ns3:isGlobalEqEnabledRequest");
	case SOAP_TYPE_PointerTo_ns3__enableBassManagementRequest:
		return soap_out_PointerTo_ns3__enableBassManagementRequest(soap, tag, id, (_ns3__enableBassManagementRequest *const*)ptr, "ns3:enableBassManagementRequest");
	case SOAP_TYPE_PointerTo_ns3__isBassManagementEnabledRequest:
		return soap_out_PointerTo_ns3__isBassManagementEnabledRequest(soap, tag, id, (_ns3__isBassManagementEnabledRequest *const*)ptr, "ns3:isBassManagementEnabledRequest");
	case SOAP_TYPE_PointerTo_ns3__setTestSignalModeRequest:
		return soap_out_PointerTo_ns3__setTestSignalModeRequest(soap, tag, id, (_ns3__setTestSignalModeRequest *const*)ptr, "ns3:setTestSignalModeRequest");
	case SOAP_TYPE_PointerTo_ns3__getTestSignalModeRequest:
		return soap_out_PointerTo_ns3__getTestSignalModeRequest(soap, tag, id, (_ns3__getTestSignalModeRequest *const*)ptr, "ns3:getTestSignalModeRequest");
	case SOAP_TYPE_PointerTo_ns3__setTestSignalOutputRequest:
		return soap_out_PointerTo_ns3__setTestSignalOutputRequest(soap, tag, id, (_ns3__setTestSignalOutputRequest *const*)ptr, "ns3:setTestSignalOutputRequest");
	case SOAP_TYPE_PointerTo_ns3__getTestSignalOutputRequest:
		return soap_out_PointerTo_ns3__getTestSignalOutputRequest(soap, tag, id, (_ns3__getTestSignalOutputRequest *const*)ptr, "ns3:getTestSignalOutputRequest");
	case SOAP_TYPE_PointerTo_ns3__setAtmosConfigRequest:
		return soap_out_PointerTo_ns3__setAtmosConfigRequest(soap, tag, id, (_ns3__setAtmosConfigRequest *const*)ptr, "ns3:setAtmosConfigRequest");
	case SOAP_TYPE_PointerTo_ns3__getAtmosConfigRequest:
		return soap_out_PointerTo_ns3__getAtmosConfigRequest(soap, tag, id, (_ns3__getAtmosConfigRequest *const*)ptr, "ns3:getAtmosConfigRequest");
	case SOAP_TYPE_PointerTo_ns3__getAtmosConfigInfoRequest:
		return soap_out_PointerTo_ns3__getAtmosConfigInfoRequest(soap, tag, id, (_ns3__getAtmosConfigInfoRequest *const*)ptr, "ns3:getAtmosConfigInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__getAudioStreamInfoRequest:
		return soap_out_PointerTo_ns3__getAudioStreamInfoRequest(soap, tag, id, (_ns3__getAudioStreamInfoRequest *const*)ptr, "ns3:getAudioStreamInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__isAtmosContentRequest:
		return soap_out_PointerTo_ns3__isAtmosContentRequest(soap, tag, id, (_ns3__isAtmosContentRequest *const*)ptr, "ns3:isAtmosContentRequest");
	case SOAP_TYPE_PointerTo_ns3__setMuteRequest:
		return soap_out_PointerTo_ns3__setMuteRequest(soap, tag, id, (_ns3__setMuteRequest *const*)ptr, "ns3:setMuteRequest");
	case SOAP_TYPE_PointerTo_ns3__getMuteRequest:
		return soap_out_PointerTo_ns3__getMuteRequest(soap, tag, id, (_ns3__getMuteRequest *const*)ptr, "ns3:getMuteRequest");
	case SOAP_TYPE_PointerTo_ns3__setGainRequest:
		return soap_out_PointerTo_ns3__setGainRequest(soap, tag, id, (_ns3__setGainRequest *const*)ptr, "ns3:setGainRequest");
	case SOAP_TYPE_PointerTo_ns3__getGainRequest:
		return soap_out_PointerTo_ns3__getGainRequest(soap, tag, id, (_ns3__getGainRequest *const*)ptr, "ns3:getGainRequest");
	case SOAP_TYPE_PointerTo_ns3__setCurrentMacroRequest:
		return soap_out_PointerTo_ns3__setCurrentMacroRequest(soap, tag, id, (_ns3__setCurrentMacroRequest *const*)ptr, "ns3:setCurrentMacroRequest");
	case SOAP_TYPE_PointerTo_ns3__getCurrentMacroRequest:
		return soap_out_PointerTo_ns3__getCurrentMacroRequest(soap, tag, id, (_ns3__getCurrentMacroRequest *const*)ptr, "ns3:getCurrentMacroRequest");
	case SOAP_TYPE_PointerTo_ns3__listMacrosRequest:
		return soap_out_PointerTo_ns3__listMacrosRequest(soap, tag, id, (_ns3__listMacrosRequest *const*)ptr, "ns3:listMacrosRequest");
	case SOAP_TYPE_PointerTons2__fault:
		return soap_out_PointerTons2__fault(soap, tag, id, (ns2__fault *const*)ptr, "ns2:fault");
	case SOAP_TYPE_PointerTons2__allPassFilter:
		return soap_out_PointerTons2__allPassFilter(soap, tag, id, (ns2__allPassFilter *const*)ptr, "ns2:allPassFilter");
	case SOAP_TYPE_PointerTons2__parametricFilter:
		return soap_out_PointerTons2__parametricFilter(soap, tag, id, (ns2__parametricFilter *const*)ptr, "ns2:parametricFilter");
	case SOAP_TYPE_PointerTons2__shelfFilter:
		return soap_out_PointerTons2__shelfFilter(soap, tag, id, (ns2__shelfFilter *const*)ptr, "ns2:shelfFilter");
	case SOAP_TYPE_PointerTons2__crossoverFilter:
		return soap_out_PointerTons2__crossoverFilter(soap, tag, id, (ns2__crossoverFilter *const*)ptr, "ns2:crossoverFilter");
	case SOAP_TYPE_PointerTo_ns2__alarm:
		return soap_out_PointerTo_ns2__alarm(soap, tag, id, (_ns2__alarm *const*)ptr, "ns2:alarm");
	case SOAP_TYPE_PointerTons2__keyValuePair:
		return soap_out_PointerTons2__keyValuePair(soap, tag, id, (ns2__keyValuePair *const*)ptr, "ns2:keyValuePair");
	case SOAP_TYPE_PointerTons2__testSignalObjectPath:
		return soap_out_PointerTons2__testSignalObjectPath(soap, tag, id, (enum ns2__testSignalObjectPath *const*)ptr, "ns2:testSignalObjectPath");
	case SOAP_TYPE_PointerTons2__bedChannelId:
		return soap_out_PointerTons2__bedChannelId(soap, tag, id, (enum ns2__bedChannelId *const*)ptr, "ns2:bedChannelId");
	case SOAP_TYPE_PointerTons2__lastAtmosConfigPushErrorType:
		return soap_out_PointerTons2__lastAtmosConfigPushErrorType(soap, tag, id, (enum ns2__lastAtmosConfigPushErrorType *const*)ptr, "ns2:lastAtmosConfigPushErrorType");
	case SOAP_TYPE_PointerTons2__lastAtmosConfigPushStatus:
		return soap_out_PointerTons2__lastAtmosConfigPushStatus(soap, tag, id, (enum ns2__lastAtmosConfigPushStatus *const*)ptr, "ns2:lastAtmosConfigPushStatus");
	case SOAP_TYPE_PointerTons2__audioStreamInfo:
		return soap_out_PointerTons2__audioStreamInfo(soap, tag, id, (ns2__audioStreamInfo *const*)ptr, "ns2:audioStreamInfo");
	case SOAP_TYPE_PointerTons2__macro:
		return soap_out_PointerTons2__macro(soap, tag, id, (ns2__macro *const*)ptr, "ns2:macro");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__UUID:
		return soap_out_PointerTons2__UUID(soap, tag, id, (std::string *const*)ptr, "ns2:UUID");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns4__getWayParamsResponse_sequence:
		((__ns4__getWayParamsResponse_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__timeZone:
		soap_serialize_ns2__timeZone(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__filterID:
		soap_serialize_ns2__filterID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__UUID:
		soap_serialize_ns2__UUID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns4__deleteWayFilterResponse:
		((_ns4__deleteWayFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__deleteWayFilterRequest:
		((_ns4__deleteWayFilterRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__setWayFilterResponse:
		((_ns4__setWayFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__setWayFilterRequest:
		((_ns4__setWayFilterRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getWayFiltersResponse:
		((_ns4__getWayFiltersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getWayFiltersRequest:
		((_ns4__getWayFiltersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getWayParamsResponse:
		((_ns4__getWayParamsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getWayParamsRequest:
		((_ns4__getWayParamsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__setWayParamsResponse:
		((_ns4__setWayParamsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__setWayParamsRequest:
		((_ns4__setWayParamsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getSystemVersionsResponse:
		((_ns4__getSystemVersionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getSystemVersionsRequest:
		((_ns4__getSystemVersionsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getCertificateResponse:
		((_ns4__getCertificateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__getCertificateRequest:
		((_ns4__getCertificateRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__performSystemUpgradeResponse:
		((_ns3__performSystemUpgradeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__performSystemUpgradeRequest:
		((_ns3__performSystemUpgradeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__enableAutoEqModeResponse:
		((_ns3__enableAutoEqModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__enableAutoEqModeRequest:
		((_ns3__enableAutoEqModeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isAutoEqModeEnabledResponse:
		((_ns3__isAutoEqModeEnabledResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isAutoEqModeEnabledRequest:
		((_ns3__isAutoEqModeEnabledRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setTimeZoneResponse:
		((_ns3__setTimeZoneResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setTimeZoneRequest:
		((_ns3__setTimeZoneRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getTimeZoneResponse:
		((_ns3__getTimeZoneResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getTimeZoneRequest:
		((_ns3__getTimeZoneRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getDeviceAlarmsResponse:
		((_ns3__getDeviceAlarmsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getDeviceAlarmsRequest:
		((_ns3__getDeviceAlarmsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getDeviceInfoResponse:
		((_ns3__getDeviceInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getDeviceInfoRequest:
		((_ns3__getDeviceInfoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__enableGlobalEqResponse:
		((_ns3__enableGlobalEqResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__enableGlobalEqRequest:
		((_ns3__enableGlobalEqRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isGlobalEqEnabledResponse:
		((_ns3__isGlobalEqEnabledResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isGlobalEqEnabledRequest:
		((_ns3__isGlobalEqEnabledRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__enableBassManagementResponse:
		((_ns3__enableBassManagementResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__enableBassManagementRequest:
		((_ns3__enableBassManagementRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isBassManagementEnabledResponse:
		((_ns3__isBassManagementEnabledResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isBassManagementEnabledRequest:
		((_ns3__isBassManagementEnabledRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setTestSignalModeResponse:
		((_ns3__setTestSignalModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setTestSignalModeRequest:
		((_ns3__setTestSignalModeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getTestSignalModeResponse:
		((_ns3__getTestSignalModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getTestSignalModeRequest:
		((_ns3__getTestSignalModeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setTestSignalOutputResponse:
		((_ns3__setTestSignalOutputResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setTestSignalOutputRequest:
		((_ns3__setTestSignalOutputRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getTestSignalOutputResponse:
		((_ns3__getTestSignalOutputResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getTestSignalOutputRequest:
		((_ns3__getTestSignalOutputRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigInfoResponse:
		((_ns3__getAtmosConfigInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigInfoRequest:
		((_ns3__getAtmosConfigInfoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setAtmosConfigResponse:
		((_ns3__setAtmosConfigResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setAtmosConfigRequest:
		((_ns3__setAtmosConfigRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigResponse:
		((_ns3__getAtmosConfigResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigRequest:
		((_ns3__getAtmosConfigRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getAudioStreamInfoResponse:
		((_ns3__getAudioStreamInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getAudioStreamInfoRequest:
		((_ns3__getAudioStreamInfoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isAtmosContentResponse:
		((_ns3__isAtmosContentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__isAtmosContentRequest:
		((_ns3__isAtmosContentRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setMuteResponse:
		((_ns3__setMuteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setMuteRequest:
		((_ns3__setMuteRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getMuteResponse:
		((_ns3__getMuteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getMuteRequest:
		((_ns3__getMuteRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setGainResponse:
		((_ns3__setGainResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setGainRequest:
		((_ns3__setGainRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getGainResponse:
		((_ns3__getGainResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getGainRequest:
		((_ns3__getGainRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setCurrentMacroResponse:
		((_ns3__setCurrentMacroResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__setCurrentMacroRequest:
		((_ns3__setCurrentMacroRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getCurrentMacroResponse:
		((_ns3__getCurrentMacroResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__getCurrentMacroRequest:
		((_ns3__getCurrentMacroRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__listMacrosResponse:
		((_ns3__listMacrosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__listMacrosRequest:
		((_ns3__listMacrosRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__alarm:
		((_ns2__alarm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__keyValuePair:
		((ns2__keyValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__audioStreamInfo:
		((ns2__audioStreamInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__fault:
		((ns2__fault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__macro:
		((ns2__macro *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__allPassFilter:
		((ns2__allPassFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__parametricFilter:
		((ns2__parametricFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__shelfFilter:
		((ns2__shelfFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__crossoverFilter:
		((ns2__crossoverFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteWayFilter:
		soap_serialize___ns1__deleteWayFilter(soap, (const struct __ns1__deleteWayFilter *)ptr);
		break;
	case SOAP_TYPE___ns1__setWayFilter:
		soap_serialize___ns1__setWayFilter(soap, (const struct __ns1__setWayFilter *)ptr);
		break;
	case SOAP_TYPE___ns1__getWayFilters:
		soap_serialize___ns1__getWayFilters(soap, (const struct __ns1__getWayFilters *)ptr);
		break;
	case SOAP_TYPE___ns1__getWayParams:
		soap_serialize___ns1__getWayParams(soap, (const struct __ns1__getWayParams *)ptr);
		break;
	case SOAP_TYPE___ns1__setWayParams:
		soap_serialize___ns1__setWayParams(soap, (const struct __ns1__setWayParams *)ptr);
		break;
	case SOAP_TYPE___ns1__getSystemVersions:
		soap_serialize___ns1__getSystemVersions(soap, (const struct __ns1__getSystemVersions *)ptr);
		break;
	case SOAP_TYPE___ns1__getCertificate:
		soap_serialize___ns1__getCertificate(soap, (const struct __ns1__getCertificate *)ptr);
		break;
	case SOAP_TYPE___ns1__performSystemUpgrade_:
		soap_serialize___ns1__performSystemUpgrade_(soap, (const struct __ns1__performSystemUpgrade_ *)ptr);
		break;
	case SOAP_TYPE___ns1__enableAutoEqMode_:
		soap_serialize___ns1__enableAutoEqMode_(soap, (const struct __ns1__enableAutoEqMode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__isAutoEqModeEnabled_:
		soap_serialize___ns1__isAutoEqModeEnabled_(soap, (const struct __ns1__isAutoEqModeEnabled_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setTimeZone_:
		soap_serialize___ns1__setTimeZone_(soap, (const struct __ns1__setTimeZone_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getTimeZone_:
		soap_serialize___ns1__getTimeZone_(soap, (const struct __ns1__getTimeZone_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceAlarms_:
		soap_serialize___ns1__getDeviceAlarms_(soap, (const struct __ns1__getDeviceAlarms_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceInfo_:
		soap_serialize___ns1__getDeviceInfo_(soap, (const struct __ns1__getDeviceInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__enableGlobalEq_:
		soap_serialize___ns1__enableGlobalEq_(soap, (const struct __ns1__enableGlobalEq_ *)ptr);
		break;
	case SOAP_TYPE___ns1__isGlobalEqEnabled_:
		soap_serialize___ns1__isGlobalEqEnabled_(soap, (const struct __ns1__isGlobalEqEnabled_ *)ptr);
		break;
	case SOAP_TYPE___ns1__enableBassManagement_:
		soap_serialize___ns1__enableBassManagement_(soap, (const struct __ns1__enableBassManagement_ *)ptr);
		break;
	case SOAP_TYPE___ns1__isBassManagementEnabled_:
		soap_serialize___ns1__isBassManagementEnabled_(soap, (const struct __ns1__isBassManagementEnabled_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalMode_:
		soap_serialize___ns1__setTestSignalMode_(soap, (const struct __ns1__setTestSignalMode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalMode_:
		soap_serialize___ns1__getTestSignalMode_(soap, (const struct __ns1__getTestSignalMode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalOutput_:
		soap_serialize___ns1__setTestSignalOutput_(soap, (const struct __ns1__setTestSignalOutput_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalOutput_:
		soap_serialize___ns1__getTestSignalOutput_(soap, (const struct __ns1__getTestSignalOutput_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setAtmosConfig_:
		soap_serialize___ns1__setAtmosConfig_(soap, (const struct __ns1__setAtmosConfig_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfig_:
		soap_serialize___ns1__getAtmosConfig_(soap, (const struct __ns1__getAtmosConfig_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfigInfo_:
		soap_serialize___ns1__getAtmosConfigInfo_(soap, (const struct __ns1__getAtmosConfigInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getAudioStreamInfo_:
		soap_serialize___ns1__getAudioStreamInfo_(soap, (const struct __ns1__getAudioStreamInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__isAtmosContent_:
		soap_serialize___ns1__isAtmosContent_(soap, (const struct __ns1__isAtmosContent_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setMute_:
		soap_serialize___ns1__setMute_(soap, (const struct __ns1__setMute_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getMute_:
		soap_serialize___ns1__getMute_(soap, (const struct __ns1__getMute_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setGain_:
		soap_serialize___ns1__setGain_(soap, (const struct __ns1__setGain_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getGain_:
		soap_serialize___ns1__getGain_(soap, (const struct __ns1__getGain_ *)ptr);
		break;
	case SOAP_TYPE___ns1__setCurrentMacro_:
		soap_serialize___ns1__setCurrentMacro_(soap, (const struct __ns1__setCurrentMacro_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getCurrentMacro_:
		soap_serialize___ns1__getCurrentMacro_(soap, (const struct __ns1__getCurrentMacro_ *)ptr);
		break;
	case SOAP_TYPE___ns1__listMacros_:
		soap_serialize___ns1__listMacros_(soap, (const struct __ns1__listMacros_ *)ptr);
		break;
	case SOAP_TYPE___ns1__performSystemUpgrade:
		soap_serialize___ns1__performSystemUpgrade(soap, (const struct __ns1__performSystemUpgrade *)ptr);
		break;
	case SOAP_TYPE___ns1__enableAutoEqMode:
		soap_serialize___ns1__enableAutoEqMode(soap, (const struct __ns1__enableAutoEqMode *)ptr);
		break;
	case SOAP_TYPE___ns1__isAutoEqModeEnabled:
		soap_serialize___ns1__isAutoEqModeEnabled(soap, (const struct __ns1__isAutoEqModeEnabled *)ptr);
		break;
	case SOAP_TYPE___ns1__setTimeZone:
		soap_serialize___ns1__setTimeZone(soap, (const struct __ns1__setTimeZone *)ptr);
		break;
	case SOAP_TYPE___ns1__getTimeZone:
		soap_serialize___ns1__getTimeZone(soap, (const struct __ns1__getTimeZone *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceAlarms:
		soap_serialize___ns1__getDeviceAlarms(soap, (const struct __ns1__getDeviceAlarms *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceInfo:
		soap_serialize___ns1__getDeviceInfo(soap, (const struct __ns1__getDeviceInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__enableGlobalEq:
		soap_serialize___ns1__enableGlobalEq(soap, (const struct __ns1__enableGlobalEq *)ptr);
		break;
	case SOAP_TYPE___ns1__isGlobalEqEnabled:
		soap_serialize___ns1__isGlobalEqEnabled(soap, (const struct __ns1__isGlobalEqEnabled *)ptr);
		break;
	case SOAP_TYPE___ns1__enableBassManagement:
		soap_serialize___ns1__enableBassManagement(soap, (const struct __ns1__enableBassManagement *)ptr);
		break;
	case SOAP_TYPE___ns1__isBassManagementEnabled:
		soap_serialize___ns1__isBassManagementEnabled(soap, (const struct __ns1__isBassManagementEnabled *)ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalMode:
		soap_serialize___ns1__setTestSignalMode(soap, (const struct __ns1__setTestSignalMode *)ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalMode:
		soap_serialize___ns1__getTestSignalMode(soap, (const struct __ns1__getTestSignalMode *)ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalOutput:
		soap_serialize___ns1__setTestSignalOutput(soap, (const struct __ns1__setTestSignalOutput *)ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalOutput:
		soap_serialize___ns1__getTestSignalOutput(soap, (const struct __ns1__getTestSignalOutput *)ptr);
		break;
	case SOAP_TYPE___ns1__setAtmosConfig:
		soap_serialize___ns1__setAtmosConfig(soap, (const struct __ns1__setAtmosConfig *)ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfig:
		soap_serialize___ns1__getAtmosConfig(soap, (const struct __ns1__getAtmosConfig *)ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfigInfo:
		soap_serialize___ns1__getAtmosConfigInfo(soap, (const struct __ns1__getAtmosConfigInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__getAudioStreamInfo:
		soap_serialize___ns1__getAudioStreamInfo(soap, (const struct __ns1__getAudioStreamInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__isAtmosContent:
		soap_serialize___ns1__isAtmosContent(soap, (const struct __ns1__isAtmosContent *)ptr);
		break;
	case SOAP_TYPE___ns1__setMute:
		soap_serialize___ns1__setMute(soap, (const struct __ns1__setMute *)ptr);
		break;
	case SOAP_TYPE___ns1__getMute:
		soap_serialize___ns1__getMute(soap, (const struct __ns1__getMute *)ptr);
		break;
	case SOAP_TYPE___ns1__setGain:
		soap_serialize___ns1__setGain(soap, (const struct __ns1__setGain *)ptr);
		break;
	case SOAP_TYPE___ns1__getGain:
		soap_serialize___ns1__getGain(soap, (const struct __ns1__getGain *)ptr);
		break;
	case SOAP_TYPE___ns1__setCurrentMacro:
		soap_serialize___ns1__setCurrentMacro(soap, (const struct __ns1__setCurrentMacro *)ptr);
		break;
	case SOAP_TYPE___ns1__getCurrentMacro:
		soap_serialize___ns1__getCurrentMacro(soap, (const struct __ns1__getCurrentMacro *)ptr);
		break;
	case SOAP_TYPE___ns1__listMacros:
		soap_serialize___ns1__listMacros(soap, (const struct __ns1__listMacros *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__deleteWayFilterRequest:
		soap_serialize_PointerTo_ns4__deleteWayFilterRequest(soap, (_ns4__deleteWayFilterRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__setWayFilterRequest:
		soap_serialize_PointerTo_ns4__setWayFilterRequest(soap, (_ns4__setWayFilterRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__getWayFiltersRequest:
		soap_serialize_PointerTo_ns4__getWayFiltersRequest(soap, (_ns4__getWayFiltersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__getWayParamsRequest:
		soap_serialize_PointerTo_ns4__getWayParamsRequest(soap, (_ns4__getWayParamsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__setWayParamsRequest:
		soap_serialize_PointerTo_ns4__setWayParamsRequest(soap, (_ns4__setWayParamsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__getSystemVersionsRequest:
		soap_serialize_PointerTo_ns4__getSystemVersionsRequest(soap, (_ns4__getSystemVersionsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__getCertificateRequest:
		soap_serialize_PointerTo_ns4__getCertificateRequest(soap, (_ns4__getCertificateRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__performSystemUpgradeRequest:
		soap_serialize_PointerTo_ns3__performSystemUpgradeRequest(soap, (_ns3__performSystemUpgradeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__enableAutoEqModeRequest:
		soap_serialize_PointerTo_ns3__enableAutoEqModeRequest(soap, (_ns3__enableAutoEqModeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__isAutoEqModeEnabledRequest:
		soap_serialize_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, (_ns3__isAutoEqModeEnabledRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setTimeZoneRequest:
		soap_serialize_PointerTo_ns3__setTimeZoneRequest(soap, (_ns3__setTimeZoneRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getTimeZoneRequest:
		soap_serialize_PointerTo_ns3__getTimeZoneRequest(soap, (_ns3__getTimeZoneRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getDeviceAlarmsRequest:
		soap_serialize_PointerTo_ns3__getDeviceAlarmsRequest(soap, (_ns3__getDeviceAlarmsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getDeviceInfoRequest:
		soap_serialize_PointerTo_ns3__getDeviceInfoRequest(soap, (_ns3__getDeviceInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__enableGlobalEqRequest:
		soap_serialize_PointerTo_ns3__enableGlobalEqRequest(soap, (_ns3__enableGlobalEqRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__isGlobalEqEnabledRequest:
		soap_serialize_PointerTo_ns3__isGlobalEqEnabledRequest(soap, (_ns3__isGlobalEqEnabledRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__enableBassManagementRequest:
		soap_serialize_PointerTo_ns3__enableBassManagementRequest(soap, (_ns3__enableBassManagementRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__isBassManagementEnabledRequest:
		soap_serialize_PointerTo_ns3__isBassManagementEnabledRequest(soap, (_ns3__isBassManagementEnabledRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setTestSignalModeRequest:
		soap_serialize_PointerTo_ns3__setTestSignalModeRequest(soap, (_ns3__setTestSignalModeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getTestSignalModeRequest:
		soap_serialize_PointerTo_ns3__getTestSignalModeRequest(soap, (_ns3__getTestSignalModeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setTestSignalOutputRequest:
		soap_serialize_PointerTo_ns3__setTestSignalOutputRequest(soap, (_ns3__setTestSignalOutputRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getTestSignalOutputRequest:
		soap_serialize_PointerTo_ns3__getTestSignalOutputRequest(soap, (_ns3__getTestSignalOutputRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setAtmosConfigRequest:
		soap_serialize_PointerTo_ns3__setAtmosConfigRequest(soap, (_ns3__setAtmosConfigRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getAtmosConfigRequest:
		soap_serialize_PointerTo_ns3__getAtmosConfigRequest(soap, (_ns3__getAtmosConfigRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getAtmosConfigInfoRequest:
		soap_serialize_PointerTo_ns3__getAtmosConfigInfoRequest(soap, (_ns3__getAtmosConfigInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getAudioStreamInfoRequest:
		soap_serialize_PointerTo_ns3__getAudioStreamInfoRequest(soap, (_ns3__getAudioStreamInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__isAtmosContentRequest:
		soap_serialize_PointerTo_ns3__isAtmosContentRequest(soap, (_ns3__isAtmosContentRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setMuteRequest:
		soap_serialize_PointerTo_ns3__setMuteRequest(soap, (_ns3__setMuteRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getMuteRequest:
		soap_serialize_PointerTo_ns3__getMuteRequest(soap, (_ns3__getMuteRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setGainRequest:
		soap_serialize_PointerTo_ns3__setGainRequest(soap, (_ns3__setGainRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getGainRequest:
		soap_serialize_PointerTo_ns3__getGainRequest(soap, (_ns3__getGainRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__setCurrentMacroRequest:
		soap_serialize_PointerTo_ns3__setCurrentMacroRequest(soap, (_ns3__setCurrentMacroRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__getCurrentMacroRequest:
		soap_serialize_PointerTo_ns3__getCurrentMacroRequest(soap, (_ns3__getCurrentMacroRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__listMacrosRequest:
		soap_serialize_PointerTo_ns3__listMacrosRequest(soap, (_ns3__listMacrosRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__fault:
		soap_serialize_PointerTons2__fault(soap, (ns2__fault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__allPassFilter:
		soap_serialize_PointerTons2__allPassFilter(soap, (ns2__allPassFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__parametricFilter:
		soap_serialize_PointerTons2__parametricFilter(soap, (ns2__parametricFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__shelfFilter:
		soap_serialize_PointerTons2__shelfFilter(soap, (ns2__shelfFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__crossoverFilter:
		soap_serialize_PointerTons2__crossoverFilter(soap, (ns2__crossoverFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns4__getWayParamsResponse_sequence:
		soap_serialize_PointerTo__ns4__getWayParamsResponse_sequence(soap, (__ns4__getWayParamsResponse_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__alarm:
		soap_serialize_PointerTo_ns2__alarm(soap, (_ns2__alarm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__keyValuePair:
		soap_serialize_PointerTons2__keyValuePair(soap, (ns2__keyValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__testSignalObjectPath:
		soap_serialize_PointerTons2__testSignalObjectPath(soap, (enum ns2__testSignalObjectPath *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__bedChannelId:
		soap_serialize_PointerTons2__bedChannelId(soap, (enum ns2__bedChannelId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__lastAtmosConfigPushErrorType:
		soap_serialize_PointerTons2__lastAtmosConfigPushErrorType(soap, (enum ns2__lastAtmosConfigPushErrorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__lastAtmosConfigPushStatus:
		soap_serialize_PointerTons2__lastAtmosConfigPushStatus(soap, (enum ns2__lastAtmosConfigPushStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__audioStreamInfo:
		soap_serialize_PointerTons2__audioStreamInfo(soap, (ns2__audioStreamInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__macro:
		soap_serialize_PointerTons2__macro(soap, (ns2__macro *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UUID:
		soap_serialize_PointerTons2__UUID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__crossoverFilter:
		return (void*)soap_instantiate_ns2__crossoverFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__shelfFilter:
		return (void*)soap_instantiate_ns2__shelfFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__parametricFilter:
		return (void*)soap_instantiate_ns2__parametricFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__allPassFilter:
		return (void*)soap_instantiate_ns2__allPassFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__macro:
		return (void*)soap_instantiate_ns2__macro(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__fault:
		return (void*)soap_instantiate_ns2__fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__audioStreamInfo:
		return (void*)soap_instantiate_ns2__audioStreamInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__keyValuePair:
		return (void*)soap_instantiate_ns2__keyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__alarm:
		return (void*)soap_instantiate__ns2__alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__listMacrosRequest:
		return (void*)soap_instantiate__ns3__listMacrosRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__listMacrosResponse:
		return (void*)soap_instantiate__ns3__listMacrosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getCurrentMacroRequest:
		return (void*)soap_instantiate__ns3__getCurrentMacroRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getCurrentMacroResponse:
		return (void*)soap_instantiate__ns3__getCurrentMacroResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setCurrentMacroRequest:
		return (void*)soap_instantiate__ns3__setCurrentMacroRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setCurrentMacroResponse:
		return (void*)soap_instantiate__ns3__setCurrentMacroResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getGainRequest:
		return (void*)soap_instantiate__ns3__getGainRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getGainResponse:
		return (void*)soap_instantiate__ns3__getGainResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setGainRequest:
		return (void*)soap_instantiate__ns3__setGainRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setGainResponse:
		return (void*)soap_instantiate__ns3__setGainResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getMuteRequest:
		return (void*)soap_instantiate__ns3__getMuteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getMuteResponse:
		return (void*)soap_instantiate__ns3__getMuteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setMuteRequest:
		return (void*)soap_instantiate__ns3__setMuteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setMuteResponse:
		return (void*)soap_instantiate__ns3__setMuteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isAtmosContentRequest:
		return (void*)soap_instantiate__ns3__isAtmosContentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isAtmosContentResponse:
		return (void*)soap_instantiate__ns3__isAtmosContentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getAudioStreamInfoRequest:
		return (void*)soap_instantiate__ns3__getAudioStreamInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getAudioStreamInfoResponse:
		return (void*)soap_instantiate__ns3__getAudioStreamInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getAtmosConfigRequest:
		return (void*)soap_instantiate__ns3__getAtmosConfigRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getAtmosConfigResponse:
		return (void*)soap_instantiate__ns3__getAtmosConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setAtmosConfigRequest:
		return (void*)soap_instantiate__ns3__setAtmosConfigRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setAtmosConfigResponse:
		return (void*)soap_instantiate__ns3__setAtmosConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getAtmosConfigInfoRequest:
		return (void*)soap_instantiate__ns3__getAtmosConfigInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getAtmosConfigInfoResponse:
		return (void*)soap_instantiate__ns3__getAtmosConfigInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getTestSignalOutputRequest:
		return (void*)soap_instantiate__ns3__getTestSignalOutputRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getTestSignalOutputResponse:
		return (void*)soap_instantiate__ns3__getTestSignalOutputResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setTestSignalOutputRequest:
		return (void*)soap_instantiate__ns3__setTestSignalOutputRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setTestSignalOutputResponse:
		return (void*)soap_instantiate__ns3__setTestSignalOutputResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getTestSignalModeRequest:
		return (void*)soap_instantiate__ns3__getTestSignalModeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getTestSignalModeResponse:
		return (void*)soap_instantiate__ns3__getTestSignalModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setTestSignalModeRequest:
		return (void*)soap_instantiate__ns3__setTestSignalModeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setTestSignalModeResponse:
		return (void*)soap_instantiate__ns3__setTestSignalModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isBassManagementEnabledRequest:
		return (void*)soap_instantiate__ns3__isBassManagementEnabledRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isBassManagementEnabledResponse:
		return (void*)soap_instantiate__ns3__isBassManagementEnabledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__enableBassManagementRequest:
		return (void*)soap_instantiate__ns3__enableBassManagementRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__enableBassManagementResponse:
		return (void*)soap_instantiate__ns3__enableBassManagementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isGlobalEqEnabledRequest:
		return (void*)soap_instantiate__ns3__isGlobalEqEnabledRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isGlobalEqEnabledResponse:
		return (void*)soap_instantiate__ns3__isGlobalEqEnabledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__enableGlobalEqRequest:
		return (void*)soap_instantiate__ns3__enableGlobalEqRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__enableGlobalEqResponse:
		return (void*)soap_instantiate__ns3__enableGlobalEqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getDeviceInfoRequest:
		return (void*)soap_instantiate__ns3__getDeviceInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getDeviceInfoResponse:
		return (void*)soap_instantiate__ns3__getDeviceInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getDeviceAlarmsRequest:
		return (void*)soap_instantiate__ns3__getDeviceAlarmsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getDeviceAlarmsResponse:
		return (void*)soap_instantiate__ns3__getDeviceAlarmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getTimeZoneRequest:
		return (void*)soap_instantiate__ns3__getTimeZoneRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__getTimeZoneResponse:
		return (void*)soap_instantiate__ns3__getTimeZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setTimeZoneRequest:
		return (void*)soap_instantiate__ns3__setTimeZoneRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__setTimeZoneResponse:
		return (void*)soap_instantiate__ns3__setTimeZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isAutoEqModeEnabledRequest:
		return (void*)soap_instantiate__ns3__isAutoEqModeEnabledRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__isAutoEqModeEnabledResponse:
		return (void*)soap_instantiate__ns3__isAutoEqModeEnabledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__enableAutoEqModeRequest:
		return (void*)soap_instantiate__ns3__enableAutoEqModeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__enableAutoEqModeResponse:
		return (void*)soap_instantiate__ns3__enableAutoEqModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__performSystemUpgradeRequest:
		return (void*)soap_instantiate__ns3__performSystemUpgradeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__performSystemUpgradeResponse:
		return (void*)soap_instantiate__ns3__performSystemUpgradeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getCertificateRequest:
		return (void*)soap_instantiate__ns4__getCertificateRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getCertificateResponse:
		return (void*)soap_instantiate__ns4__getCertificateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getSystemVersionsRequest:
		return (void*)soap_instantiate__ns4__getSystemVersionsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getSystemVersionsResponse:
		return (void*)soap_instantiate__ns4__getSystemVersionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__setWayParamsRequest:
		return (void*)soap_instantiate__ns4__setWayParamsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__setWayParamsResponse:
		return (void*)soap_instantiate__ns4__setWayParamsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getWayParamsRequest:
		return (void*)soap_instantiate__ns4__getWayParamsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getWayParamsResponse_sequence:
		return (void*)soap_instantiate___ns4__getWayParamsResponse_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getWayParamsResponse:
		return (void*)soap_instantiate__ns4__getWayParamsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getWayFiltersRequest:
		return (void*)soap_instantiate__ns4__getWayFiltersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__getWayFiltersResponse:
		return (void*)soap_instantiate__ns4__getWayFiltersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__setWayFilterRequest:
		return (void*)soap_instantiate__ns4__setWayFilterRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__setWayFilterResponse:
		return (void*)soap_instantiate__ns4__setWayFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__deleteWayFilterRequest:
		return (void*)soap_instantiate__ns4__deleteWayFilterRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__deleteWayFilterResponse:
		return (void*)soap_instantiate__ns4__deleteWayFilterResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__listMacros:
		return (void*)soap_instantiate___ns1__listMacros(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCurrentMacro:
		return (void*)soap_instantiate___ns1__getCurrentMacro(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setCurrentMacro:
		return (void*)soap_instantiate___ns1__setCurrentMacro(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getGain:
		return (void*)soap_instantiate___ns1__getGain(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setGain:
		return (void*)soap_instantiate___ns1__setGain(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMute:
		return (void*)soap_instantiate___ns1__getMute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setMute:
		return (void*)soap_instantiate___ns1__setMute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isAtmosContent:
		return (void*)soap_instantiate___ns1__isAtmosContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAudioStreamInfo:
		return (void*)soap_instantiate___ns1__getAudioStreamInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAtmosConfigInfo:
		return (void*)soap_instantiate___ns1__getAtmosConfigInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAtmosConfig:
		return (void*)soap_instantiate___ns1__getAtmosConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setAtmosConfig:
		return (void*)soap_instantiate___ns1__setAtmosConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTestSignalOutput:
		return (void*)soap_instantiate___ns1__getTestSignalOutput(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setTestSignalOutput:
		return (void*)soap_instantiate___ns1__setTestSignalOutput(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTestSignalMode:
		return (void*)soap_instantiate___ns1__getTestSignalMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setTestSignalMode:
		return (void*)soap_instantiate___ns1__setTestSignalMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isBassManagementEnabled:
		return (void*)soap_instantiate___ns1__isBassManagementEnabled(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enableBassManagement:
		return (void*)soap_instantiate___ns1__enableBassManagement(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isGlobalEqEnabled:
		return (void*)soap_instantiate___ns1__isGlobalEqEnabled(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enableGlobalEq:
		return (void*)soap_instantiate___ns1__enableGlobalEq(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDeviceInfo:
		return (void*)soap_instantiate___ns1__getDeviceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDeviceAlarms:
		return (void*)soap_instantiate___ns1__getDeviceAlarms(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTimeZone:
		return (void*)soap_instantiate___ns1__getTimeZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setTimeZone:
		return (void*)soap_instantiate___ns1__setTimeZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isAutoEqModeEnabled:
		return (void*)soap_instantiate___ns1__isAutoEqModeEnabled(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enableAutoEqMode:
		return (void*)soap_instantiate___ns1__enableAutoEqMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__performSystemUpgrade:
		return (void*)soap_instantiate___ns1__performSystemUpgrade(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listMacros_:
		return (void*)soap_instantiate___ns1__listMacros_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCurrentMacro_:
		return (void*)soap_instantiate___ns1__getCurrentMacro_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setCurrentMacro_:
		return (void*)soap_instantiate___ns1__setCurrentMacro_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getGain_:
		return (void*)soap_instantiate___ns1__getGain_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setGain_:
		return (void*)soap_instantiate___ns1__setGain_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMute_:
		return (void*)soap_instantiate___ns1__getMute_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setMute_:
		return (void*)soap_instantiate___ns1__setMute_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isAtmosContent_:
		return (void*)soap_instantiate___ns1__isAtmosContent_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAudioStreamInfo_:
		return (void*)soap_instantiate___ns1__getAudioStreamInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAtmosConfigInfo_:
		return (void*)soap_instantiate___ns1__getAtmosConfigInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAtmosConfig_:
		return (void*)soap_instantiate___ns1__getAtmosConfig_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setAtmosConfig_:
		return (void*)soap_instantiate___ns1__setAtmosConfig_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTestSignalOutput_:
		return (void*)soap_instantiate___ns1__getTestSignalOutput_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setTestSignalOutput_:
		return (void*)soap_instantiate___ns1__setTestSignalOutput_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTestSignalMode_:
		return (void*)soap_instantiate___ns1__getTestSignalMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setTestSignalMode_:
		return (void*)soap_instantiate___ns1__setTestSignalMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isBassManagementEnabled_:
		return (void*)soap_instantiate___ns1__isBassManagementEnabled_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enableBassManagement_:
		return (void*)soap_instantiate___ns1__enableBassManagement_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isGlobalEqEnabled_:
		return (void*)soap_instantiate___ns1__isGlobalEqEnabled_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enableGlobalEq_:
		return (void*)soap_instantiate___ns1__enableGlobalEq_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDeviceInfo_:
		return (void*)soap_instantiate___ns1__getDeviceInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDeviceAlarms_:
		return (void*)soap_instantiate___ns1__getDeviceAlarms_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTimeZone_:
		return (void*)soap_instantiate___ns1__getTimeZone_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setTimeZone_:
		return (void*)soap_instantiate___ns1__setTimeZone_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isAutoEqModeEnabled_:
		return (void*)soap_instantiate___ns1__isAutoEqModeEnabled_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enableAutoEqMode_:
		return (void*)soap_instantiate___ns1__enableAutoEqMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__performSystemUpgrade_:
		return (void*)soap_instantiate___ns1__performSystemUpgrade_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCertificate:
		return (void*)soap_instantiate___ns1__getCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSystemVersions:
		return (void*)soap_instantiate___ns1__getSystemVersions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setWayParams:
		return (void*)soap_instantiate___ns1__setWayParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getWayParams:
		return (void*)soap_instantiate___ns1__getWayParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getWayFilters:
		return (void*)soap_instantiate___ns1__getWayFilters(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setWayFilter:
		return (void*)soap_instantiate___ns1__setWayFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteWayFilter:
		return (void*)soap_instantiate___ns1__deleteWayFilter(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UUID:
		return (void*)soap_instantiate_ns2__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__filterID:
		return (void*)soap_instantiate_ns2__filterID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__timeZone:
		return (void*)soap_instantiate_ns2__timeZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__allPassFilter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__allPassFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__parametricFilter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__parametricFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__shelfFilter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__shelfFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__crossoverFilter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__crossoverFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns2__alarm:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_ns2__alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__keyValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__keyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__integer:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__macro:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__macro(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__crossoverFilter:
		if (p->size < 0)
			SOAP_DELETE((ns2__crossoverFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__crossoverFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns2__shelfFilter:
		if (p->size < 0)
			SOAP_DELETE((ns2__shelfFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__shelfFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns2__parametricFilter:
		if (p->size < 0)
			SOAP_DELETE((ns2__parametricFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__parametricFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns2__allPassFilter:
		if (p->size < 0)
			SOAP_DELETE((ns2__allPassFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__allPassFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns2__macro:
		if (p->size < 0)
			SOAP_DELETE((ns2__macro*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__macro*)p->ptr);
		break;
	case SOAP_TYPE_ns2__fault:
		if (p->size < 0)
			SOAP_DELETE((ns2__fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__fault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__audioStreamInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__audioStreamInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__audioStreamInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__keyValuePair:
		if (p->size < 0)
			SOAP_DELETE((ns2__keyValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__keyValuePair*)p->ptr);
		break;
	case SOAP_TYPE__ns2__alarm:
		if (p->size < 0)
			SOAP_DELETE((_ns2__alarm*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__alarm*)p->ptr);
		break;
	case SOAP_TYPE__ns3__listMacrosRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__listMacrosRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__listMacrosRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__listMacrosResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__listMacrosResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__listMacrosResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getCurrentMacroRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getCurrentMacroRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getCurrentMacroRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getCurrentMacroResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getCurrentMacroResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getCurrentMacroResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setCurrentMacroRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setCurrentMacroRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setCurrentMacroRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setCurrentMacroResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setCurrentMacroResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setCurrentMacroResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getGainRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getGainRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getGainRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getGainResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getGainResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getGainResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setGainRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setGainRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setGainRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setGainResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setGainResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setGainResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getMuteRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getMuteRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getMuteRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getMuteResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getMuteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getMuteResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setMuteRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setMuteRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setMuteRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setMuteResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setMuteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setMuteResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isAtmosContentRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isAtmosContentRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isAtmosContentRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isAtmosContentResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isAtmosContentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isAtmosContentResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getAudioStreamInfoRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getAudioStreamInfoRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getAudioStreamInfoRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getAudioStreamInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getAudioStreamInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getAudioStreamInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getAtmosConfigRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getAtmosConfigRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getAtmosConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getAtmosConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setAtmosConfigRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setAtmosConfigRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setAtmosConfigRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setAtmosConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setAtmosConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setAtmosConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigInfoRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getAtmosConfigInfoRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getAtmosConfigInfoRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getAtmosConfigInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getAtmosConfigInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getAtmosConfigInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getTestSignalOutputRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getTestSignalOutputRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getTestSignalOutputRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getTestSignalOutputResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getTestSignalOutputResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getTestSignalOutputResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setTestSignalOutputRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setTestSignalOutputRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setTestSignalOutputRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setTestSignalOutputResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setTestSignalOutputResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setTestSignalOutputResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getTestSignalModeRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getTestSignalModeRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getTestSignalModeRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getTestSignalModeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getTestSignalModeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getTestSignalModeResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setTestSignalModeRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setTestSignalModeRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setTestSignalModeRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setTestSignalModeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setTestSignalModeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setTestSignalModeResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isBassManagementEnabledRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isBassManagementEnabledRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isBassManagementEnabledRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isBassManagementEnabledResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isBassManagementEnabledResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isBassManagementEnabledResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__enableBassManagementRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__enableBassManagementRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__enableBassManagementRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__enableBassManagementResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__enableBassManagementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__enableBassManagementResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isGlobalEqEnabledRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isGlobalEqEnabledRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isGlobalEqEnabledRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isGlobalEqEnabledResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isGlobalEqEnabledResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isGlobalEqEnabledResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__enableGlobalEqRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__enableGlobalEqRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__enableGlobalEqRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__enableGlobalEqResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__enableGlobalEqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__enableGlobalEqResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getDeviceInfoRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getDeviceInfoRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getDeviceInfoRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getDeviceInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getDeviceInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getDeviceInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getDeviceAlarmsRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getDeviceAlarmsRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getDeviceAlarmsRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getDeviceAlarmsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getDeviceAlarmsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getDeviceAlarmsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getTimeZoneRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getTimeZoneRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getTimeZoneRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__getTimeZoneResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__getTimeZoneResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__getTimeZoneResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setTimeZoneRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setTimeZoneRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setTimeZoneRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__setTimeZoneResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__setTimeZoneResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__setTimeZoneResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isAutoEqModeEnabledRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isAutoEqModeEnabledRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isAutoEqModeEnabledRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__isAutoEqModeEnabledResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__isAutoEqModeEnabledResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__isAutoEqModeEnabledResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__enableAutoEqModeRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__enableAutoEqModeRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__enableAutoEqModeRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__enableAutoEqModeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__enableAutoEqModeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__enableAutoEqModeResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns3__performSystemUpgradeRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns3__performSystemUpgradeRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__performSystemUpgradeRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__performSystemUpgradeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__performSystemUpgradeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__performSystemUpgradeResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getCertificateRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getCertificateRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getCertificateRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getCertificateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getCertificateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getCertificateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getSystemVersionsRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getSystemVersionsRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getSystemVersionsRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getSystemVersionsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getSystemVersionsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getSystemVersionsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__setWayParamsRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__setWayParamsRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__setWayParamsRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns4__setWayParamsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__setWayParamsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__setWayParamsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getWayParamsRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getWayParamsRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getWayParamsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getWayParamsResponse_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns4__getWayParamsResponse_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns4__getWayParamsResponse_sequence*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getWayParamsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getWayParamsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getWayParamsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getWayFiltersRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getWayFiltersRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getWayFiltersRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns4__getWayFiltersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__getWayFiltersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__getWayFiltersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__setWayFilterRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__setWayFilterRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__setWayFilterRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns4__setWayFilterResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__setWayFilterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__setWayFilterResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__deleteWayFilterRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns4__deleteWayFilterRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__deleteWayFilterRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns4__deleteWayFilterResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__deleteWayFilterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__deleteWayFilterResponse*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns1__listMacros:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listMacros*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listMacros*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCurrentMacro:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCurrentMacro*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCurrentMacro*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setCurrentMacro:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setCurrentMacro*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setCurrentMacro*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getGain:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getGain*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getGain*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setGain:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setGain*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setGain*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMute:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMute*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setMute:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setMute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setMute*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isAtmosContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isAtmosContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isAtmosContent*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAudioStreamInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAudioStreamInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAudioStreamInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfigInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAtmosConfigInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAtmosConfigInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfig:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAtmosConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAtmosConfig*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setAtmosConfig:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setAtmosConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setAtmosConfig*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalOutput:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTestSignalOutput*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTestSignalOutput*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalOutput:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setTestSignalOutput*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setTestSignalOutput*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalMode:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTestSignalMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTestSignalMode*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalMode:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setTestSignalMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setTestSignalMode*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isBassManagementEnabled:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isBassManagementEnabled*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isBassManagementEnabled*)p->ptr);
		break;
	case SOAP_TYPE___ns1__enableBassManagement:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__enableBassManagement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__enableBassManagement*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isGlobalEqEnabled:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isGlobalEqEnabled*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isGlobalEqEnabled*)p->ptr);
		break;
	case SOAP_TYPE___ns1__enableGlobalEq:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__enableGlobalEq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__enableGlobalEq*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDeviceInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDeviceInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceAlarms:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDeviceAlarms*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDeviceAlarms*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTimeZone:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTimeZone*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTimeZone*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setTimeZone:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setTimeZone*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setTimeZone*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isAutoEqModeEnabled:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isAutoEqModeEnabled*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isAutoEqModeEnabled*)p->ptr);
		break;
	case SOAP_TYPE___ns1__enableAutoEqMode:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__enableAutoEqMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__enableAutoEqMode*)p->ptr);
		break;
	case SOAP_TYPE___ns1__performSystemUpgrade:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__performSystemUpgrade*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__performSystemUpgrade*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listMacros_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listMacros_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listMacros_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCurrentMacro_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCurrentMacro_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCurrentMacro_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setCurrentMacro_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setCurrentMacro_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setCurrentMacro_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getGain_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getGain_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getGain_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setGain_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setGain_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setGain_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMute_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMute_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMute_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setMute_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setMute_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setMute_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isAtmosContent_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isAtmosContent_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isAtmosContent_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAudioStreamInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAudioStreamInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAudioStreamInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfigInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAtmosConfigInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAtmosConfigInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAtmosConfig_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAtmosConfig_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAtmosConfig_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setAtmosConfig_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setAtmosConfig_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setAtmosConfig_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalOutput_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTestSignalOutput_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTestSignalOutput_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalOutput_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setTestSignalOutput_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setTestSignalOutput_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTestSignalMode_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTestSignalMode_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTestSignalMode_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setTestSignalMode_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setTestSignalMode_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setTestSignalMode_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isBassManagementEnabled_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isBassManagementEnabled_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isBassManagementEnabled_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__enableBassManagement_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__enableBassManagement_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__enableBassManagement_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isGlobalEqEnabled_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isGlobalEqEnabled_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isGlobalEqEnabled_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__enableGlobalEq_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__enableGlobalEq_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__enableGlobalEq_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDeviceInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDeviceInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceAlarms_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDeviceAlarms_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDeviceAlarms_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTimeZone_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTimeZone_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTimeZone_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setTimeZone_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setTimeZone_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setTimeZone_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isAutoEqModeEnabled_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isAutoEqModeEnabled_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isAutoEqModeEnabled_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__enableAutoEqMode_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__enableAutoEqMode_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__enableAutoEqMode_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__performSystemUpgrade_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__performSystemUpgrade_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__performSystemUpgrade_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCertificate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCertificate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCertificate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSystemVersions:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSystemVersions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSystemVersions*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setWayParams:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setWayParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setWayParams*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getWayParams:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getWayParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getWayParams*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getWayFilters:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getWayFilters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getWayFilters*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setWayFilter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setWayFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setWayFilter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteWayFilter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteWayFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteWayFilter*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UUID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__filterID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__timeZone:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__allPassFilter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__allPassFilter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__allPassFilter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__parametricFilter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__parametricFilter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__parametricFilter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__shelfFilter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__shelfFilter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__shelfFilter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__crossoverFilter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__crossoverFilter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__crossoverFilter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns2__alarm:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_ns2__alarm * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_ns2__alarm * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__keyValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__keyValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__keyValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__macro:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__macro * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__macro * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__allPassFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__allPassFilter * >*)p)[len] = *(ns2__allPassFilter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__parametricFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__parametricFilter * >*)p)[len] = *(ns2__parametricFilter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__shelfFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__shelfFilter * >*)p)[len] = *(ns2__shelfFilter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__crossoverFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__crossoverFilter * >*)p)[len] = *(ns2__crossoverFilter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns2__alarm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_ns2__alarm * >*)p)[len] = *(_ns2__alarm **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__keyValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__keyValuePair * >*)p)[len] = *(ns2__keyValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__macro:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__macro * >*)p)[len] = *(ns2__macro **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Duration(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ns2__Duration);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_ns2__Duration(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ns2__Duration);
	if (p && *p < 0)
	{	soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__Duration);
	if (soap_out_ns2__Duration(soap, tag?tag:"ns2:Duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_ns2__Duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__alarm_type(struct soap *soap, enum _ns2__alarm_type *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__alarm_type
	*a = SOAP_DEFAULT__ns2__alarm_type;
#else
	*a = (enum _ns2__alarm_type)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__alarm_type[] =
{	{ (long)_ns2__alarm_type__disk, "disk" },
	{ (long)_ns2__alarm_type__fan, "fan" },
	{ (long)_ns2__alarm_type__temperature, "temperature" },
	{ (long)_ns2__alarm_type__hardware, "hardware" },
	{ (long)_ns2__alarm_type__software, "software" },
	{ (long)_ns2__alarm_type__offline, "offline" },
	{ (long)_ns2__alarm_type__power, "power" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__alarm_type2s(struct soap *soap, enum _ns2__alarm_type n)
{	const char *s = soap_code_str(soap_codes__ns2__alarm_type, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__alarm_type(struct soap *soap, const char *tag, int id, const enum _ns2__alarm_type *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__alarm_type), type) || soap_send(soap, soap__ns2__alarm_type2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__alarm_type(struct soap *soap, const char *s, enum _ns2__alarm_type *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__alarm_type, s);
	if (map)
		*a = (enum _ns2__alarm_type)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__alarm_type)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__alarm_type * SOAP_FMAC4 soap_in__ns2__alarm_type(struct soap *soap, const char *tag, enum _ns2__alarm_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__alarm_type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__alarm_type, sizeof(enum _ns2__alarm_type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__alarm_type(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__alarm_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__alarm_type, 0, sizeof(enum _ns2__alarm_type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__alarm_type(struct soap *soap, const enum _ns2__alarm_type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__ns2__alarm_type);
	if (soap_out__ns2__alarm_type(soap, tag?tag:"ns2:alarm-type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__alarm_type * SOAP_FMAC4 soap_get__ns2__alarm_type(struct soap *soap, enum _ns2__alarm_type *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__alarm_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__alarm_severity(struct soap *soap, enum _ns2__alarm_severity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__alarm_severity
	*a = SOAP_DEFAULT__ns2__alarm_severity;
#else
	*a = (enum _ns2__alarm_severity)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__alarm_severity[] =
{	{ (long)_ns2__alarm_severity__warning, "warning" },
	{ (long)_ns2__alarm_severity__error, "error" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__alarm_severity2s(struct soap *soap, enum _ns2__alarm_severity n)
{	const char *s = soap_code_str(soap_codes__ns2__alarm_severity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__alarm_severity(struct soap *soap, const char *tag, int id, const enum _ns2__alarm_severity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__alarm_severity), type) || soap_send(soap, soap__ns2__alarm_severity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__alarm_severity(struct soap *soap, const char *s, enum _ns2__alarm_severity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__alarm_severity, s);
	if (map)
		*a = (enum _ns2__alarm_severity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__alarm_severity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__alarm_severity * SOAP_FMAC4 soap_in__ns2__alarm_severity(struct soap *soap, const char *tag, enum _ns2__alarm_severity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__alarm_severity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__alarm_severity, sizeof(enum _ns2__alarm_severity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__alarm_severity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__alarm_severity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__alarm_severity, 0, sizeof(enum _ns2__alarm_severity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__alarm_severity(struct soap *soap, const enum _ns2__alarm_severity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__ns2__alarm_severity);
	if (soap_out__ns2__alarm_severity(soap, tag?tag:"ns2:alarm-severity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__alarm_severity * SOAP_FMAC4 soap_get__ns2__alarm_severity(struct soap *soap, enum _ns2__alarm_severity *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__alarm_severity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__polarity(struct soap *soap, enum ns2__polarity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__polarity
	*a = SOAP_DEFAULT_ns2__polarity;
#else
	*a = (enum ns2__polarity)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__polarity[] =
{	{ (long)ns2__polarity__normal, "normal" },
	{ (long)ns2__polarity__inverted, "inverted" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__polarity2s(struct soap *soap, enum ns2__polarity n)
{	const char *s = soap_code_str(soap_codes_ns2__polarity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__polarity(struct soap *soap, const char *tag, int id, const enum ns2__polarity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__polarity), type) || soap_send(soap, soap_ns2__polarity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__polarity(struct soap *soap, const char *s, enum ns2__polarity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__polarity, s);
	if (map)
		*a = (enum ns2__polarity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__polarity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__polarity * SOAP_FMAC4 soap_in_ns2__polarity(struct soap *soap, const char *tag, enum ns2__polarity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__polarity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__polarity, sizeof(enum ns2__polarity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__polarity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__polarity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__polarity, 0, sizeof(enum ns2__polarity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__polarity(struct soap *soap, const enum ns2__polarity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__polarity);
	if (soap_out_ns2__polarity(soap, tag?tag:"ns2:polarity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__polarity * SOAP_FMAC4 soap_get_ns2__polarity(struct soap *soap, enum ns2__polarity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__polarity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__testSignalObjectPath(struct soap *soap, enum ns2__testSignalObjectPath *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__testSignalObjectPath
	*a = SOAP_DEFAULT_ns2__testSignalObjectPath;
#else
	*a = (enum ns2__testSignalObjectPath)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__testSignalObjectPath[] =
{	{ (long)ns2__testSignalObjectPath__allSpeakersContinuous, "allSpeakersContinuous" },
	{ (long)ns2__testSignalObjectPath__allSpeakersSnap, "allSpeakersSnap" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__testSignalObjectPath2s(struct soap *soap, enum ns2__testSignalObjectPath n)
{	const char *s = soap_code_str(soap_codes_ns2__testSignalObjectPath, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__testSignalObjectPath(struct soap *soap, const char *tag, int id, const enum ns2__testSignalObjectPath *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__testSignalObjectPath), type) || soap_send(soap, soap_ns2__testSignalObjectPath2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__testSignalObjectPath(struct soap *soap, const char *s, enum ns2__testSignalObjectPath *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__testSignalObjectPath, s);
	if (map)
		*a = (enum ns2__testSignalObjectPath)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__testSignalObjectPath)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__testSignalObjectPath * SOAP_FMAC4 soap_in_ns2__testSignalObjectPath(struct soap *soap, const char *tag, enum ns2__testSignalObjectPath *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__testSignalObjectPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__testSignalObjectPath, sizeof(enum ns2__testSignalObjectPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__testSignalObjectPath(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__testSignalObjectPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__testSignalObjectPath, 0, sizeof(enum ns2__testSignalObjectPath), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__testSignalObjectPath(struct soap *soap, const enum ns2__testSignalObjectPath *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__testSignalObjectPath);
	if (soap_out_ns2__testSignalObjectPath(soap, tag?tag:"ns2:testSignalObjectPath", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__testSignalObjectPath * SOAP_FMAC4 soap_get_ns2__testSignalObjectPath(struct soap *soap, enum ns2__testSignalObjectPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__testSignalObjectPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__testSignalOutputMode(struct soap *soap, enum ns2__testSignalOutputMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__testSignalOutputMode
	*a = SOAP_DEFAULT_ns2__testSignalOutputMode;
#else
	*a = (enum ns2__testSignalOutputMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__testSignalOutputMode[] =
{	{ (long)ns2__testSignalOutputMode__speaker, "speaker" },
	{ (long)ns2__testSignalOutputMode__array, "array" },
	{ (long)ns2__testSignalOutputMode__object, "object" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__testSignalOutputMode2s(struct soap *soap, enum ns2__testSignalOutputMode n)
{	const char *s = soap_code_str(soap_codes_ns2__testSignalOutputMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__testSignalOutputMode(struct soap *soap, const char *tag, int id, const enum ns2__testSignalOutputMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__testSignalOutputMode), type) || soap_send(soap, soap_ns2__testSignalOutputMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__testSignalOutputMode(struct soap *soap, const char *s, enum ns2__testSignalOutputMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__testSignalOutputMode, s);
	if (map)
		*a = (enum ns2__testSignalOutputMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__testSignalOutputMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__testSignalOutputMode * SOAP_FMAC4 soap_in_ns2__testSignalOutputMode(struct soap *soap, const char *tag, enum ns2__testSignalOutputMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__testSignalOutputMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__testSignalOutputMode, sizeof(enum ns2__testSignalOutputMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__testSignalOutputMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__testSignalOutputMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__testSignalOutputMode, 0, sizeof(enum ns2__testSignalOutputMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__testSignalOutputMode(struct soap *soap, const enum ns2__testSignalOutputMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__testSignalOutputMode);
	if (soap_out_ns2__testSignalOutputMode(soap, tag?tag:"ns2:testSignalOutputMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__testSignalOutputMode * SOAP_FMAC4 soap_get_ns2__testSignalOutputMode(struct soap *soap, enum ns2__testSignalOutputMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__testSignalOutputMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__lastAtmosConfigPushErrorType(struct soap *soap, enum ns2__lastAtmosConfigPushErrorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__lastAtmosConfigPushErrorType
	*a = SOAP_DEFAULT_ns2__lastAtmosConfigPushErrorType;
#else
	*a = (enum ns2__lastAtmosConfigPushErrorType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__lastAtmosConfigPushErrorType[] =
{	{ (long)ns2__lastAtmosConfigPushErrorType__NO_USCOREERROR, "NO_ERROR" },
	{ (long)ns2__lastAtmosConfigPushErrorType__UNKNOWN_USCOREERROR, "UNKNOWN_ERROR" },
	{ (long)ns2__lastAtmosConfigPushErrorType__VALIDATION_USCOREERROR, "VALIDATION_ERROR" },
	{ (long)ns2__lastAtmosConfigPushErrorType__ENABLEMENT_USCOREDISABLED_USCOREDIGITAL_USCOREOUTPUTS, "ENABLEMENT_DISABLED_DIGITAL_OUTPUTS" },
	{ (long)ns2__lastAtmosConfigPushErrorType__ENABLEMENT_USCOREDISABLED_USCOREATMOS, "ENABLEMENT_DISABLED_ATMOS" },
	{ (long)ns2__lastAtmosConfigPushErrorType__ENABLEMENT_USCOREDISABLED_USCOREINTERNAL_USCOREXOVERS, "ENABLEMENT_DISABLED_INTERNAL_XOVERS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__lastAtmosConfigPushErrorType2s(struct soap *soap, enum ns2__lastAtmosConfigPushErrorType n)
{	const char *s = soap_code_str(soap_codes_ns2__lastAtmosConfigPushErrorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__lastAtmosConfigPushErrorType(struct soap *soap, const char *tag, int id, const enum ns2__lastAtmosConfigPushErrorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType), type) || soap_send(soap, soap_ns2__lastAtmosConfigPushErrorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__lastAtmosConfigPushErrorType(struct soap *soap, const char *s, enum ns2__lastAtmosConfigPushErrorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__lastAtmosConfigPushErrorType, s);
	if (map)
		*a = (enum ns2__lastAtmosConfigPushErrorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__lastAtmosConfigPushErrorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushErrorType * SOAP_FMAC4 soap_in_ns2__lastAtmosConfigPushErrorType(struct soap *soap, const char *tag, enum ns2__lastAtmosConfigPushErrorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__lastAtmosConfigPushErrorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType, sizeof(enum ns2__lastAtmosConfigPushErrorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__lastAtmosConfigPushErrorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__lastAtmosConfigPushErrorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType, 0, sizeof(enum ns2__lastAtmosConfigPushErrorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__lastAtmosConfigPushErrorType(struct soap *soap, const enum ns2__lastAtmosConfigPushErrorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType);
	if (soap_out_ns2__lastAtmosConfigPushErrorType(soap, tag?tag:"ns2:lastAtmosConfigPushErrorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushErrorType * SOAP_FMAC4 soap_get_ns2__lastAtmosConfigPushErrorType(struct soap *soap, enum ns2__lastAtmosConfigPushErrorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__lastAtmosConfigPushErrorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__lastAtmosConfigPushStatus(struct soap *soap, enum ns2__lastAtmosConfigPushStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__lastAtmosConfigPushStatus
	*a = SOAP_DEFAULT_ns2__lastAtmosConfigPushStatus;
#else
	*a = (enum ns2__lastAtmosConfigPushStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__lastAtmosConfigPushStatus[] =
{	{ (long)ns2__lastAtmosConfigPushStatus__SUCCESS, "SUCCESS" },
	{ (long)ns2__lastAtmosConfigPushStatus__PENDING, "PENDING" },
	{ (long)ns2__lastAtmosConfigPushStatus__ERROR, "ERROR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__lastAtmosConfigPushStatus2s(struct soap *soap, enum ns2__lastAtmosConfigPushStatus n)
{	const char *s = soap_code_str(soap_codes_ns2__lastAtmosConfigPushStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__lastAtmosConfigPushStatus(struct soap *soap, const char *tag, int id, const enum ns2__lastAtmosConfigPushStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__lastAtmosConfigPushStatus), type) || soap_send(soap, soap_ns2__lastAtmosConfigPushStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__lastAtmosConfigPushStatus(struct soap *soap, const char *s, enum ns2__lastAtmosConfigPushStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__lastAtmosConfigPushStatus, s);
	if (map)
		*a = (enum ns2__lastAtmosConfigPushStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__lastAtmosConfigPushStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushStatus * SOAP_FMAC4 soap_in_ns2__lastAtmosConfigPushStatus(struct soap *soap, const char *tag, enum ns2__lastAtmosConfigPushStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__lastAtmosConfigPushStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__lastAtmosConfigPushStatus, sizeof(enum ns2__lastAtmosConfigPushStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__lastAtmosConfigPushStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__lastAtmosConfigPushStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__lastAtmosConfigPushStatus, 0, sizeof(enum ns2__lastAtmosConfigPushStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__lastAtmosConfigPushStatus(struct soap *soap, const enum ns2__lastAtmosConfigPushStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__lastAtmosConfigPushStatus);
	if (soap_out_ns2__lastAtmosConfigPushStatus(soap, tag?tag:"ns2:lastAtmosConfigPushStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushStatus * SOAP_FMAC4 soap_get_ns2__lastAtmosConfigPushStatus(struct soap *soap, enum ns2__lastAtmosConfigPushStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__lastAtmosConfigPushStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__testSignalType(struct soap *soap, enum ns2__testSignalType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__testSignalType
	*a = SOAP_DEFAULT_ns2__testSignalType;
#else
	*a = (enum ns2__testSignalType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__testSignalType[] =
{	{ (long)ns2__testSignalType__none, "none" },
	{ (long)ns2__testSignalType__pinkNoise, "pinkNoise" },
	{ (long)ns2__testSignalType__sine100Hz, "sine100Hz" },
	{ (long)ns2__testSignalType__sine1kHz, "sine1kHz" },
	{ (long)ns2__testSignalType__sine10kHz, "sine10kHz" },
	{ (long)ns2__testSignalType__thump, "thump" },
	{ (long)ns2__testSignalType__program, "program" },
	{ (long)ns2__testSignalType__sweep, "sweep" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__testSignalType2s(struct soap *soap, enum ns2__testSignalType n)
{	const char *s = soap_code_str(soap_codes_ns2__testSignalType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__testSignalType(struct soap *soap, const char *tag, int id, const enum ns2__testSignalType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__testSignalType), type) || soap_send(soap, soap_ns2__testSignalType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__testSignalType(struct soap *soap, const char *s, enum ns2__testSignalType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__testSignalType, s);
	if (map)
		*a = (enum ns2__testSignalType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__testSignalType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__testSignalType * SOAP_FMAC4 soap_in_ns2__testSignalType(struct soap *soap, const char *tag, enum ns2__testSignalType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__testSignalType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__testSignalType, sizeof(enum ns2__testSignalType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__testSignalType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__testSignalType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__testSignalType, 0, sizeof(enum ns2__testSignalType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__testSignalType(struct soap *soap, const enum ns2__testSignalType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__testSignalType);
	if (soap_out_ns2__testSignalType(soap, tag?tag:"ns2:testSignalType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__testSignalType * SOAP_FMAC4 soap_get_ns2__testSignalType(struct soap *soap, enum ns2__testSignalType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__testSignalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__bedChannelId(struct soap *soap, enum ns2__bedChannelId *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__bedChannelId
	*a = SOAP_DEFAULT_ns2__bedChannelId;
#else
	*a = (enum ns2__bedChannelId)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__bedChannelId[] =
{	{ (long)ns2__bedChannelId__l, "l" },
	{ (long)ns2__bedChannelId__r, "r" },
	{ (long)ns2__bedChannelId__c, "c" },
	{ (long)ns2__bedChannelId__lfe, "lfe" },
	{ (long)ns2__bedChannelId__lss, "lss" },
	{ (long)ns2__bedChannelId__rss, "rss" },
	{ (long)ns2__bedChannelId__lrs, "lrs" },
	{ (long)ns2__bedChannelId__rrs, "rrs" },
	{ (long)ns2__bedChannelId__lts, "lts" },
	{ (long)ns2__bedChannelId__rts, "rts" },
	{ (long)ns2__bedChannelId__lc, "lc" },
	{ (long)ns2__bedChannelId__rc, "rc" },
	{ (long)ns2__bedChannelId__ls, "ls" },
	{ (long)ns2__bedChannelId__rs, "rs" },
	{ (long)ns2__bedChannelId__lw, "lw" },
	{ (long)ns2__bedChannelId__rw, "rw" },
	{ (long)ns2__bedChannelId__cts, "cts" },
	{ (long)ns2__bedChannelId__crs, "crs" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__bedChannelId2s(struct soap *soap, enum ns2__bedChannelId n)
{	const char *s = soap_code_str(soap_codes_ns2__bedChannelId, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__bedChannelId(struct soap *soap, const char *tag, int id, const enum ns2__bedChannelId *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__bedChannelId), type) || soap_send(soap, soap_ns2__bedChannelId2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__bedChannelId(struct soap *soap, const char *s, enum ns2__bedChannelId *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__bedChannelId, s);
	if (map)
		*a = (enum ns2__bedChannelId)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 17)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__bedChannelId)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__bedChannelId * SOAP_FMAC4 soap_in_ns2__bedChannelId(struct soap *soap, const char *tag, enum ns2__bedChannelId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__bedChannelId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__bedChannelId, sizeof(enum ns2__bedChannelId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__bedChannelId(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__bedChannelId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__bedChannelId, 0, sizeof(enum ns2__bedChannelId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__bedChannelId(struct soap *soap, const enum ns2__bedChannelId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__bedChannelId);
	if (soap_out_ns2__bedChannelId(soap, tag?tag:"ns2:bedChannelId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__bedChannelId * SOAP_FMAC4 soap_get_ns2__bedChannelId(struct soap *soap, enum ns2__bedChannelId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__bedChannelId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__acmod(struct soap *soap, enum ns2__acmod *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__acmod
	*a = SOAP_DEFAULT_ns2__acmod;
#else
	*a = (enum ns2__acmod)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__acmod[] =
{	{ (long)ns2__acmod__1_x002b1, "1+1" },
	{ (long)ns2__acmod__1_x002e0, "1.0" },
	{ (long)ns2__acmod__2_x002e0, "2.0" },
	{ (long)ns2__acmod__3_x002e0, "3.0" },
	{ (long)ns2__acmod__2_x002e1, "2.1" },
	{ (long)ns2__acmod__3_x002e1, "3.1" },
	{ (long)ns2__acmod__4_x002e1, "4.1" },
	{ (long)ns2__acmod__5_x002e1, "5.1" },
	{ (long)ns2__acmod__6_x002e1, "6.1" },
	{ (long)ns2__acmod__7_x002e1, "7.1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__acmod2s(struct soap *soap, enum ns2__acmod n)
{	const char *s = soap_code_str(soap_codes_ns2__acmod, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__acmod(struct soap *soap, const char *tag, int id, const enum ns2__acmod *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__acmod), type) || soap_send(soap, soap_ns2__acmod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__acmod(struct soap *soap, const char *s, enum ns2__acmod *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__acmod, s);
	if (map)
		*a = (enum ns2__acmod)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__acmod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__acmod * SOAP_FMAC4 soap_in_ns2__acmod(struct soap *soap, const char *tag, enum ns2__acmod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__acmod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__acmod, sizeof(enum ns2__acmod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__acmod(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__acmod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__acmod, 0, sizeof(enum ns2__acmod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__acmod(struct soap *soap, const enum ns2__acmod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__acmod);
	if (soap_out_ns2__acmod(soap, tag?tag:"ns2:acmod", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__acmod * SOAP_FMAC4 soap_get_ns2__acmod(struct soap *soap, enum ns2__acmod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__acmod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__audioStreamType(struct soap *soap, enum ns2__audioStreamType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__audioStreamType
	*a = SOAP_DEFAULT_ns2__audioStreamType;
#else
	*a = (enum ns2__audioStreamType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__audioStreamType[] =
{	{ (long)ns2__audioStreamType__dolbyDigital, "dolbyDigital" },
	{ (long)ns2__audioStreamType__dolbyDigitalPlus, "dolbyDigitalPlus" },
	{ (long)ns2__audioStreamType__pcm, "pcm" },
	{ (long)ns2__audioStreamType__dolbyE, "dolbyE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__audioStreamType2s(struct soap *soap, enum ns2__audioStreamType n)
{	const char *s = soap_code_str(soap_codes_ns2__audioStreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__audioStreamType(struct soap *soap, const char *tag, int id, const enum ns2__audioStreamType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__audioStreamType), type) || soap_send(soap, soap_ns2__audioStreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__audioStreamType(struct soap *soap, const char *s, enum ns2__audioStreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__audioStreamType, s);
	if (map)
		*a = (enum ns2__audioStreamType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__audioStreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__audioStreamType * SOAP_FMAC4 soap_in_ns2__audioStreamType(struct soap *soap, const char *tag, enum ns2__audioStreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__audioStreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__audioStreamType, sizeof(enum ns2__audioStreamType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__audioStreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__audioStreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__audioStreamType, 0, sizeof(enum ns2__audioStreamType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__audioStreamType(struct soap *soap, const enum ns2__audioStreamType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__audioStreamType);
	if (soap_out_ns2__audioStreamType(soap, tag?tag:"ns2:audioStreamType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__audioStreamType * SOAP_FMAC4 soap_get_ns2__audioStreamType(struct soap *soap, enum ns2__audioStreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__audioStreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__atmosContentStatus(struct soap *soap, enum ns2__atmosContentStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__atmosContentStatus
	*a = SOAP_DEFAULT_ns2__atmosContentStatus;
#else
	*a = (enum ns2__atmosContentStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__atmosContentStatus[] =
{	{ (long)ns2__atmosContentStatus__dolbyAtmos, "dolbyAtmos" },
	{ (long)ns2__atmosContentStatus__pcm, "pcm" },
	{ (long)ns2__atmosContentStatus__pcmWhenAtmosExpected, "pcmWhenAtmosExpected" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__atmosContentStatus2s(struct soap *soap, enum ns2__atmosContentStatus n)
{	const char *s = soap_code_str(soap_codes_ns2__atmosContentStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__atmosContentStatus(struct soap *soap, const char *tag, int id, const enum ns2__atmosContentStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__atmosContentStatus), type) || soap_send(soap, soap_ns2__atmosContentStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__atmosContentStatus(struct soap *soap, const char *s, enum ns2__atmosContentStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__atmosContentStatus, s);
	if (map)
		*a = (enum ns2__atmosContentStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__atmosContentStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__atmosContentStatus * SOAP_FMAC4 soap_in_ns2__atmosContentStatus(struct soap *soap, const char *tag, enum ns2__atmosContentStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__atmosContentStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__atmosContentStatus, sizeof(enum ns2__atmosContentStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__atmosContentStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__atmosContentStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__atmosContentStatus, 0, sizeof(enum ns2__atmosContentStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__atmosContentStatus(struct soap *soap, const enum ns2__atmosContentStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__atmosContentStatus);
	if (soap_out_ns2__atmosContentStatus(soap, tag?tag:"ns2:atmosContentStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__atmosContentStatus * SOAP_FMAC4 soap_get_ns2__atmosContentStatus(struct soap *soap, enum ns2__atmosContentStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__atmosContentStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__shelfType(struct soap *soap, enum ns2__shelfType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__shelfType
	*a = SOAP_DEFAULT_ns2__shelfType;
#else
	*a = (enum ns2__shelfType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__shelfType[] =
{	{ (long)ns2__shelfType__Low, "Low" },
	{ (long)ns2__shelfType__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__shelfType2s(struct soap *soap, enum ns2__shelfType n)
{	const char *s = soap_code_str(soap_codes_ns2__shelfType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__shelfType(struct soap *soap, const char *tag, int id, const enum ns2__shelfType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__shelfType), type) || soap_send(soap, soap_ns2__shelfType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__shelfType(struct soap *soap, const char *s, enum ns2__shelfType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__shelfType, s);
	if (map)
		*a = (enum ns2__shelfType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__shelfType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__shelfType * SOAP_FMAC4 soap_in_ns2__shelfType(struct soap *soap, const char *tag, enum ns2__shelfType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__shelfType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__shelfType, sizeof(enum ns2__shelfType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__shelfType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__shelfType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__shelfType, 0, sizeof(enum ns2__shelfType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__shelfType(struct soap *soap, const enum ns2__shelfType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__shelfType);
	if (soap_out_ns2__shelfType(soap, tag?tag:"ns2:shelfType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__shelfType * SOAP_FMAC4 soap_get_ns2__shelfType(struct soap *soap, enum ns2__shelfType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__shelfType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__crossoverFilterType(struct soap *soap, enum ns2__crossoverFilterType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__crossoverFilterType
	*a = SOAP_DEFAULT_ns2__crossoverFilterType;
#else
	*a = (enum ns2__crossoverFilterType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__crossoverFilterType[] =
{	{ (long)ns2__crossoverFilterType__Bessel, "Bessel" },
	{ (long)ns2__crossoverFilterType__Butterworth, "Butterworth" },
	{ (long)ns2__crossoverFilterType__Linkwitzriley, "Linkwitzriley" },
	{ (long)ns2__crossoverFilterType__Crosssplit, "Crosssplit" },
	{ (long)ns2__crossoverFilterType__Linphase, "Linphase" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__crossoverFilterType2s(struct soap *soap, enum ns2__crossoverFilterType n)
{	const char *s = soap_code_str(soap_codes_ns2__crossoverFilterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__crossoverFilterType(struct soap *soap, const char *tag, int id, const enum ns2__crossoverFilterType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__crossoverFilterType), type) || soap_send(soap, soap_ns2__crossoverFilterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__crossoverFilterType(struct soap *soap, const char *s, enum ns2__crossoverFilterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__crossoverFilterType, s);
	if (map)
		*a = (enum ns2__crossoverFilterType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__crossoverFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__crossoverFilterType * SOAP_FMAC4 soap_in_ns2__crossoverFilterType(struct soap *soap, const char *tag, enum ns2__crossoverFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__crossoverFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__crossoverFilterType, sizeof(enum ns2__crossoverFilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__crossoverFilterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__crossoverFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__crossoverFilterType, 0, sizeof(enum ns2__crossoverFilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__crossoverFilterType(struct soap *soap, const enum ns2__crossoverFilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__crossoverFilterType);
	if (soap_out_ns2__crossoverFilterType(soap, tag?tag:"ns2:crossoverFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__crossoverFilterType * SOAP_FMAC4 soap_get_ns2__crossoverFilterType(struct soap *soap, enum ns2__crossoverFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__crossoverFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__crossoverType(struct soap *soap, enum ns2__crossoverType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__crossoverType
	*a = SOAP_DEFAULT_ns2__crossoverType;
#else
	*a = (enum ns2__crossoverType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__crossoverType[] =
{	{ (long)ns2__crossoverType__LowPass, "LowPass" },
	{ (long)ns2__crossoverType__HighPass, "HighPass" },
	{ (long)ns2__crossoverType__BandPass, "BandPass" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__crossoverType2s(struct soap *soap, enum ns2__crossoverType n)
{	const char *s = soap_code_str(soap_codes_ns2__crossoverType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__crossoverType(struct soap *soap, const char *tag, int id, const enum ns2__crossoverType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__crossoverType), type) || soap_send(soap, soap_ns2__crossoverType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__crossoverType(struct soap *soap, const char *s, enum ns2__crossoverType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__crossoverType, s);
	if (map)
		*a = (enum ns2__crossoverType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__crossoverType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__crossoverType * SOAP_FMAC4 soap_in_ns2__crossoverType(struct soap *soap, const char *tag, enum ns2__crossoverType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__crossoverType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__crossoverType, sizeof(enum ns2__crossoverType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__crossoverType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__crossoverType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__crossoverType, 0, sizeof(enum ns2__crossoverType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__crossoverType(struct soap *soap, const enum ns2__crossoverType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__crossoverType);
	if (soap_out_ns2__crossoverType(soap, tag?tag:"ns2:crossoverType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__crossoverType * SOAP_FMAC4 soap_get_ns2__crossoverType(struct soap *soap, enum ns2__crossoverType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__crossoverType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__crossoverSlope(struct soap *soap, enum ns2__crossoverSlope *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__crossoverSlope
	*a = SOAP_DEFAULT_ns2__crossoverSlope;
#else
	*a = (enum ns2__crossoverSlope)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__crossoverSlope[] =
{	{ (long)ns2__crossoverSlope__6dB, "6dB" },
	{ (long)ns2__crossoverSlope__12dB, "12dB" },
	{ (long)ns2__crossoverSlope__18dB, "18dB" },
	{ (long)ns2__crossoverSlope__24dB, "24dB" },
	{ (long)ns2__crossoverSlope__30dB, "30dB" },
	{ (long)ns2__crossoverSlope__36dB, "36dB" },
	{ (long)ns2__crossoverSlope__42dB, "42dB" },
	{ (long)ns2__crossoverSlope__48dB, "48dB" },
	{ (long)ns2__crossoverSlope__Brickwall, "Brickwall" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__crossoverSlope2s(struct soap *soap, enum ns2__crossoverSlope n)
{	const char *s = soap_code_str(soap_codes_ns2__crossoverSlope, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__crossoverSlope(struct soap *soap, const char *tag, int id, const enum ns2__crossoverSlope *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__crossoverSlope), type) || soap_send(soap, soap_ns2__crossoverSlope2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__crossoverSlope(struct soap *soap, const char *s, enum ns2__crossoverSlope *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__crossoverSlope, s);
	if (map)
		*a = (enum ns2__crossoverSlope)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__crossoverSlope)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__crossoverSlope * SOAP_FMAC4 soap_in_ns2__crossoverSlope(struct soap *soap, const char *tag, enum ns2__crossoverSlope *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__crossoverSlope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__crossoverSlope, sizeof(enum ns2__crossoverSlope), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__crossoverSlope(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__crossoverSlope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__crossoverSlope, 0, sizeof(enum ns2__crossoverSlope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__crossoverSlope(struct soap *soap, const enum ns2__crossoverSlope *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__crossoverSlope);
	if (soap_out_ns2__crossoverSlope(soap, tag?tag:"ns2:crossoverSlope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__crossoverSlope * SOAP_FMAC4 soap_get_ns2__crossoverSlope(struct soap *soap, enum ns2__crossoverSlope *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__crossoverSlope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CueType(struct soap *soap, enum ns2__CueType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CueType
	*a = SOAP_DEFAULT_ns2__CueType;
#else
	*a = (enum ns2__CueType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CueType[] =
{	{ (long)ns2__CueType__light, "light" },
	{ (long)ns2__CueType__audio, "audio" },
	{ (long)ns2__CueType__projector, "projector" },
	{ (long)ns2__CueType__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CueType2s(struct soap *soap, enum ns2__CueType n)
{	const char *s = soap_code_str(soap_codes_ns2__CueType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CueType(struct soap *soap, const char *tag, int id, const enum ns2__CueType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CueType), type) || soap_send(soap, soap_ns2__CueType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CueType(struct soap *soap, const char *s, enum ns2__CueType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CueType, s);
	if (map)
		*a = (enum ns2__CueType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CueType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CueType * SOAP_FMAC4 soap_in_ns2__CueType(struct soap *soap, const char *tag, enum ns2__CueType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CueType, sizeof(enum ns2__CueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CueType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CueType, 0, sizeof(enum ns2__CueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CueType(struct soap *soap, const enum ns2__CueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__CueType);
	if (soap_out_ns2__CueType(soap, tag?tag:"ns2:CueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CueType * SOAP_FMAC4 soap_get_ns2__CueType(struct soap *soap, enum ns2__CueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TransferType(struct soap *soap, enum ns2__TransferType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TransferType
	*a = SOAP_DEFAULT_ns2__TransferType;
#else
	*a = (enum ns2__TransferType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TransferType[] =
{	{ (long)ns2__TransferType__CPL, "CPL" },
	{ (long)ns2__TransferType__KDM, "KDM" },
	{ (long)ns2__TransferType__PKL, "PKL" },
	{ (long)ns2__TransferType__SPL, "SPL" },
	{ (long)ns2__TransferType__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TransferType2s(struct soap *soap, enum ns2__TransferType n)
{	const char *s = soap_code_str(soap_codes_ns2__TransferType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TransferType(struct soap *soap, const char *tag, int id, const enum ns2__TransferType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TransferType), type) || soap_send(soap, soap_ns2__TransferType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TransferType(struct soap *soap, const char *s, enum ns2__TransferType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TransferType, s);
	if (map)
		*a = (enum ns2__TransferType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TransferType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TransferType * SOAP_FMAC4 soap_in_ns2__TransferType(struct soap *soap, const char *tag, enum ns2__TransferType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TransferType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TransferType, sizeof(enum ns2__TransferType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__TransferType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TransferType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TransferType, 0, sizeof(enum ns2__TransferType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TransferType(struct soap *soap, const enum ns2__TransferType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__TransferType);
	if (soap_out_ns2__TransferType(soap, tag?tag:"ns2:TransferType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TransferType * SOAP_FMAC4 soap_get_ns2__TransferType(struct soap *soap, enum ns2__TransferType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TransferType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StorageType(struct soap *soap, enum ns2__StorageType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__StorageType
	*a = SOAP_DEFAULT_ns2__StorageType;
#else
	*a = (enum ns2__StorageType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__StorageType[] =
{	{ (long)ns2__StorageType__MainStore, "MainStore" },
	{ (long)ns2__StorageType__Removable, "Removable" },
	{ (long)ns2__StorageType__DVD, "DVD" },
	{ (long)ns2__StorageType__USB, "USB" },
	{ (long)ns2__StorageType__SasStore, "SasStore" },
	{ (long)ns2__StorageType__NetworkStore, "NetworkStore" },
	{ (long)ns2__StorageType__ModemStore, "ModemStore" },
	{ (long)ns2__StorageType__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__StorageType2s(struct soap *soap, enum ns2__StorageType n)
{	const char *s = soap_code_str(soap_codes_ns2__StorageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StorageType(struct soap *soap, const char *tag, int id, const enum ns2__StorageType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StorageType), type) || soap_send(soap, soap_ns2__StorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__StorageType(struct soap *soap, const char *s, enum ns2__StorageType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__StorageType, s);
	if (map)
		*a = (enum ns2__StorageType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__StorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__StorageType * SOAP_FMAC4 soap_in_ns2__StorageType(struct soap *soap, const char *tag, enum ns2__StorageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__StorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StorageType, sizeof(enum ns2__StorageType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__StorageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__StorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StorageType, 0, sizeof(enum ns2__StorageType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StorageType(struct soap *soap, const enum ns2__StorageType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__StorageType);
	if (soap_out_ns2__StorageType(soap, tag?tag:"ns2:StorageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__StorageType * SOAP_FMAC4 soap_get_ns2__StorageType(struct soap *soap, enum ns2__StorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Category(struct soap *soap, enum ns2__Category *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Category
	*a = SOAP_DEFAULT_ns2__Category;
#else
	*a = (enum ns2__Category)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__Category[] =
{	{ (long)ns2__Category__feature, "feature" },
	{ (long)ns2__Category__trailer, "trailer" },
	{ (long)ns2__Category__advertisement, "advertisement" },
	{ (long)ns2__Category__policy, "policy" },
	{ (long)ns2__Category__test, "test" },
	{ (long)ns2__Category__unknown, "unknown" },
	{ (long)ns2__Category__transitional, "transitional" },
	{ (long)ns2__Category__teaser, "teaser" },
	{ (long)ns2__Category__rating, "rating" },
	{ (long)ns2__Category__short_, "short" },
	{ (long)ns2__Category__psa, "psa" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__Category2s(struct soap *soap, enum ns2__Category n)
{	const char *s = soap_code_str(soap_codes_ns2__Category, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Category(struct soap *soap, const char *tag, int id, const enum ns2__Category *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Category), type) || soap_send(soap, soap_ns2__Category2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__Category(struct soap *soap, const char *s, enum ns2__Category *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__Category, s);
	if (map)
		*a = (enum ns2__Category)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__Category)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__Category * SOAP_FMAC4 soap_in_ns2__Category(struct soap *soap, const char *tag, enum ns2__Category *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__Category *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Category, sizeof(enum ns2__Category), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__Category(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__Category *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Category, 0, sizeof(enum ns2__Category), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Category(struct soap *soap, const enum ns2__Category *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__Category);
	if (soap_out_ns2__Category(soap, tag?tag:"ns2:Category", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Category * SOAP_FMAC4 soap_get_ns2__Category(struct soap *soap, enum ns2__Category *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Category(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CueMarkerType(struct soap *soap, enum ns2__CueMarkerType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CueMarkerType
	*a = SOAP_DEFAULT_ns2__CueMarkerType;
#else
	*a = (enum ns2__CueMarkerType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CueMarkerType[] =
{	{ (long)ns2__CueMarkerType__clipStart, "clipStart" },
	{ (long)ns2__CueMarkerType__clipEnd, "clipEnd" },
	{ (long)ns2__CueMarkerType__FFOC, "FFOC" },
	{ (long)ns2__CueMarkerType__LFOC, "LFOC" },
	{ (long)ns2__CueMarkerType__FFTC, "FFTC" },
	{ (long)ns2__CueMarkerType__LFTC, "LFTC" },
	{ (long)ns2__CueMarkerType__FFOI, "FFOI" },
	{ (long)ns2__CueMarkerType__LFOI, "LFOI" },
	{ (long)ns2__CueMarkerType__FFEC, "FFEC" },
	{ (long)ns2__CueMarkerType__LFEC, "LFEC" },
	{ (long)ns2__CueMarkerType__FFOB, "FFOB" },
	{ (long)ns2__CueMarkerType__LFOB, "LFOB" },
	{ (long)ns2__CueMarkerType__FFMC, "FFMC" },
	{ (long)ns2__CueMarkerType__LFMC, "LFMC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CueMarkerType2s(struct soap *soap, enum ns2__CueMarkerType n)
{	const char *s = soap_code_str(soap_codes_ns2__CueMarkerType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CueMarkerType(struct soap *soap, const char *tag, int id, const enum ns2__CueMarkerType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CueMarkerType), type) || soap_send(soap, soap_ns2__CueMarkerType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CueMarkerType(struct soap *soap, const char *s, enum ns2__CueMarkerType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CueMarkerType, s);
	if (map)
		*a = (enum ns2__CueMarkerType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 13)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CueMarkerType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CueMarkerType * SOAP_FMAC4 soap_in_ns2__CueMarkerType(struct soap *soap, const char *tag, enum ns2__CueMarkerType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CueMarkerType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CueMarkerType, sizeof(enum ns2__CueMarkerType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CueMarkerType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CueMarkerType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CueMarkerType, 0, sizeof(enum ns2__CueMarkerType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CueMarkerType(struct soap *soap, const enum ns2__CueMarkerType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__CueMarkerType);
	if (soap_out_ns2__CueMarkerType(soap, tag?tag:"ns2:CueMarkerType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CueMarkerType * SOAP_FMAC4 soap_get_ns2__CueMarkerType(struct soap *soap, enum ns2__CueMarkerType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CueMarkerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__LensFormat(struct soap *soap, enum ns2__LensFormat *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__LensFormat
	*a = SOAP_DEFAULT_ns2__LensFormat;
#else
	*a = (enum ns2__LensFormat)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__LensFormat[] =
{	{ (long)ns2__LensFormat__flat, "flat" },
	{ (long)ns2__LensFormat__anamorphic, "anamorphic" },
	{ (long)ns2__LensFormat__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__LensFormat2s(struct soap *soap, enum ns2__LensFormat n)
{	const char *s = soap_code_str(soap_codes_ns2__LensFormat, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LensFormat(struct soap *soap, const char *tag, int id, const enum ns2__LensFormat *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LensFormat), type) || soap_send(soap, soap_ns2__LensFormat2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__LensFormat(struct soap *soap, const char *s, enum ns2__LensFormat *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__LensFormat, s);
	if (map)
		*a = (enum ns2__LensFormat)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__LensFormat)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__LensFormat * SOAP_FMAC4 soap_in_ns2__LensFormat(struct soap *soap, const char *tag, enum ns2__LensFormat *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__LensFormat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LensFormat, sizeof(enum ns2__LensFormat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__LensFormat(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__LensFormat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LensFormat, 0, sizeof(enum ns2__LensFormat), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__LensFormat(struct soap *soap, const enum ns2__LensFormat *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__LensFormat);
	if (soap_out_ns2__LensFormat(soap, tag?tag:"ns2:LensFormat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__LensFormat * SOAP_FMAC4 soap_get_ns2__LensFormat(struct soap *soap, enum ns2__LensFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LensFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ErrorType(struct soap *soap, enum ns2__ErrorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ErrorType
	*a = SOAP_DEFAULT_ns2__ErrorType;
#else
	*a = (enum ns2__ErrorType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ErrorType[] =
{	{ (long)ns2__ErrorType__missing, "missing" },
	{ (long)ns2__ErrorType__corrupt, "corrupt" },
	{ (long)ns2__ErrorType__not_licensed, "not-licensed" },
	{ (long)ns2__ErrorType__not_clip, "not-clip" },
	{ (long)ns2__ErrorType__not_still, "not-still" },
	{ (long)ns2__ErrorType__transferring, "transferring" },
	{ (long)ns2__ErrorType__unsupported, "unsupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ErrorType2s(struct soap *soap, enum ns2__ErrorType n)
{	const char *s = soap_code_str(soap_codes_ns2__ErrorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ErrorType(struct soap *soap, const char *tag, int id, const enum ns2__ErrorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ErrorType), type) || soap_send(soap, soap_ns2__ErrorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ErrorType(struct soap *soap, const char *s, enum ns2__ErrorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ErrorType, s);
	if (map)
		*a = (enum ns2__ErrorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ErrorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ErrorType * SOAP_FMAC4 soap_in_ns2__ErrorType(struct soap *soap, const char *tag, enum ns2__ErrorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ErrorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ErrorType, sizeof(enum ns2__ErrorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ErrorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ErrorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ErrorType, 0, sizeof(enum ns2__ErrorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ErrorType(struct soap *soap, const enum ns2__ErrorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__ErrorType);
	if (soap_out_ns2__ErrorType(soap, tag?tag:"ns2:ErrorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ErrorType * SOAP_FMAC4 soap_get_ns2__ErrorType(struct soap *soap, enum ns2__ErrorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ErrorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MPAARating(struct soap *soap, enum ns2__MPAARating *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MPAARating
	*a = SOAP_DEFAULT_ns2__MPAARating;
#else
	*a = (enum ns2__MPAARating)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MPAARating[] =
{	{ (long)ns2__MPAARating__G, "G" },
	{ (long)ns2__MPAARating__PG, "PG" },
	{ (long)ns2__MPAARating__PG_13, "PG-13" },
	{ (long)ns2__MPAARating__NC_17, "NC-17" },
	{ (long)ns2__MPAARating__R, "R" },
	{ (long)ns2__MPAARating__X, "X" },
	{ (long)ns2__MPAARating__unrated, "unrated" },
	{ (long)ns2__MPAARating__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MPAARating2s(struct soap *soap, enum ns2__MPAARating n)
{	const char *s = soap_code_str(soap_codes_ns2__MPAARating, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MPAARating(struct soap *soap, const char *tag, int id, const enum ns2__MPAARating *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MPAARating), type) || soap_send(soap, soap_ns2__MPAARating2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MPAARating(struct soap *soap, const char *s, enum ns2__MPAARating *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MPAARating, s);
	if (map)
		*a = (enum ns2__MPAARating)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MPAARating)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MPAARating * SOAP_FMAC4 soap_in_ns2__MPAARating(struct soap *soap, const char *tag, enum ns2__MPAARating *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MPAARating *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MPAARating, sizeof(enum ns2__MPAARating), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MPAARating(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MPAARating *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MPAARating, 0, sizeof(enum ns2__MPAARating), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MPAARating(struct soap *soap, const enum ns2__MPAARating *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__MPAARating);
	if (soap_out_ns2__MPAARating(soap, tag?tag:"ns2:MPAARating", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MPAARating * SOAP_FMAC4 soap_get_ns2__MPAARating(struct soap *soap, enum ns2__MPAARating *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MPAARating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void __ns4__getWayParamsResponse_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->__ns4__getWayParamsResponse_sequence::gainDB);
	soap_default_float(soap, &this->__ns4__getWayParamsResponse_sequence::delayMs);
	soap_default_ns2__polarity(soap, &this->__ns4__getWayParamsResponse_sequence::polarity);
}

void __ns4__getWayParamsResponse_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int __ns4__getWayParamsResponse_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns4__getWayParamsResponse_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__getWayParamsResponse_sequence(struct soap *soap, const char *tag, int id, const __ns4__getWayParamsResponse_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_float(soap, "gainDB", -1, &(a->__ns4__getWayParamsResponse_sequence::gainDB), ""))
		return soap->error;
	if (soap_out_float(soap, "delayMs", -1, &(a->__ns4__getWayParamsResponse_sequence::delayMs), ""))
		return soap->error;
	if (soap_out_ns2__polarity(soap, "polarity", -1, &(a->__ns4__getWayParamsResponse_sequence::polarity), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns4__getWayParamsResponse_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns4__getWayParamsResponse_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns4__getWayParamsResponse_sequence * SOAP_FMAC4 soap_in___ns4__getWayParamsResponse_sequence(struct soap *soap, const char *tag, __ns4__getWayParamsResponse_sequence *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (__ns4__getWayParamsResponse_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns4__getWayParamsResponse_sequence, sizeof(__ns4__getWayParamsResponse_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_gainDB1 = 1;
	size_t soap_flag_delayMs1 = 1;
	size_t soap_flag_polarity1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gainDB1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gainDB", &(a->__ns4__getWayParamsResponse_sequence::gainDB), "xsd:float"))
				{	soap_flag_gainDB1--;
					continue;
				}
			if (soap_flag_delayMs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "delayMs", &(a->__ns4__getWayParamsResponse_sequence::delayMs), "xsd:float"))
				{	soap_flag_delayMs1--;
					continue;
				}
			if (soap_flag_polarity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__polarity(soap, "polarity", &(a->__ns4__getWayParamsResponse_sequence::polarity), "ns2:polarity"))
				{	soap_flag_polarity1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gainDB1 > 0 || soap_flag_delayMs1 > 0 || soap_flag_polarity1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns4__getWayParamsResponse_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns4:getWayParamsResponse-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns4__getWayParamsResponse_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns4__getWayParamsResponse_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns4__getWayParamsResponse_sequence * SOAP_FMAC4 soap_get___ns4__getWayParamsResponse_sequence(struct soap *soap, __ns4__getWayParamsResponse_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__getWayParamsResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns4__getWayParamsResponse_sequence * SOAP_FMAC2 soap_instantiate___ns4__getWayParamsResponse_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getWayParamsResponse_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getWayParamsResponse_sequence, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns4__getWayParamsResponse_sequence);
		if (size)
			*size = sizeof(__ns4__getWayParamsResponse_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__ns4__getWayParamsResponse_sequence, n);
		if (size)
			*size = n * sizeof(__ns4__getWayParamsResponse_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__ns4__getWayParamsResponse_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getWayParamsResponse_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns4__getWayParamsResponse_sequence %p -> %p\n", q, p));
	*(__ns4__getWayParamsResponse_sequence*)p = *(__ns4__getWayParamsResponse_sequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__timeZone(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__timeZone(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__timeZone), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__timeZone(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__timeZone, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "\\+|-[0-1][0-9]:[0-5][0-9]")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__timeZone, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__timeZone, 0, sizeof(std::string), 0, soap_copy_ns2__timeZone);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__timeZone(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__timeZone);
	if (soap_out_ns2__timeZone(soap, tag?tag:"ns2:timeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__timeZone(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__timeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__filterID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__filterID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__filterID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__filterID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__filterID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__filterID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__filterID, 0, sizeof(std::string), 0, soap_copy_ns2__filterID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__filterID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__filterID);
	if (soap_out_ns2__filterID(soap, tag?tag:"ns2:filterID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__filterID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__filterID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UUID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UUID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__UUID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__UUID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__UUID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "urn:uuid:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__UUID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__UUID, 0, sizeof(std::string), 0, soap_copy_ns2__UUID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UUID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_ns2__UUID);
	if (soap_out_ns2__UUID(soap, tag?tag:"ns2:UUID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__UUID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UUID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns4__deleteWayFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__deleteWayFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns4__deleteWayFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__deleteWayFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__deleteWayFilterResponse(struct soap *soap, const char *tag, int id, const _ns4__deleteWayFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__deleteWayFilterResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__deleteWayFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__deleteWayFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__deleteWayFilterResponse * SOAP_FMAC4 soap_in__ns4__deleteWayFilterResponse(struct soap *soap, const char *tag, _ns4__deleteWayFilterResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__deleteWayFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__deleteWayFilterResponse, sizeof(_ns4__deleteWayFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__deleteWayFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__deleteWayFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__deleteWayFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__deleteWayFilterResponse, 0, sizeof(_ns4__deleteWayFilterResponse), 0, soap_copy__ns4__deleteWayFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__deleteWayFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__deleteWayFilterResponse);
	if (this->soap_out(soap, tag?tag:"ns4:deleteWayFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__deleteWayFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__deleteWayFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__deleteWayFilterResponse * SOAP_FMAC4 soap_get__ns4__deleteWayFilterResponse(struct soap *soap, _ns4__deleteWayFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__deleteWayFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__deleteWayFilterResponse * SOAP_FMAC2 soap_instantiate__ns4__deleteWayFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__deleteWayFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__deleteWayFilterResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__deleteWayFilterResponse);
		if (size)
			*size = sizeof(_ns4__deleteWayFilterResponse);
		((_ns4__deleteWayFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__deleteWayFilterResponse, n);
		if (size)
			*size = n * sizeof(_ns4__deleteWayFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__deleteWayFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__deleteWayFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__deleteWayFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__deleteWayFilterResponse %p -> %p\n", q, p));
	*(_ns4__deleteWayFilterResponse*)p = *(_ns4__deleteWayFilterResponse*)q;
}

void _ns4__deleteWayFilterRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns4__deleteWayFilterRequest::channel);
	soap_default_xsd__integer(soap, &this->_ns4__deleteWayFilterRequest::way);
	soap_default_ns2__filterID(soap, &this->_ns4__deleteWayFilterRequest::id);
	/* transient soap skipped */
}

void _ns4__deleteWayFilterRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns4__deleteWayFilterRequest::channel);
	soap_serialize_xsd__integer(soap, &this->_ns4__deleteWayFilterRequest::way);
	soap_serialize_ns2__filterID(soap, &this->_ns4__deleteWayFilterRequest::id);
	/* transient soap skipped */
#endif
}

int _ns4__deleteWayFilterRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__deleteWayFilterRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__deleteWayFilterRequest(struct soap *soap, const char *tag, int id, const _ns4__deleteWayFilterRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__deleteWayFilterRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "channel", -1, &(a->_ns4__deleteWayFilterRequest::channel), ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "way", -1, &(a->_ns4__deleteWayFilterRequest::way), ""))
		return soap->error;
	if (soap_out_ns2__filterID(soap, "id", -1, &(a->_ns4__deleteWayFilterRequest::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__deleteWayFilterRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__deleteWayFilterRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__deleteWayFilterRequest * SOAP_FMAC4 soap_in__ns4__deleteWayFilterRequest(struct soap *soap, const char *tag, _ns4__deleteWayFilterRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__deleteWayFilterRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__deleteWayFilterRequest, sizeof(_ns4__deleteWayFilterRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__deleteWayFilterRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__deleteWayFilterRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_way1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channel", &(a->_ns4__deleteWayFilterRequest::channel), "xsd:integer"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_way1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "way", &(a->_ns4__deleteWayFilterRequest::way), "xsd:integer"))
				{	soap_flag_way1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__filterID(soap, "id", &(a->_ns4__deleteWayFilterRequest::id), "ns2:filterID"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__deleteWayFilterRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__deleteWayFilterRequest, 0, sizeof(_ns4__deleteWayFilterRequest), 0, soap_copy__ns4__deleteWayFilterRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0 || soap_flag_way1 > 0 || soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__deleteWayFilterRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__deleteWayFilterRequest);
	if (this->soap_out(soap, tag?tag:"ns4:deleteWayFilterRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__deleteWayFilterRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__deleteWayFilterRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__deleteWayFilterRequest * SOAP_FMAC4 soap_get__ns4__deleteWayFilterRequest(struct soap *soap, _ns4__deleteWayFilterRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__deleteWayFilterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__deleteWayFilterRequest * SOAP_FMAC2 soap_instantiate__ns4__deleteWayFilterRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__deleteWayFilterRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__deleteWayFilterRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__deleteWayFilterRequest);
		if (size)
			*size = sizeof(_ns4__deleteWayFilterRequest);
		((_ns4__deleteWayFilterRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__deleteWayFilterRequest, n);
		if (size)
			*size = n * sizeof(_ns4__deleteWayFilterRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__deleteWayFilterRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__deleteWayFilterRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__deleteWayFilterRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__deleteWayFilterRequest %p -> %p\n", q, p));
	*(_ns4__deleteWayFilterRequest*)p = *(_ns4__deleteWayFilterRequest*)q;
}

void _ns4__setWayFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__setWayFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns4__setWayFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__setWayFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__setWayFilterResponse(struct soap *soap, const char *tag, int id, const _ns4__setWayFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__setWayFilterResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__setWayFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__setWayFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__setWayFilterResponse * SOAP_FMAC4 soap_in__ns4__setWayFilterResponse(struct soap *soap, const char *tag, _ns4__setWayFilterResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__setWayFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__setWayFilterResponse, sizeof(_ns4__setWayFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__setWayFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__setWayFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__setWayFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__setWayFilterResponse, 0, sizeof(_ns4__setWayFilterResponse), 0, soap_copy__ns4__setWayFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__setWayFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__setWayFilterResponse);
	if (this->soap_out(soap, tag?tag:"ns4:setWayFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__setWayFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__setWayFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__setWayFilterResponse * SOAP_FMAC4 soap_get__ns4__setWayFilterResponse(struct soap *soap, _ns4__setWayFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__setWayFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__setWayFilterResponse * SOAP_FMAC2 soap_instantiate__ns4__setWayFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__setWayFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__setWayFilterResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__setWayFilterResponse);
		if (size)
			*size = sizeof(_ns4__setWayFilterResponse);
		((_ns4__setWayFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__setWayFilterResponse, n);
		if (size)
			*size = n * sizeof(_ns4__setWayFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__setWayFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__setWayFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__setWayFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__setWayFilterResponse %p -> %p\n", q, p));
	*(_ns4__setWayFilterResponse*)p = *(_ns4__setWayFilterResponse*)q;
}

void _ns4__setWayFilterRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns4__setWayFilterRequest::channel);
	soap_default_xsd__integer(soap, &this->_ns4__setWayFilterRequest::way);
	this->_ns4__setWayFilterRequest::crossover = NULL;
	this->_ns4__setWayFilterRequest::shelf = NULL;
	this->_ns4__setWayFilterRequest::parametric = NULL;
	this->_ns4__setWayFilterRequest::allPass = NULL;
	/* transient soap skipped */
}

void _ns4__setWayFilterRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns4__setWayFilterRequest::channel);
	soap_serialize_xsd__integer(soap, &this->_ns4__setWayFilterRequest::way);
	soap_serialize_PointerTons2__crossoverFilter(soap, &this->_ns4__setWayFilterRequest::crossover);
	soap_serialize_PointerTons2__shelfFilter(soap, &this->_ns4__setWayFilterRequest::shelf);
	soap_serialize_PointerTons2__parametricFilter(soap, &this->_ns4__setWayFilterRequest::parametric);
	soap_serialize_PointerTons2__allPassFilter(soap, &this->_ns4__setWayFilterRequest::allPass);
	/* transient soap skipped */
#endif
}

int _ns4__setWayFilterRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__setWayFilterRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__setWayFilterRequest(struct soap *soap, const char *tag, int id, const _ns4__setWayFilterRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__setWayFilterRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "channel", -1, &(a->_ns4__setWayFilterRequest::channel), ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "way", -1, &(a->_ns4__setWayFilterRequest::way), ""))
		return soap->error;
	if (soap_out_PointerTons2__crossoverFilter(soap, "crossover", -1, &(a->_ns4__setWayFilterRequest::crossover), ""))
		return soap->error;
	if (soap_out_PointerTons2__shelfFilter(soap, "shelf", -1, &(a->_ns4__setWayFilterRequest::shelf), ""))
		return soap->error;
	if (soap_out_PointerTons2__parametricFilter(soap, "parametric", -1, &(a->_ns4__setWayFilterRequest::parametric), ""))
		return soap->error;
	if (soap_out_PointerTons2__allPassFilter(soap, "allPass", -1, &(a->_ns4__setWayFilterRequest::allPass), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__setWayFilterRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__setWayFilterRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__setWayFilterRequest * SOAP_FMAC4 soap_in__ns4__setWayFilterRequest(struct soap *soap, const char *tag, _ns4__setWayFilterRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__setWayFilterRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__setWayFilterRequest, sizeof(_ns4__setWayFilterRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__setWayFilterRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__setWayFilterRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_way1 = 1;
	size_t soap_flag_crossover1 = 1;
	size_t soap_flag_shelf1 = 1;
	size_t soap_flag_parametric1 = 1;
	size_t soap_flag_allPass1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channel", &(a->_ns4__setWayFilterRequest::channel), "xsd:integer"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_way1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "way", &(a->_ns4__setWayFilterRequest::way), "xsd:integer"))
				{	soap_flag_way1--;
					continue;
				}
			if (soap_flag_crossover1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__crossoverFilter(soap, "crossover", &(a->_ns4__setWayFilterRequest::crossover), "ns2:crossoverFilter"))
				{	soap_flag_crossover1--;
					continue;
				}
			if (soap_flag_shelf1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__shelfFilter(soap, "shelf", &(a->_ns4__setWayFilterRequest::shelf), "ns2:shelfFilter"))
				{	soap_flag_shelf1--;
					continue;
				}
			if (soap_flag_parametric1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__parametricFilter(soap, "parametric", &(a->_ns4__setWayFilterRequest::parametric), "ns2:parametricFilter"))
				{	soap_flag_parametric1--;
					continue;
				}
			if (soap_flag_allPass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__allPassFilter(soap, "allPass", &(a->_ns4__setWayFilterRequest::allPass), "ns2:allPassFilter"))
				{	soap_flag_allPass1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__setWayFilterRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__setWayFilterRequest, 0, sizeof(_ns4__setWayFilterRequest), 0, soap_copy__ns4__setWayFilterRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0 || soap_flag_way1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__setWayFilterRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__setWayFilterRequest);
	if (this->soap_out(soap, tag?tag:"ns4:setWayFilterRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__setWayFilterRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__setWayFilterRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__setWayFilterRequest * SOAP_FMAC4 soap_get__ns4__setWayFilterRequest(struct soap *soap, _ns4__setWayFilterRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__setWayFilterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__setWayFilterRequest * SOAP_FMAC2 soap_instantiate__ns4__setWayFilterRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__setWayFilterRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__setWayFilterRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__setWayFilterRequest);
		if (size)
			*size = sizeof(_ns4__setWayFilterRequest);
		((_ns4__setWayFilterRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__setWayFilterRequest, n);
		if (size)
			*size = n * sizeof(_ns4__setWayFilterRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__setWayFilterRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__setWayFilterRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__setWayFilterRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__setWayFilterRequest %p -> %p\n", q, p));
	*(_ns4__setWayFilterRequest*)p = *(_ns4__setWayFilterRequest*)q;
}

void _ns4__getWayFiltersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__crossoverFilter(soap, &this->_ns4__getWayFiltersResponse::crossover);
	soap_default_std__vectorTemplateOfPointerTons2__shelfFilter(soap, &this->_ns4__getWayFiltersResponse::shelf);
	soap_default_std__vectorTemplateOfPointerTons2__parametricFilter(soap, &this->_ns4__getWayFiltersResponse::parametric);
	soap_default_std__vectorTemplateOfPointerTons2__allPassFilter(soap, &this->_ns4__getWayFiltersResponse::allPass);
	/* transient soap skipped */
}

void _ns4__getWayFiltersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__crossoverFilter(soap, &this->_ns4__getWayFiltersResponse::crossover);
	soap_serialize_std__vectorTemplateOfPointerTons2__shelfFilter(soap, &this->_ns4__getWayFiltersResponse::shelf);
	soap_serialize_std__vectorTemplateOfPointerTons2__parametricFilter(soap, &this->_ns4__getWayFiltersResponse::parametric);
	soap_serialize_std__vectorTemplateOfPointerTons2__allPassFilter(soap, &this->_ns4__getWayFiltersResponse::allPass);
	/* transient soap skipped */
#endif
}

int _ns4__getWayFiltersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getWayFiltersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getWayFiltersResponse(struct soap *soap, const char *tag, int id, const _ns4__getWayFiltersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getWayFiltersResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__crossoverFilter(soap, "crossover", -1, &(a->_ns4__getWayFiltersResponse::crossover), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__shelfFilter(soap, "shelf", -1, &(a->_ns4__getWayFiltersResponse::shelf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__parametricFilter(soap, "parametric", -1, &(a->_ns4__getWayFiltersResponse::parametric), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__allPassFilter(soap, "allPass", -1, &(a->_ns4__getWayFiltersResponse::allPass), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getWayFiltersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getWayFiltersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getWayFiltersResponse * SOAP_FMAC4 soap_in__ns4__getWayFiltersResponse(struct soap *soap, const char *tag, _ns4__getWayFiltersResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getWayFiltersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getWayFiltersResponse, sizeof(_ns4__getWayFiltersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getWayFiltersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getWayFiltersResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__crossoverFilter(soap, "crossover", &(a->_ns4__getWayFiltersResponse::crossover), "ns2:crossoverFilter"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__shelfFilter(soap, "shelf", &(a->_ns4__getWayFiltersResponse::shelf), "ns2:shelfFilter"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__parametricFilter(soap, "parametric", &(a->_ns4__getWayFiltersResponse::parametric), "ns2:parametricFilter"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__allPassFilter(soap, "allPass", &(a->_ns4__getWayFiltersResponse::allPass), "ns2:allPassFilter"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getWayFiltersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getWayFiltersResponse, 0, sizeof(_ns4__getWayFiltersResponse), 0, soap_copy__ns4__getWayFiltersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__getWayFiltersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getWayFiltersResponse);
	if (this->soap_out(soap, tag?tag:"ns4:getWayFiltersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getWayFiltersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getWayFiltersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getWayFiltersResponse * SOAP_FMAC4 soap_get__ns4__getWayFiltersResponse(struct soap *soap, _ns4__getWayFiltersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getWayFiltersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getWayFiltersResponse * SOAP_FMAC2 soap_instantiate__ns4__getWayFiltersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getWayFiltersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getWayFiltersResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getWayFiltersResponse);
		if (size)
			*size = sizeof(_ns4__getWayFiltersResponse);
		((_ns4__getWayFiltersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getWayFiltersResponse, n);
		if (size)
			*size = n * sizeof(_ns4__getWayFiltersResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getWayFiltersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getWayFiltersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getWayFiltersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getWayFiltersResponse %p -> %p\n", q, p));
	*(_ns4__getWayFiltersResponse*)p = *(_ns4__getWayFiltersResponse*)q;
}

void _ns4__getWayFiltersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns4__getWayFiltersRequest::channel);
	soap_default_xsd__integer(soap, &this->_ns4__getWayFiltersRequest::way);
	/* transient soap skipped */
}

void _ns4__getWayFiltersRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns4__getWayFiltersRequest::channel);
	soap_serialize_xsd__integer(soap, &this->_ns4__getWayFiltersRequest::way);
	/* transient soap skipped */
#endif
}

int _ns4__getWayFiltersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getWayFiltersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getWayFiltersRequest(struct soap *soap, const char *tag, int id, const _ns4__getWayFiltersRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getWayFiltersRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "channel", -1, &(a->_ns4__getWayFiltersRequest::channel), ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "way", -1, &(a->_ns4__getWayFiltersRequest::way), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getWayFiltersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getWayFiltersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getWayFiltersRequest * SOAP_FMAC4 soap_in__ns4__getWayFiltersRequest(struct soap *soap, const char *tag, _ns4__getWayFiltersRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getWayFiltersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getWayFiltersRequest, sizeof(_ns4__getWayFiltersRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getWayFiltersRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getWayFiltersRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_way1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channel", &(a->_ns4__getWayFiltersRequest::channel), "xsd:integer"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_way1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "way", &(a->_ns4__getWayFiltersRequest::way), "xsd:integer"))
				{	soap_flag_way1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getWayFiltersRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getWayFiltersRequest, 0, sizeof(_ns4__getWayFiltersRequest), 0, soap_copy__ns4__getWayFiltersRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0 || soap_flag_way1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__getWayFiltersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getWayFiltersRequest);
	if (this->soap_out(soap, tag?tag:"ns4:getWayFiltersRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getWayFiltersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getWayFiltersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getWayFiltersRequest * SOAP_FMAC4 soap_get__ns4__getWayFiltersRequest(struct soap *soap, _ns4__getWayFiltersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getWayFiltersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getWayFiltersRequest * SOAP_FMAC2 soap_instantiate__ns4__getWayFiltersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getWayFiltersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getWayFiltersRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getWayFiltersRequest);
		if (size)
			*size = sizeof(_ns4__getWayFiltersRequest);
		((_ns4__getWayFiltersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getWayFiltersRequest, n);
		if (size)
			*size = n * sizeof(_ns4__getWayFiltersRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getWayFiltersRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getWayFiltersRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getWayFiltersRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getWayFiltersRequest %p -> %p\n", q, p));
	*(_ns4__getWayFiltersRequest*)p = *(_ns4__getWayFiltersRequest*)q;
}

void _ns4__getWayParamsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__getWayParamsResponse::__getWayParamsResponse_sequence = NULL;
	/* transient soap skipped */
}

void _ns4__getWayParamsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo__ns4__getWayParamsResponse_sequence(soap, &this->_ns4__getWayParamsResponse::__getWayParamsResponse_sequence);
	/* transient soap skipped */
#endif
}

int _ns4__getWayParamsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getWayParamsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getWayParamsResponse(struct soap *soap, const char *tag, int id, const _ns4__getWayParamsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getWayParamsResponse), type))
		return soap->error;
	if (soap_out_PointerTo__ns4__getWayParamsResponse_sequence(soap, "-getWayParamsResponse-sequence", -1, &(a->_ns4__getWayParamsResponse::__getWayParamsResponse_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getWayParamsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getWayParamsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getWayParamsResponse * SOAP_FMAC4 soap_in__ns4__getWayParamsResponse(struct soap *soap, const char *tag, _ns4__getWayParamsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getWayParamsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getWayParamsResponse, sizeof(_ns4__getWayParamsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getWayParamsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getWayParamsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___getWayParamsResponse_sequence1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___getWayParamsResponse_sequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo__ns4__getWayParamsResponse_sequence(soap, "-getWayParamsResponse-sequence", &(a->_ns4__getWayParamsResponse::__getWayParamsResponse_sequence), "-ns4:getWayParamsResponse-sequence"))
				{	soap_flag___getWayParamsResponse_sequence1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getWayParamsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getWayParamsResponse, 0, sizeof(_ns4__getWayParamsResponse), 0, soap_copy__ns4__getWayParamsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__getWayParamsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getWayParamsResponse);
	if (this->soap_out(soap, tag?tag:"ns4:getWayParamsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getWayParamsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getWayParamsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getWayParamsResponse * SOAP_FMAC4 soap_get__ns4__getWayParamsResponse(struct soap *soap, _ns4__getWayParamsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getWayParamsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getWayParamsResponse * SOAP_FMAC2 soap_instantiate__ns4__getWayParamsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getWayParamsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getWayParamsResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getWayParamsResponse);
		if (size)
			*size = sizeof(_ns4__getWayParamsResponse);
		((_ns4__getWayParamsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getWayParamsResponse, n);
		if (size)
			*size = n * sizeof(_ns4__getWayParamsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getWayParamsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getWayParamsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getWayParamsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getWayParamsResponse %p -> %p\n", q, p));
	*(_ns4__getWayParamsResponse*)p = *(_ns4__getWayParamsResponse*)q;
}

void _ns4__getWayParamsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns4__getWayParamsRequest::channel);
	soap_default_xsd__integer(soap, &this->_ns4__getWayParamsRequest::way);
	/* transient soap skipped */
}

void _ns4__getWayParamsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns4__getWayParamsRequest::channel);
	soap_serialize_xsd__integer(soap, &this->_ns4__getWayParamsRequest::way);
	/* transient soap skipped */
#endif
}

int _ns4__getWayParamsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getWayParamsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getWayParamsRequest(struct soap *soap, const char *tag, int id, const _ns4__getWayParamsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getWayParamsRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "channel", -1, &(a->_ns4__getWayParamsRequest::channel), ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "way", -1, &(a->_ns4__getWayParamsRequest::way), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getWayParamsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getWayParamsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getWayParamsRequest * SOAP_FMAC4 soap_in__ns4__getWayParamsRequest(struct soap *soap, const char *tag, _ns4__getWayParamsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getWayParamsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getWayParamsRequest, sizeof(_ns4__getWayParamsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getWayParamsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getWayParamsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_way1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channel", &(a->_ns4__getWayParamsRequest::channel), "xsd:integer"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_way1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "way", &(a->_ns4__getWayParamsRequest::way), "xsd:integer"))
				{	soap_flag_way1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getWayParamsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getWayParamsRequest, 0, sizeof(_ns4__getWayParamsRequest), 0, soap_copy__ns4__getWayParamsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0 || soap_flag_way1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__getWayParamsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getWayParamsRequest);
	if (this->soap_out(soap, tag?tag:"ns4:getWayParamsRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getWayParamsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getWayParamsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getWayParamsRequest * SOAP_FMAC4 soap_get__ns4__getWayParamsRequest(struct soap *soap, _ns4__getWayParamsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getWayParamsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getWayParamsRequest * SOAP_FMAC2 soap_instantiate__ns4__getWayParamsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getWayParamsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getWayParamsRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getWayParamsRequest);
		if (size)
			*size = sizeof(_ns4__getWayParamsRequest);
		((_ns4__getWayParamsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getWayParamsRequest, n);
		if (size)
			*size = n * sizeof(_ns4__getWayParamsRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getWayParamsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getWayParamsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getWayParamsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getWayParamsRequest %p -> %p\n", q, p));
	*(_ns4__getWayParamsRequest*)p = *(_ns4__getWayParamsRequest*)q;
}

void _ns4__setWayParamsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__setWayParamsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns4__setWayParamsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__setWayParamsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__setWayParamsResponse(struct soap *soap, const char *tag, int id, const _ns4__setWayParamsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__setWayParamsResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__setWayParamsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__setWayParamsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__setWayParamsResponse * SOAP_FMAC4 soap_in__ns4__setWayParamsResponse(struct soap *soap, const char *tag, _ns4__setWayParamsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__setWayParamsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__setWayParamsResponse, sizeof(_ns4__setWayParamsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__setWayParamsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__setWayParamsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__setWayParamsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__setWayParamsResponse, 0, sizeof(_ns4__setWayParamsResponse), 0, soap_copy__ns4__setWayParamsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__setWayParamsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__setWayParamsResponse);
	if (this->soap_out(soap, tag?tag:"ns4:setWayParamsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__setWayParamsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__setWayParamsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__setWayParamsResponse * SOAP_FMAC4 soap_get__ns4__setWayParamsResponse(struct soap *soap, _ns4__setWayParamsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__setWayParamsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__setWayParamsResponse * SOAP_FMAC2 soap_instantiate__ns4__setWayParamsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__setWayParamsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__setWayParamsResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__setWayParamsResponse);
		if (size)
			*size = sizeof(_ns4__setWayParamsResponse);
		((_ns4__setWayParamsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__setWayParamsResponse, n);
		if (size)
			*size = n * sizeof(_ns4__setWayParamsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__setWayParamsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__setWayParamsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__setWayParamsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__setWayParamsResponse %p -> %p\n", q, p));
	*(_ns4__setWayParamsResponse*)p = *(_ns4__setWayParamsResponse*)q;
}

void _ns4__setWayParamsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns4__setWayParamsRequest::channel);
	soap_default_xsd__integer(soap, &this->_ns4__setWayParamsRequest::way);
	soap_default_float(soap, &this->_ns4__setWayParamsRequest::gainDB);
	soap_default_float(soap, &this->_ns4__setWayParamsRequest::delayMs);
	soap_default_ns2__polarity(soap, &this->_ns4__setWayParamsRequest::polarity);
	/* transient soap skipped */
}

void _ns4__setWayParamsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns4__setWayParamsRequest::channel);
	soap_serialize_xsd__integer(soap, &this->_ns4__setWayParamsRequest::way);
	/* transient soap skipped */
#endif
}

int _ns4__setWayParamsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__setWayParamsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__setWayParamsRequest(struct soap *soap, const char *tag, int id, const _ns4__setWayParamsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__setWayParamsRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "channel", -1, &(a->_ns4__setWayParamsRequest::channel), ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "way", -1, &(a->_ns4__setWayParamsRequest::way), ""))
		return soap->error;
	if (soap_out_float(soap, "gainDB", -1, &(a->_ns4__setWayParamsRequest::gainDB), ""))
		return soap->error;
	if (soap_out_float(soap, "delayMs", -1, &(a->_ns4__setWayParamsRequest::delayMs), ""))
		return soap->error;
	if (soap_out_ns2__polarity(soap, "polarity", -1, &(a->_ns4__setWayParamsRequest::polarity), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__setWayParamsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__setWayParamsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__setWayParamsRequest * SOAP_FMAC4 soap_in__ns4__setWayParamsRequest(struct soap *soap, const char *tag, _ns4__setWayParamsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__setWayParamsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__setWayParamsRequest, sizeof(_ns4__setWayParamsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__setWayParamsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__setWayParamsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_way1 = 1;
	size_t soap_flag_gainDB1 = 1;
	size_t soap_flag_delayMs1 = 1;
	size_t soap_flag_polarity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channel", &(a->_ns4__setWayParamsRequest::channel), "xsd:integer"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_way1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "way", &(a->_ns4__setWayParamsRequest::way), "xsd:integer"))
				{	soap_flag_way1--;
					continue;
				}
			if (soap_flag_gainDB1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gainDB", &(a->_ns4__setWayParamsRequest::gainDB), "xsd:float"))
				{	soap_flag_gainDB1--;
					continue;
				}
			if (soap_flag_delayMs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "delayMs", &(a->_ns4__setWayParamsRequest::delayMs), "xsd:float"))
				{	soap_flag_delayMs1--;
					continue;
				}
			if (soap_flag_polarity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__polarity(soap, "polarity", &(a->_ns4__setWayParamsRequest::polarity), "ns2:polarity"))
				{	soap_flag_polarity1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__setWayParamsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__setWayParamsRequest, 0, sizeof(_ns4__setWayParamsRequest), 0, soap_copy__ns4__setWayParamsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0 || soap_flag_way1 > 0 || soap_flag_gainDB1 > 0 || soap_flag_delayMs1 > 0 || soap_flag_polarity1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__setWayParamsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__setWayParamsRequest);
	if (this->soap_out(soap, tag?tag:"ns4:setWayParamsRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__setWayParamsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__setWayParamsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__setWayParamsRequest * SOAP_FMAC4 soap_get__ns4__setWayParamsRequest(struct soap *soap, _ns4__setWayParamsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__setWayParamsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__setWayParamsRequest * SOAP_FMAC2 soap_instantiate__ns4__setWayParamsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__setWayParamsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__setWayParamsRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__setWayParamsRequest);
		if (size)
			*size = sizeof(_ns4__setWayParamsRequest);
		((_ns4__setWayParamsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__setWayParamsRequest, n);
		if (size)
			*size = n * sizeof(_ns4__setWayParamsRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__setWayParamsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__setWayParamsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__setWayParamsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__setWayParamsRequest %p -> %p\n", q, p));
	*(_ns4__setWayParamsRequest*)p = *(_ns4__setWayParamsRequest*)q;
}

void _ns4__getSystemVersionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__keyValuePair(soap, &this->_ns4__getSystemVersionsResponse::keyValuePair);
	/* transient soap skipped */
}

void _ns4__getSystemVersionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__keyValuePair(soap, &this->_ns4__getSystemVersionsResponse::keyValuePair);
	/* transient soap skipped */
#endif
}

int _ns4__getSystemVersionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getSystemVersionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getSystemVersionsResponse(struct soap *soap, const char *tag, int id, const _ns4__getSystemVersionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getSystemVersionsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__keyValuePair(soap, "keyValuePair", -1, &(a->_ns4__getSystemVersionsResponse::keyValuePair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getSystemVersionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getSystemVersionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getSystemVersionsResponse * SOAP_FMAC4 soap_in__ns4__getSystemVersionsResponse(struct soap *soap, const char *tag, _ns4__getSystemVersionsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getSystemVersionsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getSystemVersionsResponse, sizeof(_ns4__getSystemVersionsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getSystemVersionsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getSystemVersionsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__keyValuePair(soap, "keyValuePair", &(a->_ns4__getSystemVersionsResponse::keyValuePair), "ns2:keyValuePair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getSystemVersionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getSystemVersionsResponse, 0, sizeof(_ns4__getSystemVersionsResponse), 0, soap_copy__ns4__getSystemVersionsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__getSystemVersionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getSystemVersionsResponse);
	if (this->soap_out(soap, tag?tag:"ns4:getSystemVersionsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getSystemVersionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getSystemVersionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getSystemVersionsResponse * SOAP_FMAC4 soap_get__ns4__getSystemVersionsResponse(struct soap *soap, _ns4__getSystemVersionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getSystemVersionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getSystemVersionsResponse * SOAP_FMAC2 soap_instantiate__ns4__getSystemVersionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getSystemVersionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getSystemVersionsResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getSystemVersionsResponse);
		if (size)
			*size = sizeof(_ns4__getSystemVersionsResponse);
		((_ns4__getSystemVersionsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getSystemVersionsResponse, n);
		if (size)
			*size = n * sizeof(_ns4__getSystemVersionsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getSystemVersionsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getSystemVersionsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getSystemVersionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getSystemVersionsResponse %p -> %p\n", q, p));
	*(_ns4__getSystemVersionsResponse*)p = *(_ns4__getSystemVersionsResponse*)q;
}

void _ns4__getSystemVersionsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__getSystemVersionsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns4__getSystemVersionsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getSystemVersionsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getSystemVersionsRequest(struct soap *soap, const char *tag, int id, const _ns4__getSystemVersionsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getSystemVersionsRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getSystemVersionsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getSystemVersionsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getSystemVersionsRequest * SOAP_FMAC4 soap_in__ns4__getSystemVersionsRequest(struct soap *soap, const char *tag, _ns4__getSystemVersionsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getSystemVersionsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getSystemVersionsRequest, sizeof(_ns4__getSystemVersionsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getSystemVersionsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getSystemVersionsRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getSystemVersionsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getSystemVersionsRequest, 0, sizeof(_ns4__getSystemVersionsRequest), 0, soap_copy__ns4__getSystemVersionsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__getSystemVersionsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getSystemVersionsRequest);
	if (this->soap_out(soap, tag?tag:"ns4:getSystemVersionsRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getSystemVersionsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getSystemVersionsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getSystemVersionsRequest * SOAP_FMAC4 soap_get__ns4__getSystemVersionsRequest(struct soap *soap, _ns4__getSystemVersionsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getSystemVersionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getSystemVersionsRequest * SOAP_FMAC2 soap_instantiate__ns4__getSystemVersionsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getSystemVersionsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getSystemVersionsRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getSystemVersionsRequest);
		if (size)
			*size = sizeof(_ns4__getSystemVersionsRequest);
		((_ns4__getSystemVersionsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getSystemVersionsRequest, n);
		if (size)
			*size = n * sizeof(_ns4__getSystemVersionsRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getSystemVersionsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getSystemVersionsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getSystemVersionsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getSystemVersionsRequest %p -> %p\n", q, p));
	*(_ns4__getSystemVersionsRequest*)p = *(_ns4__getSystemVersionsRequest*)q;
}

void _ns4__getCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns4__getCertificateResponse::name);
	soap_default_std__string(soap, &this->_ns4__getCertificateResponse::certificate);
	/* transient soap skipped */
}

void _ns4__getCertificateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns4__getCertificateResponse::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns4__getCertificateResponse::name);
	soap_embedded(soap, &this->_ns4__getCertificateResponse::certificate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns4__getCertificateResponse::certificate);
	/* transient soap skipped */
#endif
}

int _ns4__getCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getCertificateResponse(struct soap *soap, const char *tag, int id, const _ns4__getCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getCertificateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->_ns4__getCertificateResponse::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "certificate", -1, &(a->_ns4__getCertificateResponse::certificate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getCertificateResponse * SOAP_FMAC4 soap_in__ns4__getCertificateResponse(struct soap *soap, const char *tag, _ns4__getCertificateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getCertificateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getCertificateResponse, sizeof(_ns4__getCertificateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getCertificateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getCertificateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_certificate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->_ns4__getCertificateResponse::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_certificate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "certificate", &(a->_ns4__getCertificateResponse::certificate), "xsd:string"))
				{	soap_flag_certificate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getCertificateResponse, 0, sizeof(_ns4__getCertificateResponse), 0, soap_copy__ns4__getCertificateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_certificate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__getCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getCertificateResponse);
	if (this->soap_out(soap, tag?tag:"ns4:getCertificateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getCertificateResponse * SOAP_FMAC4 soap_get__ns4__getCertificateResponse(struct soap *soap, _ns4__getCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getCertificateResponse * SOAP_FMAC2 soap_instantiate__ns4__getCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getCertificateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getCertificateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getCertificateResponse);
		if (size)
			*size = sizeof(_ns4__getCertificateResponse);
		((_ns4__getCertificateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getCertificateResponse, n);
		if (size)
			*size = n * sizeof(_ns4__getCertificateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getCertificateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getCertificateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getCertificateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getCertificateResponse %p -> %p\n", q, p));
	*(_ns4__getCertificateResponse*)p = *(_ns4__getCertificateResponse*)q;
}

void _ns4__getCertificateRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__getCertificateRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns4__getCertificateRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__getCertificateRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__getCertificateRequest(struct soap *soap, const char *tag, int id, const _ns4__getCertificateRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__getCertificateRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__getCertificateRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__getCertificateRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__getCertificateRequest * SOAP_FMAC4 soap_in__ns4__getCertificateRequest(struct soap *soap, const char *tag, _ns4__getCertificateRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__getCertificateRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__getCertificateRequest, sizeof(_ns4__getCertificateRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__getCertificateRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__getCertificateRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__getCertificateRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__getCertificateRequest, 0, sizeof(_ns4__getCertificateRequest), 0, soap_copy__ns4__getCertificateRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__getCertificateRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns4__getCertificateRequest);
	if (this->soap_out(soap, tag?tag:"ns4:getCertificateRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__getCertificateRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__getCertificateRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__getCertificateRequest * SOAP_FMAC4 soap_get__ns4__getCertificateRequest(struct soap *soap, _ns4__getCertificateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__getCertificateRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__getCertificateRequest * SOAP_FMAC2 soap_instantiate__ns4__getCertificateRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__getCertificateRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__getCertificateRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__getCertificateRequest);
		if (size)
			*size = sizeof(_ns4__getCertificateRequest);
		((_ns4__getCertificateRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__getCertificateRequest, n);
		if (size)
			*size = n * sizeof(_ns4__getCertificateRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__getCertificateRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__getCertificateRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__getCertificateRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__getCertificateRequest %p -> %p\n", q, p));
	*(_ns4__getCertificateRequest*)p = *(_ns4__getCertificateRequest*)q;
}

void _ns3__performSystemUpgradeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__performSystemUpgradeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__performSystemUpgradeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__performSystemUpgradeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__performSystemUpgradeResponse(struct soap *soap, const char *tag, int id, const _ns3__performSystemUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__performSystemUpgradeResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__performSystemUpgradeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__performSystemUpgradeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__performSystemUpgradeResponse * SOAP_FMAC4 soap_in__ns3__performSystemUpgradeResponse(struct soap *soap, const char *tag, _ns3__performSystemUpgradeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__performSystemUpgradeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__performSystemUpgradeResponse, sizeof(_ns3__performSystemUpgradeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__performSystemUpgradeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__performSystemUpgradeResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__performSystemUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__performSystemUpgradeResponse, 0, sizeof(_ns3__performSystemUpgradeResponse), 0, soap_copy__ns3__performSystemUpgradeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__performSystemUpgradeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__performSystemUpgradeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:performSystemUpgradeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__performSystemUpgradeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__performSystemUpgradeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__performSystemUpgradeResponse * SOAP_FMAC4 soap_get__ns3__performSystemUpgradeResponse(struct soap *soap, _ns3__performSystemUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__performSystemUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__performSystemUpgradeResponse * SOAP_FMAC2 soap_instantiate__ns3__performSystemUpgradeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__performSystemUpgradeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__performSystemUpgradeResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__performSystemUpgradeResponse);
		if (size)
			*size = sizeof(_ns3__performSystemUpgradeResponse);
		((_ns3__performSystemUpgradeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__performSystemUpgradeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__performSystemUpgradeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__performSystemUpgradeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__performSystemUpgradeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__performSystemUpgradeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__performSystemUpgradeResponse %p -> %p\n", q, p));
	*(_ns3__performSystemUpgradeResponse*)p = *(_ns3__performSystemUpgradeResponse*)q;
}

void _ns3__performSystemUpgradeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__performSystemUpgradeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__performSystemUpgradeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__performSystemUpgradeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__performSystemUpgradeRequest(struct soap *soap, const char *tag, int id, const _ns3__performSystemUpgradeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__performSystemUpgradeRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__performSystemUpgradeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__performSystemUpgradeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__performSystemUpgradeRequest * SOAP_FMAC4 soap_in__ns3__performSystemUpgradeRequest(struct soap *soap, const char *tag, _ns3__performSystemUpgradeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__performSystemUpgradeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__performSystemUpgradeRequest, sizeof(_ns3__performSystemUpgradeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__performSystemUpgradeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__performSystemUpgradeRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__performSystemUpgradeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__performSystemUpgradeRequest, 0, sizeof(_ns3__performSystemUpgradeRequest), 0, soap_copy__ns3__performSystemUpgradeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__performSystemUpgradeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__performSystemUpgradeRequest);
	if (this->soap_out(soap, tag?tag:"ns3:performSystemUpgradeRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__performSystemUpgradeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__performSystemUpgradeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__performSystemUpgradeRequest * SOAP_FMAC4 soap_get__ns3__performSystemUpgradeRequest(struct soap *soap, _ns3__performSystemUpgradeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__performSystemUpgradeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__performSystemUpgradeRequest * SOAP_FMAC2 soap_instantiate__ns3__performSystemUpgradeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__performSystemUpgradeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__performSystemUpgradeRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__performSystemUpgradeRequest);
		if (size)
			*size = sizeof(_ns3__performSystemUpgradeRequest);
		((_ns3__performSystemUpgradeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__performSystemUpgradeRequest, n);
		if (size)
			*size = n * sizeof(_ns3__performSystemUpgradeRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__performSystemUpgradeRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__performSystemUpgradeRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__performSystemUpgradeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__performSystemUpgradeRequest %p -> %p\n", q, p));
	*(_ns3__performSystemUpgradeRequest*)p = *(_ns3__performSystemUpgradeRequest*)q;
}

void _ns3__enableAutoEqModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns3__enableAutoEqModeResponse::result);
	/* transient soap skipped */
}

void _ns3__enableAutoEqModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns3__enableAutoEqModeResponse::result);
	/* transient soap skipped */
#endif
}

int _ns3__enableAutoEqModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__enableAutoEqModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__enableAutoEqModeResponse(struct soap *soap, const char *tag, int id, const _ns3__enableAutoEqModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__enableAutoEqModeResponse), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "result", -1, &(a->_ns3__enableAutoEqModeResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__enableAutoEqModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__enableAutoEqModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__enableAutoEqModeResponse * SOAP_FMAC4 soap_in__ns3__enableAutoEqModeResponse(struct soap *soap, const char *tag, _ns3__enableAutoEqModeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__enableAutoEqModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__enableAutoEqModeResponse, sizeof(_ns3__enableAutoEqModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__enableAutoEqModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__enableAutoEqModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "result", &(a->_ns3__enableAutoEqModeResponse::result), "xsd:integer"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__enableAutoEqModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__enableAutoEqModeResponse, 0, sizeof(_ns3__enableAutoEqModeResponse), 0, soap_copy__ns3__enableAutoEqModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__enableAutoEqModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__enableAutoEqModeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:enableAutoEqModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__enableAutoEqModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__enableAutoEqModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__enableAutoEqModeResponse * SOAP_FMAC4 soap_get__ns3__enableAutoEqModeResponse(struct soap *soap, _ns3__enableAutoEqModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__enableAutoEqModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__enableAutoEqModeResponse * SOAP_FMAC2 soap_instantiate__ns3__enableAutoEqModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__enableAutoEqModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__enableAutoEqModeResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__enableAutoEqModeResponse);
		if (size)
			*size = sizeof(_ns3__enableAutoEqModeResponse);
		((_ns3__enableAutoEqModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__enableAutoEqModeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__enableAutoEqModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__enableAutoEqModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__enableAutoEqModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__enableAutoEqModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__enableAutoEqModeResponse %p -> %p\n", q, p));
	*(_ns3__enableAutoEqModeResponse*)p = *(_ns3__enableAutoEqModeResponse*)q;
}

void _ns3__enableAutoEqModeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__enableAutoEqModeRequest::enable);
	/* transient soap skipped */
}

void _ns3__enableAutoEqModeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__enableAutoEqModeRequest::enable, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__enableAutoEqModeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__enableAutoEqModeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__enableAutoEqModeRequest(struct soap *soap, const char *tag, int id, const _ns3__enableAutoEqModeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__enableAutoEqModeRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "enable", -1, &(a->_ns3__enableAutoEqModeRequest::enable), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__enableAutoEqModeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__enableAutoEqModeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__enableAutoEqModeRequest * SOAP_FMAC4 soap_in__ns3__enableAutoEqModeRequest(struct soap *soap, const char *tag, _ns3__enableAutoEqModeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__enableAutoEqModeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__enableAutoEqModeRequest, sizeof(_ns3__enableAutoEqModeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__enableAutoEqModeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__enableAutoEqModeRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enable", &(a->_ns3__enableAutoEqModeRequest::enable), "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__enableAutoEqModeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__enableAutoEqModeRequest, 0, sizeof(_ns3__enableAutoEqModeRequest), 0, soap_copy__ns3__enableAutoEqModeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__enableAutoEqModeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__enableAutoEqModeRequest);
	if (this->soap_out(soap, tag?tag:"ns3:enableAutoEqModeRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__enableAutoEqModeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__enableAutoEqModeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__enableAutoEqModeRequest * SOAP_FMAC4 soap_get__ns3__enableAutoEqModeRequest(struct soap *soap, _ns3__enableAutoEqModeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__enableAutoEqModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__enableAutoEqModeRequest * SOAP_FMAC2 soap_instantiate__ns3__enableAutoEqModeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__enableAutoEqModeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__enableAutoEqModeRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__enableAutoEqModeRequest);
		if (size)
			*size = sizeof(_ns3__enableAutoEqModeRequest);
		((_ns3__enableAutoEqModeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__enableAutoEqModeRequest, n);
		if (size)
			*size = n * sizeof(_ns3__enableAutoEqModeRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__enableAutoEqModeRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__enableAutoEqModeRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__enableAutoEqModeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__enableAutoEqModeRequest %p -> %p\n", q, p));
	*(_ns3__enableAutoEqModeRequest*)p = *(_ns3__enableAutoEqModeRequest*)q;
}

void _ns3__isAutoEqModeEnabledResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__isAutoEqModeEnabledResponse::enabled);
	/* transient soap skipped */
}

void _ns3__isAutoEqModeEnabledResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__isAutoEqModeEnabledResponse::enabled, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__isAutoEqModeEnabledResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isAutoEqModeEnabledResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isAutoEqModeEnabledResponse(struct soap *soap, const char *tag, int id, const _ns3__isAutoEqModeEnabledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isAutoEqModeEnabledResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "enabled", -1, &(a->_ns3__isAutoEqModeEnabledResponse::enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isAutoEqModeEnabledResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isAutoEqModeEnabledResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isAutoEqModeEnabledResponse * SOAP_FMAC4 soap_in__ns3__isAutoEqModeEnabledResponse(struct soap *soap, const char *tag, _ns3__isAutoEqModeEnabledResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isAutoEqModeEnabledResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isAutoEqModeEnabledResponse, sizeof(_ns3__isAutoEqModeEnabledResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isAutoEqModeEnabledResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isAutoEqModeEnabledResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enabled", &(a->_ns3__isAutoEqModeEnabledResponse::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isAutoEqModeEnabledResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isAutoEqModeEnabledResponse, 0, sizeof(_ns3__isAutoEqModeEnabledResponse), 0, soap_copy__ns3__isAutoEqModeEnabledResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__isAutoEqModeEnabledResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isAutoEqModeEnabledResponse);
	if (this->soap_out(soap, tag?tag:"ns3:isAutoEqModeEnabledResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isAutoEqModeEnabledResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isAutoEqModeEnabledResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isAutoEqModeEnabledResponse * SOAP_FMAC4 soap_get__ns3__isAutoEqModeEnabledResponse(struct soap *soap, _ns3__isAutoEqModeEnabledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isAutoEqModeEnabledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isAutoEqModeEnabledResponse * SOAP_FMAC2 soap_instantiate__ns3__isAutoEqModeEnabledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isAutoEqModeEnabledResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isAutoEqModeEnabledResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isAutoEqModeEnabledResponse);
		if (size)
			*size = sizeof(_ns3__isAutoEqModeEnabledResponse);
		((_ns3__isAutoEqModeEnabledResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isAutoEqModeEnabledResponse, n);
		if (size)
			*size = n * sizeof(_ns3__isAutoEqModeEnabledResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isAutoEqModeEnabledResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isAutoEqModeEnabledResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isAutoEqModeEnabledResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isAutoEqModeEnabledResponse %p -> %p\n", q, p));
	*(_ns3__isAutoEqModeEnabledResponse*)p = *(_ns3__isAutoEqModeEnabledResponse*)q;
}

void _ns3__isAutoEqModeEnabledRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__isAutoEqModeEnabledRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__isAutoEqModeEnabledRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isAutoEqModeEnabledRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isAutoEqModeEnabledRequest(struct soap *soap, const char *tag, int id, const _ns3__isAutoEqModeEnabledRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isAutoEqModeEnabledRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isAutoEqModeEnabledRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isAutoEqModeEnabledRequest * SOAP_FMAC4 soap_in__ns3__isAutoEqModeEnabledRequest(struct soap *soap, const char *tag, _ns3__isAutoEqModeEnabledRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isAutoEqModeEnabledRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest, sizeof(_ns3__isAutoEqModeEnabledRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isAutoEqModeEnabledRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isAutoEqModeEnabledRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isAutoEqModeEnabledRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest, 0, sizeof(_ns3__isAutoEqModeEnabledRequest), 0, soap_copy__ns3__isAutoEqModeEnabledRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__isAutoEqModeEnabledRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest);
	if (this->soap_out(soap, tag?tag:"ns3:isAutoEqModeEnabledRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isAutoEqModeEnabledRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isAutoEqModeEnabledRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isAutoEqModeEnabledRequest * SOAP_FMAC4 soap_get__ns3__isAutoEqModeEnabledRequest(struct soap *soap, _ns3__isAutoEqModeEnabledRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isAutoEqModeEnabledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isAutoEqModeEnabledRequest * SOAP_FMAC2 soap_instantiate__ns3__isAutoEqModeEnabledRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isAutoEqModeEnabledRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isAutoEqModeEnabledRequest);
		if (size)
			*size = sizeof(_ns3__isAutoEqModeEnabledRequest);
		((_ns3__isAutoEqModeEnabledRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isAutoEqModeEnabledRequest, n);
		if (size)
			*size = n * sizeof(_ns3__isAutoEqModeEnabledRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isAutoEqModeEnabledRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isAutoEqModeEnabledRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isAutoEqModeEnabledRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isAutoEqModeEnabledRequest %p -> %p\n", q, p));
	*(_ns3__isAutoEqModeEnabledRequest*)p = *(_ns3__isAutoEqModeEnabledRequest*)q;
}

void _ns3__setTimeZoneResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setTimeZoneResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setTimeZoneResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setTimeZoneResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setTimeZoneResponse(struct soap *soap, const char *tag, int id, const _ns3__setTimeZoneResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setTimeZoneResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setTimeZoneResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setTimeZoneResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setTimeZoneResponse * SOAP_FMAC4 soap_in__ns3__setTimeZoneResponse(struct soap *soap, const char *tag, _ns3__setTimeZoneResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setTimeZoneResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setTimeZoneResponse, sizeof(_ns3__setTimeZoneResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setTimeZoneResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setTimeZoneResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setTimeZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setTimeZoneResponse, 0, sizeof(_ns3__setTimeZoneResponse), 0, soap_copy__ns3__setTimeZoneResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setTimeZoneResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setTimeZoneResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setTimeZoneResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setTimeZoneResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setTimeZoneResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setTimeZoneResponse * SOAP_FMAC4 soap_get__ns3__setTimeZoneResponse(struct soap *soap, _ns3__setTimeZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setTimeZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setTimeZoneResponse * SOAP_FMAC2 soap_instantiate__ns3__setTimeZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setTimeZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setTimeZoneResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setTimeZoneResponse);
		if (size)
			*size = sizeof(_ns3__setTimeZoneResponse);
		((_ns3__setTimeZoneResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setTimeZoneResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setTimeZoneResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setTimeZoneResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setTimeZoneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setTimeZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setTimeZoneResponse %p -> %p\n", q, p));
	*(_ns3__setTimeZoneResponse*)p = *(_ns3__setTimeZoneResponse*)q;
}

void _ns3__setTimeZoneRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__timeZone(soap, &this->_ns3__setTimeZoneRequest::timeZone);
	/* transient soap skipped */
}

void _ns3__setTimeZoneRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__timeZone(soap, &this->_ns3__setTimeZoneRequest::timeZone);
	/* transient soap skipped */
#endif
}

int _ns3__setTimeZoneRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setTimeZoneRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setTimeZoneRequest(struct soap *soap, const char *tag, int id, const _ns3__setTimeZoneRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setTimeZoneRequest), type))
		return soap->error;
	if (soap_out_ns2__timeZone(soap, "timeZone", -1, &(a->_ns3__setTimeZoneRequest::timeZone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setTimeZoneRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setTimeZoneRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setTimeZoneRequest * SOAP_FMAC4 soap_in__ns3__setTimeZoneRequest(struct soap *soap, const char *tag, _ns3__setTimeZoneRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setTimeZoneRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setTimeZoneRequest, sizeof(_ns3__setTimeZoneRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setTimeZoneRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setTimeZoneRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_timeZone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timeZone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__timeZone(soap, "timeZone", &(a->_ns3__setTimeZoneRequest::timeZone), "ns2:timeZone"))
				{	soap_flag_timeZone1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setTimeZoneRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setTimeZoneRequest, 0, sizeof(_ns3__setTimeZoneRequest), 0, soap_copy__ns3__setTimeZoneRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeZone1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setTimeZoneRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setTimeZoneRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setTimeZoneRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setTimeZoneRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setTimeZoneRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setTimeZoneRequest * SOAP_FMAC4 soap_get__ns3__setTimeZoneRequest(struct soap *soap, _ns3__setTimeZoneRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setTimeZoneRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setTimeZoneRequest * SOAP_FMAC2 soap_instantiate__ns3__setTimeZoneRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setTimeZoneRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setTimeZoneRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setTimeZoneRequest);
		if (size)
			*size = sizeof(_ns3__setTimeZoneRequest);
		((_ns3__setTimeZoneRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setTimeZoneRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setTimeZoneRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setTimeZoneRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setTimeZoneRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setTimeZoneRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setTimeZoneRequest %p -> %p\n", q, p));
	*(_ns3__setTimeZoneRequest*)p = *(_ns3__setTimeZoneRequest*)q;
}

void _ns3__getTimeZoneResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__timeZone(soap, &this->_ns3__getTimeZoneResponse::timeZone);
	/* transient soap skipped */
}

void _ns3__getTimeZoneResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__timeZone(soap, &this->_ns3__getTimeZoneResponse::timeZone);
	/* transient soap skipped */
#endif
}

int _ns3__getTimeZoneResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getTimeZoneResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getTimeZoneResponse(struct soap *soap, const char *tag, int id, const _ns3__getTimeZoneResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getTimeZoneResponse), type))
		return soap->error;
	if (soap_out_ns2__timeZone(soap, "timeZone", -1, &(a->_ns3__getTimeZoneResponse::timeZone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getTimeZoneResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getTimeZoneResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getTimeZoneResponse * SOAP_FMAC4 soap_in__ns3__getTimeZoneResponse(struct soap *soap, const char *tag, _ns3__getTimeZoneResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getTimeZoneResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getTimeZoneResponse, sizeof(_ns3__getTimeZoneResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getTimeZoneResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getTimeZoneResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_timeZone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timeZone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__timeZone(soap, "timeZone", &(a->_ns3__getTimeZoneResponse::timeZone), "ns2:timeZone"))
				{	soap_flag_timeZone1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getTimeZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getTimeZoneResponse, 0, sizeof(_ns3__getTimeZoneResponse), 0, soap_copy__ns3__getTimeZoneResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeZone1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getTimeZoneResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getTimeZoneResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getTimeZoneResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getTimeZoneResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getTimeZoneResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getTimeZoneResponse * SOAP_FMAC4 soap_get__ns3__getTimeZoneResponse(struct soap *soap, _ns3__getTimeZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getTimeZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getTimeZoneResponse * SOAP_FMAC2 soap_instantiate__ns3__getTimeZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getTimeZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getTimeZoneResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getTimeZoneResponse);
		if (size)
			*size = sizeof(_ns3__getTimeZoneResponse);
		((_ns3__getTimeZoneResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getTimeZoneResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getTimeZoneResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getTimeZoneResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getTimeZoneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getTimeZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getTimeZoneResponse %p -> %p\n", q, p));
	*(_ns3__getTimeZoneResponse*)p = *(_ns3__getTimeZoneResponse*)q;
}

void _ns3__getTimeZoneRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getTimeZoneRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getTimeZoneRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getTimeZoneRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getTimeZoneRequest(struct soap *soap, const char *tag, int id, const _ns3__getTimeZoneRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getTimeZoneRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getTimeZoneRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getTimeZoneRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getTimeZoneRequest * SOAP_FMAC4 soap_in__ns3__getTimeZoneRequest(struct soap *soap, const char *tag, _ns3__getTimeZoneRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getTimeZoneRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getTimeZoneRequest, sizeof(_ns3__getTimeZoneRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getTimeZoneRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getTimeZoneRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getTimeZoneRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getTimeZoneRequest, 0, sizeof(_ns3__getTimeZoneRequest), 0, soap_copy__ns3__getTimeZoneRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getTimeZoneRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getTimeZoneRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getTimeZoneRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getTimeZoneRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getTimeZoneRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getTimeZoneRequest * SOAP_FMAC4 soap_get__ns3__getTimeZoneRequest(struct soap *soap, _ns3__getTimeZoneRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getTimeZoneRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getTimeZoneRequest * SOAP_FMAC2 soap_instantiate__ns3__getTimeZoneRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getTimeZoneRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getTimeZoneRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getTimeZoneRequest);
		if (size)
			*size = sizeof(_ns3__getTimeZoneRequest);
		((_ns3__getTimeZoneRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getTimeZoneRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getTimeZoneRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getTimeZoneRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getTimeZoneRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getTimeZoneRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getTimeZoneRequest %p -> %p\n", q, p));
	*(_ns3__getTimeZoneRequest*)p = *(_ns3__getTimeZoneRequest*)q;
}

void _ns3__getDeviceAlarmsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_ns2__alarm(soap, &this->_ns3__getDeviceAlarmsResponse::ns2__alarm);
	/* transient soap skipped */
}

void _ns3__getDeviceAlarmsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTo_ns2__alarm(soap, &this->_ns3__getDeviceAlarmsResponse::ns2__alarm);
	/* transient soap skipped */
#endif
}

int _ns3__getDeviceAlarmsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getDeviceAlarmsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getDeviceAlarmsResponse(struct soap *soap, const char *tag, int id, const _ns3__getDeviceAlarmsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getDeviceAlarmsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns2:alarm");
	if (soap_out_std__vectorTemplateOfPointerTo_ns2__alarm(soap, "ns2:alarm", -1, &(a->_ns3__getDeviceAlarmsResponse::ns2__alarm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getDeviceAlarmsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getDeviceAlarmsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getDeviceAlarmsResponse * SOAP_FMAC4 soap_in__ns3__getDeviceAlarmsResponse(struct soap *soap, const char *tag, _ns3__getDeviceAlarmsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getDeviceAlarmsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getDeviceAlarmsResponse, sizeof(_ns3__getDeviceAlarmsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getDeviceAlarmsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getDeviceAlarmsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_ns2__alarm(soap, "ns2:alarm", &(a->_ns3__getDeviceAlarmsResponse::ns2__alarm), ""))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns2:alarm");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getDeviceAlarmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getDeviceAlarmsResponse, 0, sizeof(_ns3__getDeviceAlarmsResponse), 0, soap_copy__ns3__getDeviceAlarmsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getDeviceAlarmsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getDeviceAlarmsResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getDeviceAlarmsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getDeviceAlarmsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getDeviceAlarmsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getDeviceAlarmsResponse * SOAP_FMAC4 soap_get__ns3__getDeviceAlarmsResponse(struct soap *soap, _ns3__getDeviceAlarmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getDeviceAlarmsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getDeviceAlarmsResponse * SOAP_FMAC2 soap_instantiate__ns3__getDeviceAlarmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getDeviceAlarmsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getDeviceAlarmsResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getDeviceAlarmsResponse);
		if (size)
			*size = sizeof(_ns3__getDeviceAlarmsResponse);
		((_ns3__getDeviceAlarmsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getDeviceAlarmsResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getDeviceAlarmsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getDeviceAlarmsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getDeviceAlarmsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getDeviceAlarmsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getDeviceAlarmsResponse %p -> %p\n", q, p));
	*(_ns3__getDeviceAlarmsResponse*)p = *(_ns3__getDeviceAlarmsResponse*)q;
}

void _ns3__getDeviceAlarmsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getDeviceAlarmsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getDeviceAlarmsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getDeviceAlarmsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getDeviceAlarmsRequest(struct soap *soap, const char *tag, int id, const _ns3__getDeviceAlarmsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getDeviceAlarmsRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getDeviceAlarmsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getDeviceAlarmsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getDeviceAlarmsRequest * SOAP_FMAC4 soap_in__ns3__getDeviceAlarmsRequest(struct soap *soap, const char *tag, _ns3__getDeviceAlarmsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getDeviceAlarmsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getDeviceAlarmsRequest, sizeof(_ns3__getDeviceAlarmsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getDeviceAlarmsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getDeviceAlarmsRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getDeviceAlarmsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getDeviceAlarmsRequest, 0, sizeof(_ns3__getDeviceAlarmsRequest), 0, soap_copy__ns3__getDeviceAlarmsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getDeviceAlarmsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getDeviceAlarmsRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getDeviceAlarmsRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getDeviceAlarmsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getDeviceAlarmsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getDeviceAlarmsRequest * SOAP_FMAC4 soap_get__ns3__getDeviceAlarmsRequest(struct soap *soap, _ns3__getDeviceAlarmsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getDeviceAlarmsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getDeviceAlarmsRequest * SOAP_FMAC2 soap_instantiate__ns3__getDeviceAlarmsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getDeviceAlarmsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getDeviceAlarmsRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getDeviceAlarmsRequest);
		if (size)
			*size = sizeof(_ns3__getDeviceAlarmsRequest);
		((_ns3__getDeviceAlarmsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getDeviceAlarmsRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getDeviceAlarmsRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getDeviceAlarmsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getDeviceAlarmsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getDeviceAlarmsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getDeviceAlarmsRequest %p -> %p\n", q, p));
	*(_ns3__getDeviceAlarmsRequest*)p = *(_ns3__getDeviceAlarmsRequest*)q;
}

void _ns3__getDeviceInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__keyValuePair(soap, &this->_ns3__getDeviceInfoResponse::keyValuePair);
	/* transient soap skipped */
}

void _ns3__getDeviceInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__keyValuePair(soap, &this->_ns3__getDeviceInfoResponse::keyValuePair);
	/* transient soap skipped */
#endif
}

int _ns3__getDeviceInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getDeviceInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getDeviceInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__getDeviceInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getDeviceInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__keyValuePair(soap, "keyValuePair", -1, &(a->_ns3__getDeviceInfoResponse::keyValuePair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getDeviceInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getDeviceInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getDeviceInfoResponse * SOAP_FMAC4 soap_in__ns3__getDeviceInfoResponse(struct soap *soap, const char *tag, _ns3__getDeviceInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getDeviceInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getDeviceInfoResponse, sizeof(_ns3__getDeviceInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getDeviceInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getDeviceInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__keyValuePair(soap, "keyValuePair", &(a->_ns3__getDeviceInfoResponse::keyValuePair), "ns2:keyValuePair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getDeviceInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getDeviceInfoResponse, 0, sizeof(_ns3__getDeviceInfoResponse), 0, soap_copy__ns3__getDeviceInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getDeviceInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getDeviceInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getDeviceInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getDeviceInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getDeviceInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getDeviceInfoResponse * SOAP_FMAC4 soap_get__ns3__getDeviceInfoResponse(struct soap *soap, _ns3__getDeviceInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getDeviceInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getDeviceInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__getDeviceInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getDeviceInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getDeviceInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getDeviceInfoResponse);
		if (size)
			*size = sizeof(_ns3__getDeviceInfoResponse);
		((_ns3__getDeviceInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getDeviceInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getDeviceInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getDeviceInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getDeviceInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getDeviceInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getDeviceInfoResponse %p -> %p\n", q, p));
	*(_ns3__getDeviceInfoResponse*)p = *(_ns3__getDeviceInfoResponse*)q;
}

void _ns3__getDeviceInfoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getDeviceInfoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getDeviceInfoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getDeviceInfoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getDeviceInfoRequest(struct soap *soap, const char *tag, int id, const _ns3__getDeviceInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getDeviceInfoRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getDeviceInfoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getDeviceInfoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getDeviceInfoRequest * SOAP_FMAC4 soap_in__ns3__getDeviceInfoRequest(struct soap *soap, const char *tag, _ns3__getDeviceInfoRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getDeviceInfoRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getDeviceInfoRequest, sizeof(_ns3__getDeviceInfoRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getDeviceInfoRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getDeviceInfoRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getDeviceInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getDeviceInfoRequest, 0, sizeof(_ns3__getDeviceInfoRequest), 0, soap_copy__ns3__getDeviceInfoRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getDeviceInfoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getDeviceInfoRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getDeviceInfoRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getDeviceInfoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getDeviceInfoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getDeviceInfoRequest * SOAP_FMAC4 soap_get__ns3__getDeviceInfoRequest(struct soap *soap, _ns3__getDeviceInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getDeviceInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getDeviceInfoRequest * SOAP_FMAC2 soap_instantiate__ns3__getDeviceInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getDeviceInfoRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getDeviceInfoRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getDeviceInfoRequest);
		if (size)
			*size = sizeof(_ns3__getDeviceInfoRequest);
		((_ns3__getDeviceInfoRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getDeviceInfoRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getDeviceInfoRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getDeviceInfoRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getDeviceInfoRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getDeviceInfoRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getDeviceInfoRequest %p -> %p\n", q, p));
	*(_ns3__getDeviceInfoRequest*)p = *(_ns3__getDeviceInfoRequest*)q;
}

void _ns3__enableGlobalEqResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__enableGlobalEqResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__enableGlobalEqResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__enableGlobalEqResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__enableGlobalEqResponse(struct soap *soap, const char *tag, int id, const _ns3__enableGlobalEqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__enableGlobalEqResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__enableGlobalEqResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__enableGlobalEqResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__enableGlobalEqResponse * SOAP_FMAC4 soap_in__ns3__enableGlobalEqResponse(struct soap *soap, const char *tag, _ns3__enableGlobalEqResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__enableGlobalEqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__enableGlobalEqResponse, sizeof(_ns3__enableGlobalEqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__enableGlobalEqResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__enableGlobalEqResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__enableGlobalEqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__enableGlobalEqResponse, 0, sizeof(_ns3__enableGlobalEqResponse), 0, soap_copy__ns3__enableGlobalEqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__enableGlobalEqResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__enableGlobalEqResponse);
	if (this->soap_out(soap, tag?tag:"ns3:enableGlobalEqResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__enableGlobalEqResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__enableGlobalEqResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__enableGlobalEqResponse * SOAP_FMAC4 soap_get__ns3__enableGlobalEqResponse(struct soap *soap, _ns3__enableGlobalEqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__enableGlobalEqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__enableGlobalEqResponse * SOAP_FMAC2 soap_instantiate__ns3__enableGlobalEqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__enableGlobalEqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__enableGlobalEqResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__enableGlobalEqResponse);
		if (size)
			*size = sizeof(_ns3__enableGlobalEqResponse);
		((_ns3__enableGlobalEqResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__enableGlobalEqResponse, n);
		if (size)
			*size = n * sizeof(_ns3__enableGlobalEqResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__enableGlobalEqResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__enableGlobalEqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__enableGlobalEqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__enableGlobalEqResponse %p -> %p\n", q, p));
	*(_ns3__enableGlobalEqResponse*)p = *(_ns3__enableGlobalEqResponse*)q;
}

void _ns3__enableGlobalEqRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__enableGlobalEqRequest::enable);
	/* transient soap skipped */
}

void _ns3__enableGlobalEqRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__enableGlobalEqRequest::enable, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__enableGlobalEqRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__enableGlobalEqRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__enableGlobalEqRequest(struct soap *soap, const char *tag, int id, const _ns3__enableGlobalEqRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__enableGlobalEqRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "enable", -1, &(a->_ns3__enableGlobalEqRequest::enable), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__enableGlobalEqRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__enableGlobalEqRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__enableGlobalEqRequest * SOAP_FMAC4 soap_in__ns3__enableGlobalEqRequest(struct soap *soap, const char *tag, _ns3__enableGlobalEqRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__enableGlobalEqRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__enableGlobalEqRequest, sizeof(_ns3__enableGlobalEqRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__enableGlobalEqRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__enableGlobalEqRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enable", &(a->_ns3__enableGlobalEqRequest::enable), "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__enableGlobalEqRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__enableGlobalEqRequest, 0, sizeof(_ns3__enableGlobalEqRequest), 0, soap_copy__ns3__enableGlobalEqRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__enableGlobalEqRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__enableGlobalEqRequest);
	if (this->soap_out(soap, tag?tag:"ns3:enableGlobalEqRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__enableGlobalEqRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__enableGlobalEqRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__enableGlobalEqRequest * SOAP_FMAC4 soap_get__ns3__enableGlobalEqRequest(struct soap *soap, _ns3__enableGlobalEqRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__enableGlobalEqRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__enableGlobalEqRequest * SOAP_FMAC2 soap_instantiate__ns3__enableGlobalEqRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__enableGlobalEqRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__enableGlobalEqRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__enableGlobalEqRequest);
		if (size)
			*size = sizeof(_ns3__enableGlobalEqRequest);
		((_ns3__enableGlobalEqRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__enableGlobalEqRequest, n);
		if (size)
			*size = n * sizeof(_ns3__enableGlobalEqRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__enableGlobalEqRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__enableGlobalEqRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__enableGlobalEqRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__enableGlobalEqRequest %p -> %p\n", q, p));
	*(_ns3__enableGlobalEqRequest*)p = *(_ns3__enableGlobalEqRequest*)q;
}

void _ns3__isGlobalEqEnabledResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__isGlobalEqEnabledResponse::enabled);
	/* transient soap skipped */
}

void _ns3__isGlobalEqEnabledResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__isGlobalEqEnabledResponse::enabled, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__isGlobalEqEnabledResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isGlobalEqEnabledResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isGlobalEqEnabledResponse(struct soap *soap, const char *tag, int id, const _ns3__isGlobalEqEnabledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isGlobalEqEnabledResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "enabled", -1, &(a->_ns3__isGlobalEqEnabledResponse::enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isGlobalEqEnabledResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isGlobalEqEnabledResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isGlobalEqEnabledResponse * SOAP_FMAC4 soap_in__ns3__isGlobalEqEnabledResponse(struct soap *soap, const char *tag, _ns3__isGlobalEqEnabledResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isGlobalEqEnabledResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isGlobalEqEnabledResponse, sizeof(_ns3__isGlobalEqEnabledResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isGlobalEqEnabledResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isGlobalEqEnabledResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enabled", &(a->_ns3__isGlobalEqEnabledResponse::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isGlobalEqEnabledResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isGlobalEqEnabledResponse, 0, sizeof(_ns3__isGlobalEqEnabledResponse), 0, soap_copy__ns3__isGlobalEqEnabledResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__isGlobalEqEnabledResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isGlobalEqEnabledResponse);
	if (this->soap_out(soap, tag?tag:"ns3:isGlobalEqEnabledResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isGlobalEqEnabledResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isGlobalEqEnabledResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isGlobalEqEnabledResponse * SOAP_FMAC4 soap_get__ns3__isGlobalEqEnabledResponse(struct soap *soap, _ns3__isGlobalEqEnabledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isGlobalEqEnabledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isGlobalEqEnabledResponse * SOAP_FMAC2 soap_instantiate__ns3__isGlobalEqEnabledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isGlobalEqEnabledResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isGlobalEqEnabledResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isGlobalEqEnabledResponse);
		if (size)
			*size = sizeof(_ns3__isGlobalEqEnabledResponse);
		((_ns3__isGlobalEqEnabledResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isGlobalEqEnabledResponse, n);
		if (size)
			*size = n * sizeof(_ns3__isGlobalEqEnabledResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isGlobalEqEnabledResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isGlobalEqEnabledResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isGlobalEqEnabledResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isGlobalEqEnabledResponse %p -> %p\n", q, p));
	*(_ns3__isGlobalEqEnabledResponse*)p = *(_ns3__isGlobalEqEnabledResponse*)q;
}

void _ns3__isGlobalEqEnabledRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__isGlobalEqEnabledRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__isGlobalEqEnabledRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isGlobalEqEnabledRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isGlobalEqEnabledRequest(struct soap *soap, const char *tag, int id, const _ns3__isGlobalEqEnabledRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isGlobalEqEnabledRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isGlobalEqEnabledRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isGlobalEqEnabledRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isGlobalEqEnabledRequest * SOAP_FMAC4 soap_in__ns3__isGlobalEqEnabledRequest(struct soap *soap, const char *tag, _ns3__isGlobalEqEnabledRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isGlobalEqEnabledRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isGlobalEqEnabledRequest, sizeof(_ns3__isGlobalEqEnabledRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isGlobalEqEnabledRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isGlobalEqEnabledRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isGlobalEqEnabledRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isGlobalEqEnabledRequest, 0, sizeof(_ns3__isGlobalEqEnabledRequest), 0, soap_copy__ns3__isGlobalEqEnabledRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__isGlobalEqEnabledRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isGlobalEqEnabledRequest);
	if (this->soap_out(soap, tag?tag:"ns3:isGlobalEqEnabledRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isGlobalEqEnabledRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isGlobalEqEnabledRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isGlobalEqEnabledRequest * SOAP_FMAC4 soap_get__ns3__isGlobalEqEnabledRequest(struct soap *soap, _ns3__isGlobalEqEnabledRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isGlobalEqEnabledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isGlobalEqEnabledRequest * SOAP_FMAC2 soap_instantiate__ns3__isGlobalEqEnabledRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isGlobalEqEnabledRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isGlobalEqEnabledRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isGlobalEqEnabledRequest);
		if (size)
			*size = sizeof(_ns3__isGlobalEqEnabledRequest);
		((_ns3__isGlobalEqEnabledRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isGlobalEqEnabledRequest, n);
		if (size)
			*size = n * sizeof(_ns3__isGlobalEqEnabledRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isGlobalEqEnabledRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isGlobalEqEnabledRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isGlobalEqEnabledRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isGlobalEqEnabledRequest %p -> %p\n", q, p));
	*(_ns3__isGlobalEqEnabledRequest*)p = *(_ns3__isGlobalEqEnabledRequest*)q;
}

void _ns3__enableBassManagementResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__enableBassManagementResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__enableBassManagementResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__enableBassManagementResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__enableBassManagementResponse(struct soap *soap, const char *tag, int id, const _ns3__enableBassManagementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__enableBassManagementResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__enableBassManagementResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__enableBassManagementResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__enableBassManagementResponse * SOAP_FMAC4 soap_in__ns3__enableBassManagementResponse(struct soap *soap, const char *tag, _ns3__enableBassManagementResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__enableBassManagementResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__enableBassManagementResponse, sizeof(_ns3__enableBassManagementResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__enableBassManagementResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__enableBassManagementResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__enableBassManagementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__enableBassManagementResponse, 0, sizeof(_ns3__enableBassManagementResponse), 0, soap_copy__ns3__enableBassManagementResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__enableBassManagementResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__enableBassManagementResponse);
	if (this->soap_out(soap, tag?tag:"ns3:enableBassManagementResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__enableBassManagementResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__enableBassManagementResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__enableBassManagementResponse * SOAP_FMAC4 soap_get__ns3__enableBassManagementResponse(struct soap *soap, _ns3__enableBassManagementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__enableBassManagementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__enableBassManagementResponse * SOAP_FMAC2 soap_instantiate__ns3__enableBassManagementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__enableBassManagementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__enableBassManagementResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__enableBassManagementResponse);
		if (size)
			*size = sizeof(_ns3__enableBassManagementResponse);
		((_ns3__enableBassManagementResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__enableBassManagementResponse, n);
		if (size)
			*size = n * sizeof(_ns3__enableBassManagementResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__enableBassManagementResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__enableBassManagementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__enableBassManagementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__enableBassManagementResponse %p -> %p\n", q, p));
	*(_ns3__enableBassManagementResponse*)p = *(_ns3__enableBassManagementResponse*)q;
}

void _ns3__enableBassManagementRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__enableBassManagementRequest::enable);
	/* transient soap skipped */
}

void _ns3__enableBassManagementRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__enableBassManagementRequest::enable, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__enableBassManagementRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__enableBassManagementRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__enableBassManagementRequest(struct soap *soap, const char *tag, int id, const _ns3__enableBassManagementRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__enableBassManagementRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "enable", -1, &(a->_ns3__enableBassManagementRequest::enable), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__enableBassManagementRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__enableBassManagementRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__enableBassManagementRequest * SOAP_FMAC4 soap_in__ns3__enableBassManagementRequest(struct soap *soap, const char *tag, _ns3__enableBassManagementRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__enableBassManagementRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__enableBassManagementRequest, sizeof(_ns3__enableBassManagementRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__enableBassManagementRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__enableBassManagementRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enable", &(a->_ns3__enableBassManagementRequest::enable), "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__enableBassManagementRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__enableBassManagementRequest, 0, sizeof(_ns3__enableBassManagementRequest), 0, soap_copy__ns3__enableBassManagementRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__enableBassManagementRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__enableBassManagementRequest);
	if (this->soap_out(soap, tag?tag:"ns3:enableBassManagementRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__enableBassManagementRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__enableBassManagementRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__enableBassManagementRequest * SOAP_FMAC4 soap_get__ns3__enableBassManagementRequest(struct soap *soap, _ns3__enableBassManagementRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__enableBassManagementRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__enableBassManagementRequest * SOAP_FMAC2 soap_instantiate__ns3__enableBassManagementRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__enableBassManagementRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__enableBassManagementRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__enableBassManagementRequest);
		if (size)
			*size = sizeof(_ns3__enableBassManagementRequest);
		((_ns3__enableBassManagementRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__enableBassManagementRequest, n);
		if (size)
			*size = n * sizeof(_ns3__enableBassManagementRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__enableBassManagementRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__enableBassManagementRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__enableBassManagementRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__enableBassManagementRequest %p -> %p\n", q, p));
	*(_ns3__enableBassManagementRequest*)p = *(_ns3__enableBassManagementRequest*)q;
}

void _ns3__isBassManagementEnabledResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__isBassManagementEnabledResponse::enabled);
	/* transient soap skipped */
}

void _ns3__isBassManagementEnabledResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__isBassManagementEnabledResponse::enabled, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__isBassManagementEnabledResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isBassManagementEnabledResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isBassManagementEnabledResponse(struct soap *soap, const char *tag, int id, const _ns3__isBassManagementEnabledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isBassManagementEnabledResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "enabled", -1, &(a->_ns3__isBassManagementEnabledResponse::enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isBassManagementEnabledResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isBassManagementEnabledResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isBassManagementEnabledResponse * SOAP_FMAC4 soap_in__ns3__isBassManagementEnabledResponse(struct soap *soap, const char *tag, _ns3__isBassManagementEnabledResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isBassManagementEnabledResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isBassManagementEnabledResponse, sizeof(_ns3__isBassManagementEnabledResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isBassManagementEnabledResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isBassManagementEnabledResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enabled", &(a->_ns3__isBassManagementEnabledResponse::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isBassManagementEnabledResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isBassManagementEnabledResponse, 0, sizeof(_ns3__isBassManagementEnabledResponse), 0, soap_copy__ns3__isBassManagementEnabledResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__isBassManagementEnabledResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isBassManagementEnabledResponse);
	if (this->soap_out(soap, tag?tag:"ns3:isBassManagementEnabledResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isBassManagementEnabledResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isBassManagementEnabledResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isBassManagementEnabledResponse * SOAP_FMAC4 soap_get__ns3__isBassManagementEnabledResponse(struct soap *soap, _ns3__isBassManagementEnabledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isBassManagementEnabledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isBassManagementEnabledResponse * SOAP_FMAC2 soap_instantiate__ns3__isBassManagementEnabledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isBassManagementEnabledResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isBassManagementEnabledResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isBassManagementEnabledResponse);
		if (size)
			*size = sizeof(_ns3__isBassManagementEnabledResponse);
		((_ns3__isBassManagementEnabledResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isBassManagementEnabledResponse, n);
		if (size)
			*size = n * sizeof(_ns3__isBassManagementEnabledResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isBassManagementEnabledResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isBassManagementEnabledResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isBassManagementEnabledResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isBassManagementEnabledResponse %p -> %p\n", q, p));
	*(_ns3__isBassManagementEnabledResponse*)p = *(_ns3__isBassManagementEnabledResponse*)q;
}

void _ns3__isBassManagementEnabledRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__isBassManagementEnabledRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__isBassManagementEnabledRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isBassManagementEnabledRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isBassManagementEnabledRequest(struct soap *soap, const char *tag, int id, const _ns3__isBassManagementEnabledRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isBassManagementEnabledRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isBassManagementEnabledRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isBassManagementEnabledRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isBassManagementEnabledRequest * SOAP_FMAC4 soap_in__ns3__isBassManagementEnabledRequest(struct soap *soap, const char *tag, _ns3__isBassManagementEnabledRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isBassManagementEnabledRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isBassManagementEnabledRequest, sizeof(_ns3__isBassManagementEnabledRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isBassManagementEnabledRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isBassManagementEnabledRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isBassManagementEnabledRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isBassManagementEnabledRequest, 0, sizeof(_ns3__isBassManagementEnabledRequest), 0, soap_copy__ns3__isBassManagementEnabledRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__isBassManagementEnabledRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isBassManagementEnabledRequest);
	if (this->soap_out(soap, tag?tag:"ns3:isBassManagementEnabledRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isBassManagementEnabledRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isBassManagementEnabledRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isBassManagementEnabledRequest * SOAP_FMAC4 soap_get__ns3__isBassManagementEnabledRequest(struct soap *soap, _ns3__isBassManagementEnabledRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isBassManagementEnabledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isBassManagementEnabledRequest * SOAP_FMAC2 soap_instantiate__ns3__isBassManagementEnabledRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isBassManagementEnabledRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isBassManagementEnabledRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isBassManagementEnabledRequest);
		if (size)
			*size = sizeof(_ns3__isBassManagementEnabledRequest);
		((_ns3__isBassManagementEnabledRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isBassManagementEnabledRequest, n);
		if (size)
			*size = n * sizeof(_ns3__isBassManagementEnabledRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isBassManagementEnabledRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isBassManagementEnabledRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isBassManagementEnabledRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isBassManagementEnabledRequest %p -> %p\n", q, p));
	*(_ns3__isBassManagementEnabledRequest*)p = *(_ns3__isBassManagementEnabledRequest*)q;
}

void _ns3__setTestSignalModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setTestSignalModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setTestSignalModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setTestSignalModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setTestSignalModeResponse(struct soap *soap, const char *tag, int id, const _ns3__setTestSignalModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setTestSignalModeResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setTestSignalModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setTestSignalModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setTestSignalModeResponse * SOAP_FMAC4 soap_in__ns3__setTestSignalModeResponse(struct soap *soap, const char *tag, _ns3__setTestSignalModeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setTestSignalModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setTestSignalModeResponse, sizeof(_ns3__setTestSignalModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setTestSignalModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setTestSignalModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setTestSignalModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setTestSignalModeResponse, 0, sizeof(_ns3__setTestSignalModeResponse), 0, soap_copy__ns3__setTestSignalModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setTestSignalModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setTestSignalModeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setTestSignalModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setTestSignalModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setTestSignalModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setTestSignalModeResponse * SOAP_FMAC4 soap_get__ns3__setTestSignalModeResponse(struct soap *soap, _ns3__setTestSignalModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setTestSignalModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setTestSignalModeResponse * SOAP_FMAC2 soap_instantiate__ns3__setTestSignalModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setTestSignalModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setTestSignalModeResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setTestSignalModeResponse);
		if (size)
			*size = sizeof(_ns3__setTestSignalModeResponse);
		((_ns3__setTestSignalModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setTestSignalModeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setTestSignalModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setTestSignalModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setTestSignalModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setTestSignalModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setTestSignalModeResponse %p -> %p\n", q, p));
	*(_ns3__setTestSignalModeResponse*)p = *(_ns3__setTestSignalModeResponse*)q;
}

void _ns3__setTestSignalModeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__testSignalType(soap, &this->_ns3__setTestSignalModeRequest::signalType);
	/* transient soap skipped */
}

void _ns3__setTestSignalModeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setTestSignalModeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setTestSignalModeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setTestSignalModeRequest(struct soap *soap, const char *tag, int id, const _ns3__setTestSignalModeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setTestSignalModeRequest), type))
		return soap->error;
	if (soap_out_ns2__testSignalType(soap, "signalType", -1, &(a->_ns3__setTestSignalModeRequest::signalType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setTestSignalModeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setTestSignalModeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setTestSignalModeRequest * SOAP_FMAC4 soap_in__ns3__setTestSignalModeRequest(struct soap *soap, const char *tag, _ns3__setTestSignalModeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setTestSignalModeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setTestSignalModeRequest, sizeof(_ns3__setTestSignalModeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setTestSignalModeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setTestSignalModeRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_signalType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signalType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__testSignalType(soap, "signalType", &(a->_ns3__setTestSignalModeRequest::signalType), "ns2:testSignalType"))
				{	soap_flag_signalType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setTestSignalModeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setTestSignalModeRequest, 0, sizeof(_ns3__setTestSignalModeRequest), 0, soap_copy__ns3__setTestSignalModeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_signalType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setTestSignalModeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setTestSignalModeRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setTestSignalModeRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setTestSignalModeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setTestSignalModeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setTestSignalModeRequest * SOAP_FMAC4 soap_get__ns3__setTestSignalModeRequest(struct soap *soap, _ns3__setTestSignalModeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setTestSignalModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setTestSignalModeRequest * SOAP_FMAC2 soap_instantiate__ns3__setTestSignalModeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setTestSignalModeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setTestSignalModeRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setTestSignalModeRequest);
		if (size)
			*size = sizeof(_ns3__setTestSignalModeRequest);
		((_ns3__setTestSignalModeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setTestSignalModeRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setTestSignalModeRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setTestSignalModeRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setTestSignalModeRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setTestSignalModeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setTestSignalModeRequest %p -> %p\n", q, p));
	*(_ns3__setTestSignalModeRequest*)p = *(_ns3__setTestSignalModeRequest*)q;
}

void _ns3__getTestSignalModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__testSignalType(soap, &this->_ns3__getTestSignalModeResponse::signalType);
	/* transient soap skipped */
}

void _ns3__getTestSignalModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getTestSignalModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getTestSignalModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getTestSignalModeResponse(struct soap *soap, const char *tag, int id, const _ns3__getTestSignalModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getTestSignalModeResponse), type))
		return soap->error;
	if (soap_out_ns2__testSignalType(soap, "signalType", -1, &(a->_ns3__getTestSignalModeResponse::signalType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getTestSignalModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getTestSignalModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getTestSignalModeResponse * SOAP_FMAC4 soap_in__ns3__getTestSignalModeResponse(struct soap *soap, const char *tag, _ns3__getTestSignalModeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getTestSignalModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getTestSignalModeResponse, sizeof(_ns3__getTestSignalModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getTestSignalModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getTestSignalModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_signalType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signalType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__testSignalType(soap, "signalType", &(a->_ns3__getTestSignalModeResponse::signalType), "ns2:testSignalType"))
				{	soap_flag_signalType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getTestSignalModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getTestSignalModeResponse, 0, sizeof(_ns3__getTestSignalModeResponse), 0, soap_copy__ns3__getTestSignalModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_signalType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getTestSignalModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getTestSignalModeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getTestSignalModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getTestSignalModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getTestSignalModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getTestSignalModeResponse * SOAP_FMAC4 soap_get__ns3__getTestSignalModeResponse(struct soap *soap, _ns3__getTestSignalModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getTestSignalModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getTestSignalModeResponse * SOAP_FMAC2 soap_instantiate__ns3__getTestSignalModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getTestSignalModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getTestSignalModeResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getTestSignalModeResponse);
		if (size)
			*size = sizeof(_ns3__getTestSignalModeResponse);
		((_ns3__getTestSignalModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getTestSignalModeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getTestSignalModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getTestSignalModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getTestSignalModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getTestSignalModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getTestSignalModeResponse %p -> %p\n", q, p));
	*(_ns3__getTestSignalModeResponse*)p = *(_ns3__getTestSignalModeResponse*)q;
}

void _ns3__getTestSignalModeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getTestSignalModeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getTestSignalModeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getTestSignalModeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getTestSignalModeRequest(struct soap *soap, const char *tag, int id, const _ns3__getTestSignalModeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getTestSignalModeRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getTestSignalModeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getTestSignalModeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getTestSignalModeRequest * SOAP_FMAC4 soap_in__ns3__getTestSignalModeRequest(struct soap *soap, const char *tag, _ns3__getTestSignalModeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getTestSignalModeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getTestSignalModeRequest, sizeof(_ns3__getTestSignalModeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getTestSignalModeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getTestSignalModeRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getTestSignalModeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getTestSignalModeRequest, 0, sizeof(_ns3__getTestSignalModeRequest), 0, soap_copy__ns3__getTestSignalModeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getTestSignalModeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getTestSignalModeRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getTestSignalModeRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getTestSignalModeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getTestSignalModeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getTestSignalModeRequest * SOAP_FMAC4 soap_get__ns3__getTestSignalModeRequest(struct soap *soap, _ns3__getTestSignalModeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getTestSignalModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getTestSignalModeRequest * SOAP_FMAC2 soap_instantiate__ns3__getTestSignalModeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getTestSignalModeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getTestSignalModeRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getTestSignalModeRequest);
		if (size)
			*size = sizeof(_ns3__getTestSignalModeRequest);
		((_ns3__getTestSignalModeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getTestSignalModeRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getTestSignalModeRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getTestSignalModeRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getTestSignalModeRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getTestSignalModeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getTestSignalModeRequest %p -> %p\n", q, p));
	*(_ns3__getTestSignalModeRequest*)p = *(_ns3__getTestSignalModeRequest*)q;
}

void _ns3__setTestSignalOutputResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setTestSignalOutputResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setTestSignalOutputResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setTestSignalOutputResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setTestSignalOutputResponse(struct soap *soap, const char *tag, int id, const _ns3__setTestSignalOutputResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setTestSignalOutputResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setTestSignalOutputResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setTestSignalOutputResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setTestSignalOutputResponse * SOAP_FMAC4 soap_in__ns3__setTestSignalOutputResponse(struct soap *soap, const char *tag, _ns3__setTestSignalOutputResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setTestSignalOutputResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setTestSignalOutputResponse, sizeof(_ns3__setTestSignalOutputResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setTestSignalOutputResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setTestSignalOutputResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setTestSignalOutputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setTestSignalOutputResponse, 0, sizeof(_ns3__setTestSignalOutputResponse), 0, soap_copy__ns3__setTestSignalOutputResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setTestSignalOutputResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setTestSignalOutputResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setTestSignalOutputResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setTestSignalOutputResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setTestSignalOutputResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setTestSignalOutputResponse * SOAP_FMAC4 soap_get__ns3__setTestSignalOutputResponse(struct soap *soap, _ns3__setTestSignalOutputResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setTestSignalOutputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setTestSignalOutputResponse * SOAP_FMAC2 soap_instantiate__ns3__setTestSignalOutputResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setTestSignalOutputResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setTestSignalOutputResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setTestSignalOutputResponse);
		if (size)
			*size = sizeof(_ns3__setTestSignalOutputResponse);
		((_ns3__setTestSignalOutputResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setTestSignalOutputResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setTestSignalOutputResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setTestSignalOutputResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setTestSignalOutputResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setTestSignalOutputResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setTestSignalOutputResponse %p -> %p\n", q, p));
	*(_ns3__setTestSignalOutputResponse*)p = *(_ns3__setTestSignalOutputResponse*)q;
}

void _ns3__setTestSignalOutputRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__testSignalOutputMode(soap, &this->_ns3__setTestSignalOutputRequest::outputMode);
	soap_default_std__vectorTemplateOfxsd__integer(soap, &this->_ns3__setTestSignalOutputRequest::speakerIndex);
	this->_ns3__setTestSignalOutputRequest::array = NULL;
	this->_ns3__setTestSignalOutputRequest::objectPath = NULL;
	/* transient soap skipped */
}

void _ns3__setTestSignalOutputRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__integer(soap, &this->_ns3__setTestSignalOutputRequest::speakerIndex);
	soap_serialize_PointerTons2__bedChannelId(soap, &this->_ns3__setTestSignalOutputRequest::array);
	soap_serialize_PointerTons2__testSignalObjectPath(soap, &this->_ns3__setTestSignalOutputRequest::objectPath);
	/* transient soap skipped */
#endif
}

int _ns3__setTestSignalOutputRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setTestSignalOutputRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setTestSignalOutputRequest(struct soap *soap, const char *tag, int id, const _ns3__setTestSignalOutputRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setTestSignalOutputRequest), type))
		return soap->error;
	if (soap_out_ns2__testSignalOutputMode(soap, "outputMode", -1, &(a->_ns3__setTestSignalOutputRequest::outputMode), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__integer(soap, "speakerIndex", -1, &(a->_ns3__setTestSignalOutputRequest::speakerIndex), ""))
		return soap->error;
	if (soap_out_PointerTons2__bedChannelId(soap, "array", -1, &(a->_ns3__setTestSignalOutputRequest::array), ""))
		return soap->error;
	if (soap_out_PointerTons2__testSignalObjectPath(soap, "objectPath", -1, &(a->_ns3__setTestSignalOutputRequest::objectPath), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setTestSignalOutputRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setTestSignalOutputRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setTestSignalOutputRequest * SOAP_FMAC4 soap_in__ns3__setTestSignalOutputRequest(struct soap *soap, const char *tag, _ns3__setTestSignalOutputRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setTestSignalOutputRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setTestSignalOutputRequest, sizeof(_ns3__setTestSignalOutputRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setTestSignalOutputRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setTestSignalOutputRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_outputMode1 = 1;
	size_t soap_flag_array1 = 1;
	size_t soap_flag_objectPath1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outputMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__testSignalOutputMode(soap, "outputMode", &(a->_ns3__setTestSignalOutputRequest::outputMode), "ns2:testSignalOutputMode"))
				{	soap_flag_outputMode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__integer(soap, "speakerIndex", &(a->_ns3__setTestSignalOutputRequest::speakerIndex), "xsd:integer"))
					continue;
			if (soap_flag_array1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__bedChannelId(soap, "array", &(a->_ns3__setTestSignalOutputRequest::array), "ns2:bedChannelId"))
				{	soap_flag_array1--;
					continue;
				}
			if (soap_flag_objectPath1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__testSignalObjectPath(soap, "objectPath", &(a->_ns3__setTestSignalOutputRequest::objectPath), "ns2:testSignalObjectPath"))
				{	soap_flag_objectPath1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setTestSignalOutputRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setTestSignalOutputRequest, 0, sizeof(_ns3__setTestSignalOutputRequest), 0, soap_copy__ns3__setTestSignalOutputRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_outputMode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setTestSignalOutputRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setTestSignalOutputRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setTestSignalOutputRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setTestSignalOutputRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setTestSignalOutputRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setTestSignalOutputRequest * SOAP_FMAC4 soap_get__ns3__setTestSignalOutputRequest(struct soap *soap, _ns3__setTestSignalOutputRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setTestSignalOutputRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setTestSignalOutputRequest * SOAP_FMAC2 soap_instantiate__ns3__setTestSignalOutputRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setTestSignalOutputRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setTestSignalOutputRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setTestSignalOutputRequest);
		if (size)
			*size = sizeof(_ns3__setTestSignalOutputRequest);
		((_ns3__setTestSignalOutputRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setTestSignalOutputRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setTestSignalOutputRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setTestSignalOutputRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setTestSignalOutputRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setTestSignalOutputRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setTestSignalOutputRequest %p -> %p\n", q, p));
	*(_ns3__setTestSignalOutputRequest*)p = *(_ns3__setTestSignalOutputRequest*)q;
}

void _ns3__getTestSignalOutputResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__testSignalOutputMode(soap, &this->_ns3__getTestSignalOutputResponse::outputMode);
	soap_default_std__vectorTemplateOfxsd__integer(soap, &this->_ns3__getTestSignalOutputResponse::speakerIndex);
	this->_ns3__getTestSignalOutputResponse::array = NULL;
	this->_ns3__getTestSignalOutputResponse::objectPath = NULL;
	/* transient soap skipped */
}

void _ns3__getTestSignalOutputResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__integer(soap, &this->_ns3__getTestSignalOutputResponse::speakerIndex);
	soap_serialize_PointerTons2__bedChannelId(soap, &this->_ns3__getTestSignalOutputResponse::array);
	soap_serialize_PointerTons2__testSignalObjectPath(soap, &this->_ns3__getTestSignalOutputResponse::objectPath);
	/* transient soap skipped */
#endif
}

int _ns3__getTestSignalOutputResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getTestSignalOutputResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getTestSignalOutputResponse(struct soap *soap, const char *tag, int id, const _ns3__getTestSignalOutputResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getTestSignalOutputResponse), type))
		return soap->error;
	if (soap_out_ns2__testSignalOutputMode(soap, "outputMode", -1, &(a->_ns3__getTestSignalOutputResponse::outputMode), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__integer(soap, "speakerIndex", -1, &(a->_ns3__getTestSignalOutputResponse::speakerIndex), ""))
		return soap->error;
	if (soap_out_PointerTons2__bedChannelId(soap, "array", -1, &(a->_ns3__getTestSignalOutputResponse::array), ""))
		return soap->error;
	if (soap_out_PointerTons2__testSignalObjectPath(soap, "objectPath", -1, &(a->_ns3__getTestSignalOutputResponse::objectPath), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getTestSignalOutputResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getTestSignalOutputResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getTestSignalOutputResponse * SOAP_FMAC4 soap_in__ns3__getTestSignalOutputResponse(struct soap *soap, const char *tag, _ns3__getTestSignalOutputResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getTestSignalOutputResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getTestSignalOutputResponse, sizeof(_ns3__getTestSignalOutputResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getTestSignalOutputResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getTestSignalOutputResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_outputMode1 = 1;
	size_t soap_flag_array1 = 1;
	size_t soap_flag_objectPath1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outputMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__testSignalOutputMode(soap, "outputMode", &(a->_ns3__getTestSignalOutputResponse::outputMode), "ns2:testSignalOutputMode"))
				{	soap_flag_outputMode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__integer(soap, "speakerIndex", &(a->_ns3__getTestSignalOutputResponse::speakerIndex), "xsd:integer"))
					continue;
			if (soap_flag_array1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__bedChannelId(soap, "array", &(a->_ns3__getTestSignalOutputResponse::array), "ns2:bedChannelId"))
				{	soap_flag_array1--;
					continue;
				}
			if (soap_flag_objectPath1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__testSignalObjectPath(soap, "objectPath", &(a->_ns3__getTestSignalOutputResponse::objectPath), "ns2:testSignalObjectPath"))
				{	soap_flag_objectPath1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getTestSignalOutputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getTestSignalOutputResponse, 0, sizeof(_ns3__getTestSignalOutputResponse), 0, soap_copy__ns3__getTestSignalOutputResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_outputMode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getTestSignalOutputResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getTestSignalOutputResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getTestSignalOutputResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getTestSignalOutputResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getTestSignalOutputResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getTestSignalOutputResponse * SOAP_FMAC4 soap_get__ns3__getTestSignalOutputResponse(struct soap *soap, _ns3__getTestSignalOutputResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getTestSignalOutputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getTestSignalOutputResponse * SOAP_FMAC2 soap_instantiate__ns3__getTestSignalOutputResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getTestSignalOutputResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getTestSignalOutputResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getTestSignalOutputResponse);
		if (size)
			*size = sizeof(_ns3__getTestSignalOutputResponse);
		((_ns3__getTestSignalOutputResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getTestSignalOutputResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getTestSignalOutputResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getTestSignalOutputResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getTestSignalOutputResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getTestSignalOutputResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getTestSignalOutputResponse %p -> %p\n", q, p));
	*(_ns3__getTestSignalOutputResponse*)p = *(_ns3__getTestSignalOutputResponse*)q;
}

void _ns3__getTestSignalOutputRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getTestSignalOutputRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getTestSignalOutputRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getTestSignalOutputRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getTestSignalOutputRequest(struct soap *soap, const char *tag, int id, const _ns3__getTestSignalOutputRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getTestSignalOutputRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getTestSignalOutputRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getTestSignalOutputRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getTestSignalOutputRequest * SOAP_FMAC4 soap_in__ns3__getTestSignalOutputRequest(struct soap *soap, const char *tag, _ns3__getTestSignalOutputRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getTestSignalOutputRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getTestSignalOutputRequest, sizeof(_ns3__getTestSignalOutputRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getTestSignalOutputRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getTestSignalOutputRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getTestSignalOutputRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getTestSignalOutputRequest, 0, sizeof(_ns3__getTestSignalOutputRequest), 0, soap_copy__ns3__getTestSignalOutputRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getTestSignalOutputRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getTestSignalOutputRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getTestSignalOutputRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getTestSignalOutputRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getTestSignalOutputRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getTestSignalOutputRequest * SOAP_FMAC4 soap_get__ns3__getTestSignalOutputRequest(struct soap *soap, _ns3__getTestSignalOutputRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getTestSignalOutputRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getTestSignalOutputRequest * SOAP_FMAC2 soap_instantiate__ns3__getTestSignalOutputRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getTestSignalOutputRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getTestSignalOutputRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getTestSignalOutputRequest);
		if (size)
			*size = sizeof(_ns3__getTestSignalOutputRequest);
		((_ns3__getTestSignalOutputRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getTestSignalOutputRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getTestSignalOutputRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getTestSignalOutputRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getTestSignalOutputRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getTestSignalOutputRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getTestSignalOutputRequest %p -> %p\n", q, p));
	*(_ns3__getTestSignalOutputRequest*)p = *(_ns3__getTestSignalOutputRequest*)q;
}

void _ns3__getAtmosConfigInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__getAtmosConfigInfoResponse::uuid);
	soap_default_std__string(soap, &this->_ns3__getAtmosConfigInfoResponse::name);
	soap_default_time(soap, &this->_ns3__getAtmosConfigInfoResponse::lastModifiedDateTime);
	this->_ns3__getAtmosConfigInfoResponse::status = NULL;
	this->_ns3__getAtmosConfigInfoResponse::errorType = NULL;
	this->_ns3__getAtmosConfigInfoResponse::errorMessage = NULL;
	/* transient soap skipped */
}

void _ns3__getAtmosConfigInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__getAtmosConfigInfoResponse::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns3__getAtmosConfigInfoResponse::uuid);
	soap_embedded(soap, &this->_ns3__getAtmosConfigInfoResponse::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns3__getAtmosConfigInfoResponse::name);
	soap_serialize_PointerTons2__lastAtmosConfigPushStatus(soap, &this->_ns3__getAtmosConfigInfoResponse::status);
	soap_serialize_PointerTons2__lastAtmosConfigPushErrorType(soap, &this->_ns3__getAtmosConfigInfoResponse::errorType);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__getAtmosConfigInfoResponse::errorMessage);
	/* transient soap skipped */
#endif
}

int _ns3__getAtmosConfigInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getAtmosConfigInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getAtmosConfigInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__getAtmosConfigInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getAtmosConfigInfoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->_ns3__getAtmosConfigInfoResponse::uuid), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->_ns3__getAtmosConfigInfoResponse::name), ""))
		return soap->error;
	if (soap_out_time(soap, "lastModifiedDateTime", -1, &(a->_ns3__getAtmosConfigInfoResponse::lastModifiedDateTime), ""))
		return soap->error;
	if (soap_out_PointerTons2__lastAtmosConfigPushStatus(soap, "status", -1, &(a->_ns3__getAtmosConfigInfoResponse::status), ""))
		return soap->error;
	if (soap_out_PointerTons2__lastAtmosConfigPushErrorType(soap, "errorType", -1, &(a->_ns3__getAtmosConfigInfoResponse::errorType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "errorMessage", -1, &(a->_ns3__getAtmosConfigInfoResponse::errorMessage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getAtmosConfigInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getAtmosConfigInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigInfoResponse * SOAP_FMAC4 soap_in__ns3__getAtmosConfigInfoResponse(struct soap *soap, const char *tag, _ns3__getAtmosConfigInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getAtmosConfigInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getAtmosConfigInfoResponse, sizeof(_ns3__getAtmosConfigInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getAtmosConfigInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getAtmosConfigInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_lastModifiedDateTime1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_errorType1 = 1;
	size_t soap_flag_errorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->_ns3__getAtmosConfigInfoResponse::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->_ns3__getAtmosConfigInfoResponse::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_lastModifiedDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "lastModifiedDateTime", &(a->_ns3__getAtmosConfigInfoResponse::lastModifiedDateTime), "xsd:dateTime"))
				{	soap_flag_lastModifiedDateTime1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__lastAtmosConfigPushStatus(soap, "status", &(a->_ns3__getAtmosConfigInfoResponse::status), "ns2:lastAtmosConfigPushStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_errorType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__lastAtmosConfigPushErrorType(soap, "errorType", &(a->_ns3__getAtmosConfigInfoResponse::errorType), "ns2:lastAtmosConfigPushErrorType"))
				{	soap_flag_errorType1--;
					continue;
				}
			if (soap_flag_errorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "errorMessage", &(a->_ns3__getAtmosConfigInfoResponse::errorMessage), "xsd:string"))
				{	soap_flag_errorMessage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getAtmosConfigInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getAtmosConfigInfoResponse, 0, sizeof(_ns3__getAtmosConfigInfoResponse), 0, soap_copy__ns3__getAtmosConfigInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_name1 > 0 || soap_flag_lastModifiedDateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getAtmosConfigInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getAtmosConfigInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getAtmosConfigInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getAtmosConfigInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getAtmosConfigInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigInfoResponse * SOAP_FMAC4 soap_get__ns3__getAtmosConfigInfoResponse(struct soap *soap, _ns3__getAtmosConfigInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getAtmosConfigInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getAtmosConfigInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__getAtmosConfigInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getAtmosConfigInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getAtmosConfigInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getAtmosConfigInfoResponse);
		if (size)
			*size = sizeof(_ns3__getAtmosConfigInfoResponse);
		((_ns3__getAtmosConfigInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getAtmosConfigInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getAtmosConfigInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getAtmosConfigInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getAtmosConfigInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getAtmosConfigInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getAtmosConfigInfoResponse %p -> %p\n", q, p));
	*(_ns3__getAtmosConfigInfoResponse*)p = *(_ns3__getAtmosConfigInfoResponse*)q;
}

void _ns3__getAtmosConfigInfoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getAtmosConfigInfoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getAtmosConfigInfoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getAtmosConfigInfoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getAtmosConfigInfoRequest(struct soap *soap, const char *tag, int id, const _ns3__getAtmosConfigInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getAtmosConfigInfoRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getAtmosConfigInfoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getAtmosConfigInfoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigInfoRequest * SOAP_FMAC4 soap_in__ns3__getAtmosConfigInfoRequest(struct soap *soap, const char *tag, _ns3__getAtmosConfigInfoRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getAtmosConfigInfoRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getAtmosConfigInfoRequest, sizeof(_ns3__getAtmosConfigInfoRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getAtmosConfigInfoRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getAtmosConfigInfoRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getAtmosConfigInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getAtmosConfigInfoRequest, 0, sizeof(_ns3__getAtmosConfigInfoRequest), 0, soap_copy__ns3__getAtmosConfigInfoRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getAtmosConfigInfoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getAtmosConfigInfoRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getAtmosConfigInfoRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getAtmosConfigInfoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getAtmosConfigInfoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigInfoRequest * SOAP_FMAC4 soap_get__ns3__getAtmosConfigInfoRequest(struct soap *soap, _ns3__getAtmosConfigInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getAtmosConfigInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getAtmosConfigInfoRequest * SOAP_FMAC2 soap_instantiate__ns3__getAtmosConfigInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getAtmosConfigInfoRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getAtmosConfigInfoRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getAtmosConfigInfoRequest);
		if (size)
			*size = sizeof(_ns3__getAtmosConfigInfoRequest);
		((_ns3__getAtmosConfigInfoRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getAtmosConfigInfoRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getAtmosConfigInfoRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getAtmosConfigInfoRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getAtmosConfigInfoRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getAtmosConfigInfoRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getAtmosConfigInfoRequest %p -> %p\n", q, p));
	*(_ns3__getAtmosConfigInfoRequest*)p = *(_ns3__getAtmosConfigInfoRequest*)q;
}

void _ns3__setAtmosConfigResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setAtmosConfigResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setAtmosConfigResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setAtmosConfigResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setAtmosConfigResponse(struct soap *soap, const char *tag, int id, const _ns3__setAtmosConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setAtmosConfigResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setAtmosConfigResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setAtmosConfigResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setAtmosConfigResponse * SOAP_FMAC4 soap_in__ns3__setAtmosConfigResponse(struct soap *soap, const char *tag, _ns3__setAtmosConfigResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setAtmosConfigResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setAtmosConfigResponse, sizeof(_ns3__setAtmosConfigResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setAtmosConfigResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setAtmosConfigResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setAtmosConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setAtmosConfigResponse, 0, sizeof(_ns3__setAtmosConfigResponse), 0, soap_copy__ns3__setAtmosConfigResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setAtmosConfigResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setAtmosConfigResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setAtmosConfigResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setAtmosConfigResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setAtmosConfigResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setAtmosConfigResponse * SOAP_FMAC4 soap_get__ns3__setAtmosConfigResponse(struct soap *soap, _ns3__setAtmosConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setAtmosConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setAtmosConfigResponse * SOAP_FMAC2 soap_instantiate__ns3__setAtmosConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setAtmosConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setAtmosConfigResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setAtmosConfigResponse);
		if (size)
			*size = sizeof(_ns3__setAtmosConfigResponse);
		((_ns3__setAtmosConfigResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setAtmosConfigResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setAtmosConfigResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setAtmosConfigResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setAtmosConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setAtmosConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setAtmosConfigResponse %p -> %p\n", q, p));
	*(_ns3__setAtmosConfigResponse*)p = *(_ns3__setAtmosConfigResponse*)q;
}

void _ns3__setAtmosConfigRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__setAtmosConfigRequest::name);
	soap_default_std__string(soap, &this->_ns3__setAtmosConfigRequest::config);
	/* transient soap skipped */
}

void _ns3__setAtmosConfigRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__setAtmosConfigRequest::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns3__setAtmosConfigRequest::name);
	soap_embedded(soap, &this->_ns3__setAtmosConfigRequest::config, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns3__setAtmosConfigRequest::config);
	/* transient soap skipped */
#endif
}

int _ns3__setAtmosConfigRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setAtmosConfigRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setAtmosConfigRequest(struct soap *soap, const char *tag, int id, const _ns3__setAtmosConfigRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setAtmosConfigRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->_ns3__setAtmosConfigRequest::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "config", -1, &(a->_ns3__setAtmosConfigRequest::config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setAtmosConfigRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setAtmosConfigRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setAtmosConfigRequest * SOAP_FMAC4 soap_in__ns3__setAtmosConfigRequest(struct soap *soap, const char *tag, _ns3__setAtmosConfigRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setAtmosConfigRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setAtmosConfigRequest, sizeof(_ns3__setAtmosConfigRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setAtmosConfigRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setAtmosConfigRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->_ns3__setAtmosConfigRequest::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_config1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "config", &(a->_ns3__setAtmosConfigRequest::config), "xsd:string"))
				{	soap_flag_config1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setAtmosConfigRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setAtmosConfigRequest, 0, sizeof(_ns3__setAtmosConfigRequest), 0, soap_copy__ns3__setAtmosConfigRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_config1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setAtmosConfigRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setAtmosConfigRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setAtmosConfigRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setAtmosConfigRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setAtmosConfigRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setAtmosConfigRequest * SOAP_FMAC4 soap_get__ns3__setAtmosConfigRequest(struct soap *soap, _ns3__setAtmosConfigRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setAtmosConfigRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setAtmosConfigRequest * SOAP_FMAC2 soap_instantiate__ns3__setAtmosConfigRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setAtmosConfigRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setAtmosConfigRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setAtmosConfigRequest);
		if (size)
			*size = sizeof(_ns3__setAtmosConfigRequest);
		((_ns3__setAtmosConfigRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setAtmosConfigRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setAtmosConfigRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setAtmosConfigRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setAtmosConfigRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setAtmosConfigRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setAtmosConfigRequest %p -> %p\n", q, p));
	*(_ns3__setAtmosConfigRequest*)p = *(_ns3__setAtmosConfigRequest*)q;
}

void _ns3__getAtmosConfigResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__getAtmosConfigResponse::name);
	soap_default_std__string(soap, &this->_ns3__getAtmosConfigResponse::config);
	/* transient soap skipped */
}

void _ns3__getAtmosConfigResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__getAtmosConfigResponse::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns3__getAtmosConfigResponse::name);
	soap_embedded(soap, &this->_ns3__getAtmosConfigResponse::config, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns3__getAtmosConfigResponse::config);
	/* transient soap skipped */
#endif
}

int _ns3__getAtmosConfigResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getAtmosConfigResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getAtmosConfigResponse(struct soap *soap, const char *tag, int id, const _ns3__getAtmosConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getAtmosConfigResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->_ns3__getAtmosConfigResponse::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "config", -1, &(a->_ns3__getAtmosConfigResponse::config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getAtmosConfigResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getAtmosConfigResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigResponse * SOAP_FMAC4 soap_in__ns3__getAtmosConfigResponse(struct soap *soap, const char *tag, _ns3__getAtmosConfigResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getAtmosConfigResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getAtmosConfigResponse, sizeof(_ns3__getAtmosConfigResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getAtmosConfigResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getAtmosConfigResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->_ns3__getAtmosConfigResponse::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_config1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "config", &(a->_ns3__getAtmosConfigResponse::config), "xsd:string"))
				{	soap_flag_config1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getAtmosConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getAtmosConfigResponse, 0, sizeof(_ns3__getAtmosConfigResponse), 0, soap_copy__ns3__getAtmosConfigResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_config1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getAtmosConfigResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getAtmosConfigResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getAtmosConfigResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getAtmosConfigResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getAtmosConfigResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigResponse * SOAP_FMAC4 soap_get__ns3__getAtmosConfigResponse(struct soap *soap, _ns3__getAtmosConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getAtmosConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getAtmosConfigResponse * SOAP_FMAC2 soap_instantiate__ns3__getAtmosConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getAtmosConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getAtmosConfigResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getAtmosConfigResponse);
		if (size)
			*size = sizeof(_ns3__getAtmosConfigResponse);
		((_ns3__getAtmosConfigResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getAtmosConfigResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getAtmosConfigResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getAtmosConfigResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getAtmosConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getAtmosConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getAtmosConfigResponse %p -> %p\n", q, p));
	*(_ns3__getAtmosConfigResponse*)p = *(_ns3__getAtmosConfigResponse*)q;
}

void _ns3__getAtmosConfigRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getAtmosConfigRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getAtmosConfigRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getAtmosConfigRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getAtmosConfigRequest(struct soap *soap, const char *tag, int id, const _ns3__getAtmosConfigRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getAtmosConfigRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getAtmosConfigRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getAtmosConfigRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigRequest * SOAP_FMAC4 soap_in__ns3__getAtmosConfigRequest(struct soap *soap, const char *tag, _ns3__getAtmosConfigRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getAtmosConfigRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getAtmosConfigRequest, sizeof(_ns3__getAtmosConfigRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getAtmosConfigRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getAtmosConfigRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getAtmosConfigRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getAtmosConfigRequest, 0, sizeof(_ns3__getAtmosConfigRequest), 0, soap_copy__ns3__getAtmosConfigRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getAtmosConfigRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getAtmosConfigRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getAtmosConfigRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getAtmosConfigRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getAtmosConfigRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigRequest * SOAP_FMAC4 soap_get__ns3__getAtmosConfigRequest(struct soap *soap, _ns3__getAtmosConfigRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getAtmosConfigRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getAtmosConfigRequest * SOAP_FMAC2 soap_instantiate__ns3__getAtmosConfigRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getAtmosConfigRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getAtmosConfigRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getAtmosConfigRequest);
		if (size)
			*size = sizeof(_ns3__getAtmosConfigRequest);
		((_ns3__getAtmosConfigRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getAtmosConfigRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getAtmosConfigRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getAtmosConfigRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getAtmosConfigRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getAtmosConfigRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getAtmosConfigRequest %p -> %p\n", q, p));
	*(_ns3__getAtmosConfigRequest*)p = *(_ns3__getAtmosConfigRequest*)q;
}

void _ns3__getAudioStreamInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__getAudioStreamInfoResponse::info = NULL;
	/* transient soap skipped */
}

void _ns3__getAudioStreamInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__audioStreamInfo(soap, &this->_ns3__getAudioStreamInfoResponse::info);
	/* transient soap skipped */
#endif
}

int _ns3__getAudioStreamInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getAudioStreamInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getAudioStreamInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__getAudioStreamInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getAudioStreamInfoResponse), type))
		return soap->error;
	if (a->_ns3__getAudioStreamInfoResponse::info)
	{	if (soap_out_PointerTons2__audioStreamInfo(soap, "info", -1, &a->_ns3__getAudioStreamInfoResponse::info, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getAudioStreamInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getAudioStreamInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getAudioStreamInfoResponse * SOAP_FMAC4 soap_in__ns3__getAudioStreamInfoResponse(struct soap *soap, const char *tag, _ns3__getAudioStreamInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getAudioStreamInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getAudioStreamInfoResponse, sizeof(_ns3__getAudioStreamInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getAudioStreamInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getAudioStreamInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_info1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__audioStreamInfo(soap, "info", &(a->_ns3__getAudioStreamInfoResponse::info), "ns2:audioStreamInfo"))
				{	soap_flag_info1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getAudioStreamInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getAudioStreamInfoResponse, 0, sizeof(_ns3__getAudioStreamInfoResponse), 0, soap_copy__ns3__getAudioStreamInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getAudioStreamInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getAudioStreamInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getAudioStreamInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getAudioStreamInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getAudioStreamInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getAudioStreamInfoResponse * SOAP_FMAC4 soap_get__ns3__getAudioStreamInfoResponse(struct soap *soap, _ns3__getAudioStreamInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getAudioStreamInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getAudioStreamInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__getAudioStreamInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getAudioStreamInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getAudioStreamInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getAudioStreamInfoResponse);
		if (size)
			*size = sizeof(_ns3__getAudioStreamInfoResponse);
		((_ns3__getAudioStreamInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getAudioStreamInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getAudioStreamInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getAudioStreamInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getAudioStreamInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getAudioStreamInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getAudioStreamInfoResponse %p -> %p\n", q, p));
	*(_ns3__getAudioStreamInfoResponse*)p = *(_ns3__getAudioStreamInfoResponse*)q;
}

void _ns3__getAudioStreamInfoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getAudioStreamInfoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getAudioStreamInfoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getAudioStreamInfoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getAudioStreamInfoRequest(struct soap *soap, const char *tag, int id, const _ns3__getAudioStreamInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getAudioStreamInfoRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getAudioStreamInfoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getAudioStreamInfoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getAudioStreamInfoRequest * SOAP_FMAC4 soap_in__ns3__getAudioStreamInfoRequest(struct soap *soap, const char *tag, _ns3__getAudioStreamInfoRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getAudioStreamInfoRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getAudioStreamInfoRequest, sizeof(_ns3__getAudioStreamInfoRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getAudioStreamInfoRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getAudioStreamInfoRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getAudioStreamInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getAudioStreamInfoRequest, 0, sizeof(_ns3__getAudioStreamInfoRequest), 0, soap_copy__ns3__getAudioStreamInfoRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getAudioStreamInfoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getAudioStreamInfoRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getAudioStreamInfoRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getAudioStreamInfoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getAudioStreamInfoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getAudioStreamInfoRequest * SOAP_FMAC4 soap_get__ns3__getAudioStreamInfoRequest(struct soap *soap, _ns3__getAudioStreamInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getAudioStreamInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getAudioStreamInfoRequest * SOAP_FMAC2 soap_instantiate__ns3__getAudioStreamInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getAudioStreamInfoRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getAudioStreamInfoRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getAudioStreamInfoRequest);
		if (size)
			*size = sizeof(_ns3__getAudioStreamInfoRequest);
		((_ns3__getAudioStreamInfoRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getAudioStreamInfoRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getAudioStreamInfoRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getAudioStreamInfoRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getAudioStreamInfoRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getAudioStreamInfoRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getAudioStreamInfoRequest %p -> %p\n", q, p));
	*(_ns3__getAudioStreamInfoRequest*)p = *(_ns3__getAudioStreamInfoRequest*)q;
}

void _ns3__isAtmosContentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__atmosContentStatus(soap, &this->_ns3__isAtmosContentResponse::status);
	/* transient soap skipped */
}

void _ns3__isAtmosContentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__isAtmosContentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isAtmosContentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isAtmosContentResponse(struct soap *soap, const char *tag, int id, const _ns3__isAtmosContentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isAtmosContentResponse), type))
		return soap->error;
	if (soap_out_ns2__atmosContentStatus(soap, "status", -1, &(a->_ns3__isAtmosContentResponse::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isAtmosContentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isAtmosContentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isAtmosContentResponse * SOAP_FMAC4 soap_in__ns3__isAtmosContentResponse(struct soap *soap, const char *tag, _ns3__isAtmosContentResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isAtmosContentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isAtmosContentResponse, sizeof(_ns3__isAtmosContentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isAtmosContentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isAtmosContentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__atmosContentStatus(soap, "status", &(a->_ns3__isAtmosContentResponse::status), "ns2:atmosContentStatus"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isAtmosContentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isAtmosContentResponse, 0, sizeof(_ns3__isAtmosContentResponse), 0, soap_copy__ns3__isAtmosContentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__isAtmosContentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isAtmosContentResponse);
	if (this->soap_out(soap, tag?tag:"ns3:isAtmosContentResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isAtmosContentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isAtmosContentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isAtmosContentResponse * SOAP_FMAC4 soap_get__ns3__isAtmosContentResponse(struct soap *soap, _ns3__isAtmosContentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isAtmosContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isAtmosContentResponse * SOAP_FMAC2 soap_instantiate__ns3__isAtmosContentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isAtmosContentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isAtmosContentResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isAtmosContentResponse);
		if (size)
			*size = sizeof(_ns3__isAtmosContentResponse);
		((_ns3__isAtmosContentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isAtmosContentResponse, n);
		if (size)
			*size = n * sizeof(_ns3__isAtmosContentResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isAtmosContentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isAtmosContentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isAtmosContentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isAtmosContentResponse %p -> %p\n", q, p));
	*(_ns3__isAtmosContentResponse*)p = *(_ns3__isAtmosContentResponse*)q;
}

void _ns3__isAtmosContentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__isAtmosContentRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__isAtmosContentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__isAtmosContentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__isAtmosContentRequest(struct soap *soap, const char *tag, int id, const _ns3__isAtmosContentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__isAtmosContentRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__isAtmosContentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__isAtmosContentRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__isAtmosContentRequest * SOAP_FMAC4 soap_in__ns3__isAtmosContentRequest(struct soap *soap, const char *tag, _ns3__isAtmosContentRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__isAtmosContentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__isAtmosContentRequest, sizeof(_ns3__isAtmosContentRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__isAtmosContentRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__isAtmosContentRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__isAtmosContentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__isAtmosContentRequest, 0, sizeof(_ns3__isAtmosContentRequest), 0, soap_copy__ns3__isAtmosContentRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__isAtmosContentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__isAtmosContentRequest);
	if (this->soap_out(soap, tag?tag:"ns3:isAtmosContentRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__isAtmosContentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__isAtmosContentRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__isAtmosContentRequest * SOAP_FMAC4 soap_get__ns3__isAtmosContentRequest(struct soap *soap, _ns3__isAtmosContentRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__isAtmosContentRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__isAtmosContentRequest * SOAP_FMAC2 soap_instantiate__ns3__isAtmosContentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__isAtmosContentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__isAtmosContentRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__isAtmosContentRequest);
		if (size)
			*size = sizeof(_ns3__isAtmosContentRequest);
		((_ns3__isAtmosContentRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__isAtmosContentRequest, n);
		if (size)
			*size = n * sizeof(_ns3__isAtmosContentRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__isAtmosContentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__isAtmosContentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__isAtmosContentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__isAtmosContentRequest %p -> %p\n", q, p));
	*(_ns3__isAtmosContentRequest*)p = *(_ns3__isAtmosContentRequest*)q;
}

void _ns3__setMuteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setMuteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setMuteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setMuteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setMuteResponse(struct soap *soap, const char *tag, int id, const _ns3__setMuteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setMuteResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setMuteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setMuteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setMuteResponse * SOAP_FMAC4 soap_in__ns3__setMuteResponse(struct soap *soap, const char *tag, _ns3__setMuteResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setMuteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setMuteResponse, sizeof(_ns3__setMuteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setMuteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setMuteResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setMuteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setMuteResponse, 0, sizeof(_ns3__setMuteResponse), 0, soap_copy__ns3__setMuteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setMuteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setMuteResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setMuteResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setMuteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setMuteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setMuteResponse * SOAP_FMAC4 soap_get__ns3__setMuteResponse(struct soap *soap, _ns3__setMuteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setMuteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setMuteResponse * SOAP_FMAC2 soap_instantiate__ns3__setMuteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setMuteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setMuteResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setMuteResponse);
		if (size)
			*size = sizeof(_ns3__setMuteResponse);
		((_ns3__setMuteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setMuteResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setMuteResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setMuteResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setMuteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setMuteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setMuteResponse %p -> %p\n", q, p));
	*(_ns3__setMuteResponse*)p = *(_ns3__setMuteResponse*)q;
}

void _ns3__setMuteRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__setMuteRequest::shouldBeMuted);
	/* transient soap skipped */
}

void _ns3__setMuteRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__setMuteRequest::shouldBeMuted, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__setMuteRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setMuteRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setMuteRequest(struct soap *soap, const char *tag, int id, const _ns3__setMuteRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setMuteRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "shouldBeMuted", -1, &(a->_ns3__setMuteRequest::shouldBeMuted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setMuteRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setMuteRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setMuteRequest * SOAP_FMAC4 soap_in__ns3__setMuteRequest(struct soap *soap, const char *tag, _ns3__setMuteRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setMuteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setMuteRequest, sizeof(_ns3__setMuteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setMuteRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setMuteRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_shouldBeMuted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_shouldBeMuted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "shouldBeMuted", &(a->_ns3__setMuteRequest::shouldBeMuted), "xsd:boolean"))
				{	soap_flag_shouldBeMuted1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setMuteRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setMuteRequest, 0, sizeof(_ns3__setMuteRequest), 0, soap_copy__ns3__setMuteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shouldBeMuted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setMuteRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setMuteRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setMuteRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setMuteRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setMuteRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setMuteRequest * SOAP_FMAC4 soap_get__ns3__setMuteRequest(struct soap *soap, _ns3__setMuteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setMuteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setMuteRequest * SOAP_FMAC2 soap_instantiate__ns3__setMuteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setMuteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setMuteRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setMuteRequest);
		if (size)
			*size = sizeof(_ns3__setMuteRequest);
		((_ns3__setMuteRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setMuteRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setMuteRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setMuteRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setMuteRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setMuteRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setMuteRequest %p -> %p\n", q, p));
	*(_ns3__setMuteRequest*)p = *(_ns3__setMuteRequest*)q;
}

void _ns3__getMuteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__getMuteResponse::isMuted);
	/* transient soap skipped */
}

void _ns3__getMuteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__getMuteResponse::isMuted, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns3__getMuteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getMuteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getMuteResponse(struct soap *soap, const char *tag, int id, const _ns3__getMuteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getMuteResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "isMuted", -1, &(a->_ns3__getMuteResponse::isMuted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getMuteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getMuteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getMuteResponse * SOAP_FMAC4 soap_in__ns3__getMuteResponse(struct soap *soap, const char *tag, _ns3__getMuteResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getMuteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getMuteResponse, sizeof(_ns3__getMuteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getMuteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getMuteResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_isMuted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isMuted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isMuted", &(a->_ns3__getMuteResponse::isMuted), "xsd:boolean"))
				{	soap_flag_isMuted1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getMuteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getMuteResponse, 0, sizeof(_ns3__getMuteResponse), 0, soap_copy__ns3__getMuteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isMuted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getMuteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getMuteResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getMuteResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getMuteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getMuteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getMuteResponse * SOAP_FMAC4 soap_get__ns3__getMuteResponse(struct soap *soap, _ns3__getMuteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getMuteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getMuteResponse * SOAP_FMAC2 soap_instantiate__ns3__getMuteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getMuteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getMuteResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getMuteResponse);
		if (size)
			*size = sizeof(_ns3__getMuteResponse);
		((_ns3__getMuteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getMuteResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getMuteResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getMuteResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getMuteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getMuteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getMuteResponse %p -> %p\n", q, p));
	*(_ns3__getMuteResponse*)p = *(_ns3__getMuteResponse*)q;
}

void _ns3__getMuteRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getMuteRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getMuteRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getMuteRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getMuteRequest(struct soap *soap, const char *tag, int id, const _ns3__getMuteRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getMuteRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getMuteRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getMuteRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getMuteRequest * SOAP_FMAC4 soap_in__ns3__getMuteRequest(struct soap *soap, const char *tag, _ns3__getMuteRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getMuteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getMuteRequest, sizeof(_ns3__getMuteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getMuteRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getMuteRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getMuteRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getMuteRequest, 0, sizeof(_ns3__getMuteRequest), 0, soap_copy__ns3__getMuteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getMuteRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getMuteRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getMuteRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getMuteRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getMuteRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getMuteRequest * SOAP_FMAC4 soap_get__ns3__getMuteRequest(struct soap *soap, _ns3__getMuteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getMuteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getMuteRequest * SOAP_FMAC2 soap_instantiate__ns3__getMuteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getMuteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getMuteRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getMuteRequest);
		if (size)
			*size = sizeof(_ns3__getMuteRequest);
		((_ns3__getMuteRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getMuteRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getMuteRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getMuteRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getMuteRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getMuteRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getMuteRequest %p -> %p\n", q, p));
	*(_ns3__getMuteRequest*)p = *(_ns3__getMuteRequest*)q;
}

void _ns3__setGainResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setGainResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setGainResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setGainResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setGainResponse(struct soap *soap, const char *tag, int id, const _ns3__setGainResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setGainResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setGainResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setGainResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setGainResponse * SOAP_FMAC4 soap_in__ns3__setGainResponse(struct soap *soap, const char *tag, _ns3__setGainResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setGainResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setGainResponse, sizeof(_ns3__setGainResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setGainResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setGainResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setGainResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setGainResponse, 0, sizeof(_ns3__setGainResponse), 0, soap_copy__ns3__setGainResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setGainResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setGainResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setGainResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setGainResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setGainResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setGainResponse * SOAP_FMAC4 soap_get__ns3__setGainResponse(struct soap *soap, _ns3__setGainResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setGainResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setGainResponse * SOAP_FMAC2 soap_instantiate__ns3__setGainResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setGainResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setGainResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setGainResponse);
		if (size)
			*size = sizeof(_ns3__setGainResponse);
		((_ns3__setGainResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setGainResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setGainResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setGainResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setGainResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setGainResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setGainResponse %p -> %p\n", q, p));
	*(_ns3__setGainResponse*)p = *(_ns3__setGainResponse*)q;
}

void _ns3__setGainRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns3__setGainRequest::gain);
	/* transient soap skipped */
}

void _ns3__setGainRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns3__setGainRequest::gain);
	/* transient soap skipped */
#endif
}

int _ns3__setGainRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setGainRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setGainRequest(struct soap *soap, const char *tag, int id, const _ns3__setGainRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setGainRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "gain", -1, &(a->_ns3__setGainRequest::gain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setGainRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setGainRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setGainRequest * SOAP_FMAC4 soap_in__ns3__setGainRequest(struct soap *soap, const char *tag, _ns3__setGainRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setGainRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setGainRequest, sizeof(_ns3__setGainRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setGainRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setGainRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gain1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "gain", &(a->_ns3__setGainRequest::gain), "xsd:integer"))
				{	soap_flag_gain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setGainRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setGainRequest, 0, sizeof(_ns3__setGainRequest), 0, soap_copy__ns3__setGainRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setGainRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setGainRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setGainRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setGainRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setGainRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setGainRequest * SOAP_FMAC4 soap_get__ns3__setGainRequest(struct soap *soap, _ns3__setGainRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setGainRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setGainRequest * SOAP_FMAC2 soap_instantiate__ns3__setGainRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setGainRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setGainRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setGainRequest);
		if (size)
			*size = sizeof(_ns3__setGainRequest);
		((_ns3__setGainRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setGainRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setGainRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setGainRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setGainRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setGainRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setGainRequest %p -> %p\n", q, p));
	*(_ns3__setGainRequest*)p = *(_ns3__setGainRequest*)q;
}

void _ns3__getGainResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns3__getGainResponse::gain);
	/* transient soap skipped */
}

void _ns3__getGainResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns3__getGainResponse::gain);
	/* transient soap skipped */
#endif
}

int _ns3__getGainResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getGainResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getGainResponse(struct soap *soap, const char *tag, int id, const _ns3__getGainResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getGainResponse), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "gain", -1, &(a->_ns3__getGainResponse::gain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getGainResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getGainResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getGainResponse * SOAP_FMAC4 soap_in__ns3__getGainResponse(struct soap *soap, const char *tag, _ns3__getGainResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getGainResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getGainResponse, sizeof(_ns3__getGainResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getGainResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getGainResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gain1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "gain", &(a->_ns3__getGainResponse::gain), "xsd:integer"))
				{	soap_flag_gain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getGainResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getGainResponse, 0, sizeof(_ns3__getGainResponse), 0, soap_copy__ns3__getGainResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getGainResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getGainResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getGainResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getGainResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getGainResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getGainResponse * SOAP_FMAC4 soap_get__ns3__getGainResponse(struct soap *soap, _ns3__getGainResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getGainResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getGainResponse * SOAP_FMAC2 soap_instantiate__ns3__getGainResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getGainResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getGainResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getGainResponse);
		if (size)
			*size = sizeof(_ns3__getGainResponse);
		((_ns3__getGainResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getGainResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getGainResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getGainResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getGainResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getGainResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getGainResponse %p -> %p\n", q, p));
	*(_ns3__getGainResponse*)p = *(_ns3__getGainResponse*)q;
}

void _ns3__getGainRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getGainRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getGainRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getGainRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getGainRequest(struct soap *soap, const char *tag, int id, const _ns3__getGainRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getGainRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getGainRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getGainRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getGainRequest * SOAP_FMAC4 soap_in__ns3__getGainRequest(struct soap *soap, const char *tag, _ns3__getGainRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getGainRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getGainRequest, sizeof(_ns3__getGainRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getGainRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getGainRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getGainRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getGainRequest, 0, sizeof(_ns3__getGainRequest), 0, soap_copy__ns3__getGainRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getGainRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getGainRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getGainRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getGainRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getGainRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getGainRequest * SOAP_FMAC4 soap_get__ns3__getGainRequest(struct soap *soap, _ns3__getGainRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getGainRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getGainRequest * SOAP_FMAC2 soap_instantiate__ns3__getGainRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getGainRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getGainRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getGainRequest);
		if (size)
			*size = sizeof(_ns3__getGainRequest);
		((_ns3__getGainRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getGainRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getGainRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getGainRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getGainRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getGainRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getGainRequest %p -> %p\n", q, p));
	*(_ns3__getGainRequest*)p = *(_ns3__getGainRequest*)q;
}

void _ns3__setCurrentMacroResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__setCurrentMacroResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__setCurrentMacroResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setCurrentMacroResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setCurrentMacroResponse(struct soap *soap, const char *tag, int id, const _ns3__setCurrentMacroResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setCurrentMacroResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setCurrentMacroResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setCurrentMacroResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setCurrentMacroResponse * SOAP_FMAC4 soap_in__ns3__setCurrentMacroResponse(struct soap *soap, const char *tag, _ns3__setCurrentMacroResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setCurrentMacroResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setCurrentMacroResponse, sizeof(_ns3__setCurrentMacroResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setCurrentMacroResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setCurrentMacroResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setCurrentMacroResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setCurrentMacroResponse, 0, sizeof(_ns3__setCurrentMacroResponse), 0, soap_copy__ns3__setCurrentMacroResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__setCurrentMacroResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setCurrentMacroResponse);
	if (this->soap_out(soap, tag?tag:"ns3:setCurrentMacroResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setCurrentMacroResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setCurrentMacroResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setCurrentMacroResponse * SOAP_FMAC4 soap_get__ns3__setCurrentMacroResponse(struct soap *soap, _ns3__setCurrentMacroResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setCurrentMacroResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setCurrentMacroResponse * SOAP_FMAC2 soap_instantiate__ns3__setCurrentMacroResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setCurrentMacroResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setCurrentMacroResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setCurrentMacroResponse);
		if (size)
			*size = sizeof(_ns3__setCurrentMacroResponse);
		((_ns3__setCurrentMacroResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setCurrentMacroResponse, n);
		if (size)
			*size = n * sizeof(_ns3__setCurrentMacroResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setCurrentMacroResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setCurrentMacroResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setCurrentMacroResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setCurrentMacroResponse %p -> %p\n", q, p));
	*(_ns3__setCurrentMacroResponse*)p = *(_ns3__setCurrentMacroResponse*)q;
}

void _ns3__setCurrentMacroRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns3__setCurrentMacroRequest::id);
	/* transient soap skipped */
}

void _ns3__setCurrentMacroRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->_ns3__setCurrentMacroRequest::id);
	/* transient soap skipped */
#endif
}

int _ns3__setCurrentMacroRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__setCurrentMacroRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__setCurrentMacroRequest(struct soap *soap, const char *tag, int id, const _ns3__setCurrentMacroRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__setCurrentMacroRequest), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &(a->_ns3__setCurrentMacroRequest::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__setCurrentMacroRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__setCurrentMacroRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__setCurrentMacroRequest * SOAP_FMAC4 soap_in__ns3__setCurrentMacroRequest(struct soap *soap, const char *tag, _ns3__setCurrentMacroRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__setCurrentMacroRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__setCurrentMacroRequest, sizeof(_ns3__setCurrentMacroRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__setCurrentMacroRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__setCurrentMacroRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &(a->_ns3__setCurrentMacroRequest::id), "xsd:integer"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__setCurrentMacroRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__setCurrentMacroRequest, 0, sizeof(_ns3__setCurrentMacroRequest), 0, soap_copy__ns3__setCurrentMacroRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__setCurrentMacroRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__setCurrentMacroRequest);
	if (this->soap_out(soap, tag?tag:"ns3:setCurrentMacroRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__setCurrentMacroRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__setCurrentMacroRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__setCurrentMacroRequest * SOAP_FMAC4 soap_get__ns3__setCurrentMacroRequest(struct soap *soap, _ns3__setCurrentMacroRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__setCurrentMacroRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__setCurrentMacroRequest * SOAP_FMAC2 soap_instantiate__ns3__setCurrentMacroRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__setCurrentMacroRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__setCurrentMacroRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__setCurrentMacroRequest);
		if (size)
			*size = sizeof(_ns3__setCurrentMacroRequest);
		((_ns3__setCurrentMacroRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__setCurrentMacroRequest, n);
		if (size)
			*size = n * sizeof(_ns3__setCurrentMacroRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__setCurrentMacroRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__setCurrentMacroRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__setCurrentMacroRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__setCurrentMacroRequest %p -> %p\n", q, p));
	*(_ns3__setCurrentMacroRequest*)p = *(_ns3__setCurrentMacroRequest*)q;
}

void _ns3__getCurrentMacroResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__getCurrentMacroResponse::macro = NULL;
	/* transient soap skipped */
}

void _ns3__getCurrentMacroResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__macro(soap, &this->_ns3__getCurrentMacroResponse::macro);
	/* transient soap skipped */
#endif
}

int _ns3__getCurrentMacroResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getCurrentMacroResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getCurrentMacroResponse(struct soap *soap, const char *tag, int id, const _ns3__getCurrentMacroResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getCurrentMacroResponse), type))
		return soap->error;
	if (a->_ns3__getCurrentMacroResponse::macro)
	{	if (soap_out_PointerTons2__macro(soap, "macro", -1, &a->_ns3__getCurrentMacroResponse::macro, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "macro"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getCurrentMacroResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getCurrentMacroResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getCurrentMacroResponse * SOAP_FMAC4 soap_in__ns3__getCurrentMacroResponse(struct soap *soap, const char *tag, _ns3__getCurrentMacroResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getCurrentMacroResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getCurrentMacroResponse, sizeof(_ns3__getCurrentMacroResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getCurrentMacroResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getCurrentMacroResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_macro1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__macro(soap, "macro", &(a->_ns3__getCurrentMacroResponse::macro), "ns2:macro"))
				{	soap_flag_macro1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getCurrentMacroResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getCurrentMacroResponse, 0, sizeof(_ns3__getCurrentMacroResponse), 0, soap_copy__ns3__getCurrentMacroResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_macro1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__getCurrentMacroResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getCurrentMacroResponse);
	if (this->soap_out(soap, tag?tag:"ns3:getCurrentMacroResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getCurrentMacroResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getCurrentMacroResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getCurrentMacroResponse * SOAP_FMAC4 soap_get__ns3__getCurrentMacroResponse(struct soap *soap, _ns3__getCurrentMacroResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getCurrentMacroResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getCurrentMacroResponse * SOAP_FMAC2 soap_instantiate__ns3__getCurrentMacroResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getCurrentMacroResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getCurrentMacroResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getCurrentMacroResponse);
		if (size)
			*size = sizeof(_ns3__getCurrentMacroResponse);
		((_ns3__getCurrentMacroResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getCurrentMacroResponse, n);
		if (size)
			*size = n * sizeof(_ns3__getCurrentMacroResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getCurrentMacroResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getCurrentMacroResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getCurrentMacroResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getCurrentMacroResponse %p -> %p\n", q, p));
	*(_ns3__getCurrentMacroResponse*)p = *(_ns3__getCurrentMacroResponse*)q;
}

void _ns3__getCurrentMacroRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__getCurrentMacroRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__getCurrentMacroRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__getCurrentMacroRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__getCurrentMacroRequest(struct soap *soap, const char *tag, int id, const _ns3__getCurrentMacroRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__getCurrentMacroRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__getCurrentMacroRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__getCurrentMacroRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__getCurrentMacroRequest * SOAP_FMAC4 soap_in__ns3__getCurrentMacroRequest(struct soap *soap, const char *tag, _ns3__getCurrentMacroRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__getCurrentMacroRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__getCurrentMacroRequest, sizeof(_ns3__getCurrentMacroRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__getCurrentMacroRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__getCurrentMacroRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__getCurrentMacroRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__getCurrentMacroRequest, 0, sizeof(_ns3__getCurrentMacroRequest), 0, soap_copy__ns3__getCurrentMacroRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__getCurrentMacroRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__getCurrentMacroRequest);
	if (this->soap_out(soap, tag?tag:"ns3:getCurrentMacroRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__getCurrentMacroRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__getCurrentMacroRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__getCurrentMacroRequest * SOAP_FMAC4 soap_get__ns3__getCurrentMacroRequest(struct soap *soap, _ns3__getCurrentMacroRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__getCurrentMacroRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__getCurrentMacroRequest * SOAP_FMAC2 soap_instantiate__ns3__getCurrentMacroRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__getCurrentMacroRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__getCurrentMacroRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__getCurrentMacroRequest);
		if (size)
			*size = sizeof(_ns3__getCurrentMacroRequest);
		((_ns3__getCurrentMacroRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__getCurrentMacroRequest, n);
		if (size)
			*size = n * sizeof(_ns3__getCurrentMacroRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__getCurrentMacroRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__getCurrentMacroRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__getCurrentMacroRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__getCurrentMacroRequest %p -> %p\n", q, p));
	*(_ns3__getCurrentMacroRequest*)p = *(_ns3__getCurrentMacroRequest*)q;
}

void _ns3__listMacrosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__macro(soap, &this->_ns3__listMacrosResponse::macros);
	/* transient soap skipped */
}

void _ns3__listMacrosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__macro(soap, &this->_ns3__listMacrosResponse::macros);
	/* transient soap skipped */
#endif
}

int _ns3__listMacrosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__listMacrosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__listMacrosResponse(struct soap *soap, const char *tag, int id, const _ns3__listMacrosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__listMacrosResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__macro(soap, "macros", -1, &(a->_ns3__listMacrosResponse::macros), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__listMacrosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__listMacrosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__listMacrosResponse * SOAP_FMAC4 soap_in__ns3__listMacrosResponse(struct soap *soap, const char *tag, _ns3__listMacrosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__listMacrosResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__listMacrosResponse, sizeof(_ns3__listMacrosResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__listMacrosResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__listMacrosResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__macro(soap, "macros", &(a->_ns3__listMacrosResponse::macros), "ns2:macro"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__listMacrosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__listMacrosResponse, 0, sizeof(_ns3__listMacrosResponse), 0, soap_copy__ns3__listMacrosResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__listMacrosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__listMacrosResponse);
	if (this->soap_out(soap, tag?tag:"ns3:listMacrosResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__listMacrosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__listMacrosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__listMacrosResponse * SOAP_FMAC4 soap_get__ns3__listMacrosResponse(struct soap *soap, _ns3__listMacrosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__listMacrosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__listMacrosResponse * SOAP_FMAC2 soap_instantiate__ns3__listMacrosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__listMacrosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__listMacrosResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__listMacrosResponse);
		if (size)
			*size = sizeof(_ns3__listMacrosResponse);
		((_ns3__listMacrosResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__listMacrosResponse, n);
		if (size)
			*size = n * sizeof(_ns3__listMacrosResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__listMacrosResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__listMacrosResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__listMacrosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__listMacrosResponse %p -> %p\n", q, p));
	*(_ns3__listMacrosResponse*)p = *(_ns3__listMacrosResponse*)q;
}

void _ns3__listMacrosRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__listMacrosRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns3__listMacrosRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__listMacrosRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__listMacrosRequest(struct soap *soap, const char *tag, int id, const _ns3__listMacrosRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__listMacrosRequest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__listMacrosRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__listMacrosRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__listMacrosRequest * SOAP_FMAC4 soap_in__ns3__listMacrosRequest(struct soap *soap, const char *tag, _ns3__listMacrosRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__listMacrosRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__listMacrosRequest, sizeof(_ns3__listMacrosRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__listMacrosRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__listMacrosRequest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__listMacrosRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__listMacrosRequest, 0, sizeof(_ns3__listMacrosRequest), 0, soap_copy__ns3__listMacrosRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__listMacrosRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns3__listMacrosRequest);
	if (this->soap_out(soap, tag?tag:"ns3:listMacrosRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__listMacrosRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__listMacrosRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__listMacrosRequest * SOAP_FMAC4 soap_get__ns3__listMacrosRequest(struct soap *soap, _ns3__listMacrosRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__listMacrosRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__listMacrosRequest * SOAP_FMAC2 soap_instantiate__ns3__listMacrosRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__listMacrosRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__listMacrosRequest, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__listMacrosRequest);
		if (size)
			*size = sizeof(_ns3__listMacrosRequest);
		((_ns3__listMacrosRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__listMacrosRequest, n);
		if (size)
			*size = n * sizeof(_ns3__listMacrosRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__listMacrosRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__listMacrosRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__listMacrosRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__listMacrosRequest %p -> %p\n", q, p));
	*(_ns3__listMacrosRequest*)p = *(_ns3__listMacrosRequest*)q;
}

void _ns2__alarm::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__alarm::alarmId = NULL;
	this->_ns2__alarm::timestamp = NULL;
	this->_ns2__alarm::clearable = NULL;
	soap_default_std__string(soap, &this->_ns2__alarm::id);
	soap_default__ns2__alarm_severity(soap, &this->_ns2__alarm::severity);
	soap_default__ns2__alarm_type(soap, &this->_ns2__alarm::type);
	/* transient soap skipped */
}

void _ns2__alarm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns2__alarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__alarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__alarm(struct soap *soap, const char *tag, int id, const _ns2__alarm *a, const char *type)
{
	if (((_ns2__alarm*)a)->alarmId)
		soap_set_attr(soap, "alarmId", ((_ns2__alarm*)a)->alarmId->c_str(), 1);
	if (((_ns2__alarm*)a)->timestamp)
		soap_set_attr(soap, "timestamp", ((_ns2__alarm*)a)->timestamp->c_str(), 1);
	if (((_ns2__alarm*)a)->clearable)
		soap_set_attr(soap, "clearable", soap_bool2s(soap, *((_ns2__alarm*)a)->clearable), 1);
	soap_set_attr(soap, "id", ((_ns2__alarm*)a)->id.c_str(), 1);
	soap_set_attr(soap, "severity", soap__ns2__alarm_severity2s(soap, ((_ns2__alarm*)a)->severity), 1);
	soap_set_attr(soap, "type", soap__ns2__alarm_type2s(soap, ((_ns2__alarm*)a)->type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__alarm), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__alarm::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__alarm(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__alarm * SOAP_FMAC4 soap_in__ns2__alarm(struct soap *soap, const char *tag, _ns2__alarm *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__alarm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__alarm, sizeof(_ns2__alarm), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__alarm)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__alarm *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "alarmId", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__alarm*)a)->alarmId = soap_new_std__string(soap, -1);
				((_ns2__alarm*)a)->alarmId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "timestamp", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__alarm*)a)->timestamp = soap_new_std__string(soap, -1);
				((_ns2__alarm*)a)->timestamp->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "clearable", 0);
		if (t)
		{
			if (!(((_ns2__alarm*)a)->clearable = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((_ns2__alarm*)a)->clearable))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_ns2__alarm*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2_ns2__alarm_severity(soap, soap_attr_value(soap, "severity", 1), &((_ns2__alarm*)a)->severity))
		return NULL;
	if (soap_s2_ns2__alarm_type(soap, soap_attr_value(soap, "type", 1), &((_ns2__alarm*)a)->type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__alarm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__alarm, 0, sizeof(_ns2__alarm), 0, soap_copy__ns2__alarm);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__alarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns2__alarm);
	if (this->soap_out(soap, tag?tag:"ns2:alarm", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__alarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__alarm(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__alarm * SOAP_FMAC4 soap_get__ns2__alarm(struct soap *soap, _ns2__alarm *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__alarm * SOAP_FMAC2 soap_instantiate__ns2__alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__alarm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__alarm, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__alarm);
		if (size)
			*size = sizeof(_ns2__alarm);
		((_ns2__alarm*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__alarm, n);
		if (size)
			*size = n * sizeof(_ns2__alarm);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__alarm*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__alarm*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__alarm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__alarm %p -> %p\n", q, p));
	*(_ns2__alarm*)p = *(_ns2__alarm*)q;
}

void ns2__keyValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__keyValuePair::key);
	soap_default_std__string(soap, &this->ns2__keyValuePair::value);
	/* transient soap skipped */
}

void ns2__keyValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns2__keyValuePair::key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__keyValuePair::key);
	soap_embedded(soap, &this->ns2__keyValuePair::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__keyValuePair::value);
	/* transient soap skipped */
#endif
}

int ns2__keyValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__keyValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__keyValuePair(struct soap *soap, const char *tag, int id, const ns2__keyValuePair *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__keyValuePair), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:key", -1, &(a->ns2__keyValuePair::key), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:value", -1, &(a->ns2__keyValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__keyValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__keyValuePair(soap, tag, this, type);
}

SOAP_FMAC3 ns2__keyValuePair * SOAP_FMAC4 soap_in_ns2__keyValuePair(struct soap *soap, const char *tag, ns2__keyValuePair *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__keyValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__keyValuePair, sizeof(ns2__keyValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__keyValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__keyValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_key1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:key", &(a->ns2__keyValuePair::key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:value", &(a->ns2__keyValuePair::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__keyValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__keyValuePair, 0, sizeof(ns2__keyValuePair), 0, soap_copy_ns2__keyValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__keyValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__keyValuePair);
	if (this->soap_out(soap, tag?tag:"ns2:keyValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__keyValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__keyValuePair(soap, this, tag, type);
}

SOAP_FMAC3 ns2__keyValuePair * SOAP_FMAC4 soap_get_ns2__keyValuePair(struct soap *soap, ns2__keyValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__keyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__keyValuePair * SOAP_FMAC2 soap_instantiate_ns2__keyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__keyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__keyValuePair, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__keyValuePair);
		if (size)
			*size = sizeof(ns2__keyValuePair);
		((ns2__keyValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__keyValuePair, n);
		if (size)
			*size = n * sizeof(ns2__keyValuePair);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__keyValuePair*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__keyValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__keyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__keyValuePair %p -> %p\n", q, p));
	*(ns2__keyValuePair*)p = *(ns2__keyValuePair*)q;
}

void ns2__audioStreamInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__audioStreamType(soap, &this->ns2__audioStreamInfo::type);
	soap_default_ns2__acmod(soap, &this->ns2__audioStreamInfo::acmod);
	/* transient soap skipped */
}

void ns2__audioStreamInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns2__audioStreamInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__audioStreamInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__audioStreamInfo(struct soap *soap, const char *tag, int id, const ns2__audioStreamInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__audioStreamInfo), type))
		return soap->error;
	if (soap_out_ns2__audioStreamType(soap, "ns2:type", -1, &(a->ns2__audioStreamInfo::type), ""))
		return soap->error;
	if (soap_out_ns2__acmod(soap, "ns2:acmod", -1, &(a->ns2__audioStreamInfo::acmod), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__audioStreamInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__audioStreamInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__audioStreamInfo * SOAP_FMAC4 soap_in_ns2__audioStreamInfo(struct soap *soap, const char *tag, ns2__audioStreamInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__audioStreamInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__audioStreamInfo, sizeof(ns2__audioStreamInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__audioStreamInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__audioStreamInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_acmod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__audioStreamType(soap, "ns2:type", &(a->ns2__audioStreamInfo::type), "ns2:audioStreamType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_acmod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__acmod(soap, "ns2:acmod", &(a->ns2__audioStreamInfo::acmod), "ns2:acmod"))
				{	soap_flag_acmod1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__audioStreamInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__audioStreamInfo, 0, sizeof(ns2__audioStreamInfo), 0, soap_copy_ns2__audioStreamInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_acmod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__audioStreamInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__audioStreamInfo);
	if (this->soap_out(soap, tag?tag:"ns2:audioStreamInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__audioStreamInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__audioStreamInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__audioStreamInfo * SOAP_FMAC4 soap_get_ns2__audioStreamInfo(struct soap *soap, ns2__audioStreamInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__audioStreamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__audioStreamInfo * SOAP_FMAC2 soap_instantiate_ns2__audioStreamInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__audioStreamInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__audioStreamInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__audioStreamInfo);
		if (size)
			*size = sizeof(ns2__audioStreamInfo);
		((ns2__audioStreamInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__audioStreamInfo, n);
		if (size)
			*size = n * sizeof(ns2__audioStreamInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__audioStreamInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__audioStreamInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__audioStreamInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__audioStreamInfo %p -> %p\n", q, p));
	*(ns2__audioStreamInfo*)p = *(ns2__audioStreamInfo*)q;
}

void ns2__fault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__fault::reason = NULL;
	/* transient soap skipped */
}

void ns2__fault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__fault::reason);
	/* transient soap skipped */
#endif
}

int ns2__fault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__fault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__fault(struct soap *soap, const char *tag, int id, const ns2__fault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__fault), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:reason", -1, &(a->ns2__fault::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__fault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__fault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__fault * SOAP_FMAC4 soap_in_ns2__fault(struct soap *soap, const char *tag, ns2__fault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__fault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__fault, sizeof(ns2__fault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__fault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__fault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:reason", &(a->ns2__fault::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__fault, 0, sizeof(ns2__fault), 0, soap_copy_ns2__fault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__fault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__fault);
	if (this->soap_out(soap, tag?tag:"ns2:fault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__fault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__fault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__fault * SOAP_FMAC4 soap_get_ns2__fault(struct soap *soap, ns2__fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__fault * SOAP_FMAC2 soap_instantiate_ns2__fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__fault, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__fault);
		if (size)
			*size = sizeof(ns2__fault);
		((ns2__fault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__fault, n);
		if (size)
			*size = n * sizeof(ns2__fault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__fault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__fault %p -> %p\n", q, p));
	*(ns2__fault*)p = *(ns2__fault*)q;
}

void ns2__macro::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->ns2__macro::id);
	soap_default_std__string(soap, &this->ns2__macro::name);
	/* transient soap skipped */
}

void ns2__macro::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, &this->ns2__macro::id);
	soap_embedded(soap, &this->ns2__macro::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__macro::name);
	/* transient soap skipped */
#endif
}

int ns2__macro::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__macro(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__macro(struct soap *soap, const char *tag, int id, const ns2__macro *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__macro), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns2:id", -1, &(a->ns2__macro::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:name", -1, &(a->ns2__macro::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__macro::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__macro(soap, tag, this, type);
}

SOAP_FMAC3 ns2__macro * SOAP_FMAC4 soap_in_ns2__macro(struct soap *soap, const char *tag, ns2__macro *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__macro *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__macro, sizeof(ns2__macro), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__macro)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__macro *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:id", &(a->ns2__macro::id), "xsd:integer"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:name", &(a->ns2__macro::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__macro *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__macro, 0, sizeof(ns2__macro), 0, soap_copy_ns2__macro);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__macro::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__macro);
	if (this->soap_out(soap, tag?tag:"ns2:macro", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__macro::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__macro(soap, this, tag, type);
}

SOAP_FMAC3 ns2__macro * SOAP_FMAC4 soap_get_ns2__macro(struct soap *soap, ns2__macro *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__macro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__macro * SOAP_FMAC2 soap_instantiate_ns2__macro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__macro(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__macro, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__macro);
		if (size)
			*size = sizeof(ns2__macro);
		((ns2__macro*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__macro, n);
		if (size)
			*size = n * sizeof(ns2__macro);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__macro*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__macro*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__macro(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__macro %p -> %p\n", q, p));
	*(ns2__macro*)p = *(ns2__macro*)q;
}

void ns2__allPassFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__filterID(soap, &this->ns2__allPassFilter::id);
	soap_default_float(soap, &this->ns2__allPassFilter::frequency);
	soap_default_float(soap, &this->ns2__allPassFilter::bw);
	soap_default_xsd__integer(soap, &this->ns2__allPassFilter::order);
	/* transient soap skipped */
}

void ns2__allPassFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__filterID(soap, &this->ns2__allPassFilter::id);
	soap_serialize_xsd__integer(soap, &this->ns2__allPassFilter::order);
	/* transient soap skipped */
#endif
}

int ns2__allPassFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__allPassFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__allPassFilter(struct soap *soap, const char *tag, int id, const ns2__allPassFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__allPassFilter), type))
		return soap->error;
	if (soap_out_ns2__filterID(soap, "ns2:id", -1, &(a->ns2__allPassFilter::id), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:frequency", -1, &(a->ns2__allPassFilter::frequency), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:bw", -1, &(a->ns2__allPassFilter::bw), ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns2:order", -1, &(a->ns2__allPassFilter::order), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__allPassFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__allPassFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns2__allPassFilter * SOAP_FMAC4 soap_in_ns2__allPassFilter(struct soap *soap, const char *tag, ns2__allPassFilter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__allPassFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__allPassFilter, sizeof(ns2__allPassFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__allPassFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__allPassFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_bw1 = 1;
	size_t soap_flag_order1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__filterID(soap, "ns2:id", &(a->ns2__allPassFilter::id), "ns2:filterID"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_frequency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:frequency", &(a->ns2__allPassFilter::frequency), "xsd:float"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_bw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:bw", &(a->ns2__allPassFilter::bw), "xsd:float"))
				{	soap_flag_bw1--;
					continue;
				}
			if (soap_flag_order1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:order", &(a->ns2__allPassFilter::order), "xsd:integer"))
				{	soap_flag_order1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__allPassFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__allPassFilter, 0, sizeof(ns2__allPassFilter), 0, soap_copy_ns2__allPassFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_frequency1 > 0 || soap_flag_bw1 > 0 || soap_flag_order1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__allPassFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__allPassFilter);
	if (this->soap_out(soap, tag?tag:"ns2:allPassFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__allPassFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__allPassFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns2__allPassFilter * SOAP_FMAC4 soap_get_ns2__allPassFilter(struct soap *soap, ns2__allPassFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__allPassFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__allPassFilter * SOAP_FMAC2 soap_instantiate_ns2__allPassFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__allPassFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__allPassFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__allPassFilter);
		if (size)
			*size = sizeof(ns2__allPassFilter);
		((ns2__allPassFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__allPassFilter, n);
		if (size)
			*size = n * sizeof(ns2__allPassFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__allPassFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__allPassFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__allPassFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__allPassFilter %p -> %p\n", q, p));
	*(ns2__allPassFilter*)p = *(ns2__allPassFilter*)q;
}

void ns2__parametricFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__filterID(soap, &this->ns2__parametricFilter::id);
	soap_default_float(soap, &this->ns2__parametricFilter::frequency);
	soap_default_float(soap, &this->ns2__parametricFilter::bw);
	soap_default_float(soap, &this->ns2__parametricFilter::gain);
	/* transient soap skipped */
}

void ns2__parametricFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__filterID(soap, &this->ns2__parametricFilter::id);
	/* transient soap skipped */
#endif
}

int ns2__parametricFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__parametricFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__parametricFilter(struct soap *soap, const char *tag, int id, const ns2__parametricFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__parametricFilter), type))
		return soap->error;
	if (soap_out_ns2__filterID(soap, "ns2:id", -1, &(a->ns2__parametricFilter::id), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:frequency", -1, &(a->ns2__parametricFilter::frequency), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:bw", -1, &(a->ns2__parametricFilter::bw), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:gain", -1, &(a->ns2__parametricFilter::gain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__parametricFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__parametricFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns2__parametricFilter * SOAP_FMAC4 soap_in_ns2__parametricFilter(struct soap *soap, const char *tag, ns2__parametricFilter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__parametricFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__parametricFilter, sizeof(ns2__parametricFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__parametricFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__parametricFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_bw1 = 1;
	size_t soap_flag_gain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__filterID(soap, "ns2:id", &(a->ns2__parametricFilter::id), "ns2:filterID"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_frequency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:frequency", &(a->ns2__parametricFilter::frequency), "xsd:float"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_bw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:bw", &(a->ns2__parametricFilter::bw), "xsd:float"))
				{	soap_flag_bw1--;
					continue;
				}
			if (soap_flag_gain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:gain", &(a->ns2__parametricFilter::gain), "xsd:float"))
				{	soap_flag_gain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__parametricFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__parametricFilter, 0, sizeof(ns2__parametricFilter), 0, soap_copy_ns2__parametricFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_frequency1 > 0 || soap_flag_bw1 > 0 || soap_flag_gain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__parametricFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__parametricFilter);
	if (this->soap_out(soap, tag?tag:"ns2:parametricFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__parametricFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__parametricFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns2__parametricFilter * SOAP_FMAC4 soap_get_ns2__parametricFilter(struct soap *soap, ns2__parametricFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__parametricFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__parametricFilter * SOAP_FMAC2 soap_instantiate_ns2__parametricFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__parametricFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__parametricFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__parametricFilter);
		if (size)
			*size = sizeof(ns2__parametricFilter);
		((ns2__parametricFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__parametricFilter, n);
		if (size)
			*size = n * sizeof(ns2__parametricFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__parametricFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__parametricFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__parametricFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__parametricFilter %p -> %p\n", q, p));
	*(ns2__parametricFilter*)p = *(ns2__parametricFilter*)q;
}

void ns2__shelfFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__filterID(soap, &this->ns2__shelfFilter::id);
	soap_default_float(soap, &this->ns2__shelfFilter::frequency);
	soap_default_float(soap, &this->ns2__shelfFilter::bw);
	soap_default_float(soap, &this->ns2__shelfFilter::gain);
	soap_default_ns2__shelfType(soap, &this->ns2__shelfFilter::type);
	/* transient soap skipped */
}

void ns2__shelfFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__filterID(soap, &this->ns2__shelfFilter::id);
	/* transient soap skipped */
#endif
}

int ns2__shelfFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__shelfFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__shelfFilter(struct soap *soap, const char *tag, int id, const ns2__shelfFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__shelfFilter), type))
		return soap->error;
	if (soap_out_ns2__filterID(soap, "ns2:id", -1, &(a->ns2__shelfFilter::id), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:frequency", -1, &(a->ns2__shelfFilter::frequency), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:bw", -1, &(a->ns2__shelfFilter::bw), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:gain", -1, &(a->ns2__shelfFilter::gain), ""))
		return soap->error;
	if (soap_out_ns2__shelfType(soap, "ns2:type", -1, &(a->ns2__shelfFilter::type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__shelfFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__shelfFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns2__shelfFilter * SOAP_FMAC4 soap_in_ns2__shelfFilter(struct soap *soap, const char *tag, ns2__shelfFilter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__shelfFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__shelfFilter, sizeof(ns2__shelfFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__shelfFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__shelfFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_bw1 = 1;
	size_t soap_flag_gain1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__filterID(soap, "ns2:id", &(a->ns2__shelfFilter::id), "ns2:filterID"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_frequency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:frequency", &(a->ns2__shelfFilter::frequency), "xsd:float"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_bw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:bw", &(a->ns2__shelfFilter::bw), "xsd:float"))
				{	soap_flag_bw1--;
					continue;
				}
			if (soap_flag_gain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:gain", &(a->ns2__shelfFilter::gain), "xsd:float"))
				{	soap_flag_gain1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__shelfType(soap, "ns2:type", &(a->ns2__shelfFilter::type), "ns2:shelfType"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__shelfFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__shelfFilter, 0, sizeof(ns2__shelfFilter), 0, soap_copy_ns2__shelfFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_frequency1 > 0 || soap_flag_bw1 > 0 || soap_flag_gain1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__shelfFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__shelfFilter);
	if (this->soap_out(soap, tag?tag:"ns2:shelfFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__shelfFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__shelfFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns2__shelfFilter * SOAP_FMAC4 soap_get_ns2__shelfFilter(struct soap *soap, ns2__shelfFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__shelfFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__shelfFilter * SOAP_FMAC2 soap_instantiate_ns2__shelfFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__shelfFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__shelfFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__shelfFilter);
		if (size)
			*size = sizeof(ns2__shelfFilter);
		((ns2__shelfFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__shelfFilter, n);
		if (size)
			*size = n * sizeof(ns2__shelfFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__shelfFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__shelfFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__shelfFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__shelfFilter %p -> %p\n", q, p));
	*(ns2__shelfFilter*)p = *(ns2__shelfFilter*)q;
}

void ns2__crossoverFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__filterID(soap, &this->ns2__crossoverFilter::id);
	soap_default_float(soap, &this->ns2__crossoverFilter::frequency);
	soap_default_ns2__crossoverSlope(soap, &this->ns2__crossoverFilter::slope);
	soap_default_ns2__crossoverFilterType(soap, &this->ns2__crossoverFilter::filterType);
	soap_default_ns2__crossoverType(soap, &this->ns2__crossoverFilter::type);
	/* transient soap skipped */
}

void ns2__crossoverFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__filterID(soap, &this->ns2__crossoverFilter::id);
	/* transient soap skipped */
#endif
}

int ns2__crossoverFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__crossoverFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__crossoverFilter(struct soap *soap, const char *tag, int id, const ns2__crossoverFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__crossoverFilter), type))
		return soap->error;
	if (soap_out_ns2__filterID(soap, "ns2:id", -1, &(a->ns2__crossoverFilter::id), ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:frequency", -1, &(a->ns2__crossoverFilter::frequency), ""))
		return soap->error;
	if (soap_out_ns2__crossoverSlope(soap, "ns2:slope", -1, &(a->ns2__crossoverFilter::slope), ""))
		return soap->error;
	if (soap_out_ns2__crossoverFilterType(soap, "ns2:filterType", -1, &(a->ns2__crossoverFilter::filterType), ""))
		return soap->error;
	if (soap_out_ns2__crossoverType(soap, "ns2:type", -1, &(a->ns2__crossoverFilter::type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__crossoverFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__crossoverFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns2__crossoverFilter * SOAP_FMAC4 soap_in_ns2__crossoverFilter(struct soap *soap, const char *tag, ns2__crossoverFilter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__crossoverFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__crossoverFilter, sizeof(ns2__crossoverFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__crossoverFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__crossoverFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_slope1 = 1;
	size_t soap_flag_filterType1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__filterID(soap, "ns2:id", &(a->ns2__crossoverFilter::id), "ns2:filterID"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_frequency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:frequency", &(a->ns2__crossoverFilter::frequency), "xsd:float"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_slope1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__crossoverSlope(soap, "ns2:slope", &(a->ns2__crossoverFilter::slope), "ns2:crossoverSlope"))
				{	soap_flag_slope1--;
					continue;
				}
			if (soap_flag_filterType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__crossoverFilterType(soap, "ns2:filterType", &(a->ns2__crossoverFilter::filterType), "ns2:crossoverFilterType"))
				{	soap_flag_filterType1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__crossoverType(soap, "ns2:type", &(a->ns2__crossoverFilter::type), "ns2:crossoverType"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__crossoverFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__crossoverFilter, 0, sizeof(ns2__crossoverFilter), 0, soap_copy_ns2__crossoverFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_frequency1 > 0 || soap_flag_slope1 > 0 || soap_flag_filterType1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__crossoverFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns2__crossoverFilter);
	if (this->soap_out(soap, tag?tag:"ns2:crossoverFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__crossoverFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__crossoverFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns2__crossoverFilter * SOAP_FMAC4 soap_get_ns2__crossoverFilter(struct soap *soap, ns2__crossoverFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__crossoverFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__crossoverFilter * SOAP_FMAC2 soap_instantiate_ns2__crossoverFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__crossoverFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__crossoverFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__crossoverFilter);
		if (size)
			*size = sizeof(ns2__crossoverFilter);
		((ns2__crossoverFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__crossoverFilter, n);
		if (size)
			*size = n * sizeof(ns2__crossoverFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__crossoverFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__crossoverFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__crossoverFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__crossoverFilter %p -> %p\n", q, p));
	*(ns2__crossoverFilter*)p = *(ns2__crossoverFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteWayFilter(struct soap *soap, struct __ns1__deleteWayFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__deleteWayFilterRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteWayFilter(struct soap *soap, const struct __ns1__deleteWayFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__deleteWayFilterRequest(soap, &a->ns4__deleteWayFilterRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteWayFilter(struct soap *soap, const char *tag, int id, const struct __ns1__deleteWayFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__deleteWayFilterRequest(soap, "ns4:deleteWayFilterRequest", -1, &a->ns4__deleteWayFilterRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteWayFilter * SOAP_FMAC4 soap_in___ns1__deleteWayFilter(struct soap *soap, const char *tag, struct __ns1__deleteWayFilter *a, const char *type)
{
	size_t soap_flag_ns4__deleteWayFilterRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteWayFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteWayFilter, sizeof(struct __ns1__deleteWayFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteWayFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__deleteWayFilterRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__deleteWayFilterRequest(soap, "ns4:deleteWayFilterRequest", &a->ns4__deleteWayFilterRequest, ""))
				{	soap_flag_ns4__deleteWayFilterRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteWayFilter(struct soap *soap, const struct __ns1__deleteWayFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteWayFilter(soap, tag?tag:"-ns1:deleteWayFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteWayFilter * SOAP_FMAC4 soap_get___ns1__deleteWayFilter(struct soap *soap, struct __ns1__deleteWayFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteWayFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteWayFilter * SOAP_FMAC2 soap_instantiate___ns1__deleteWayFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteWayFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteWayFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteWayFilter);
		if (size)
			*size = sizeof(struct __ns1__deleteWayFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__deleteWayFilter, n);
		if (size)
			*size = n * sizeof(struct __ns1__deleteWayFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__deleteWayFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteWayFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteWayFilter %p -> %p\n", q, p));
	*(struct __ns1__deleteWayFilter*)p = *(struct __ns1__deleteWayFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setWayFilter(struct soap *soap, struct __ns1__setWayFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__setWayFilterRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setWayFilter(struct soap *soap, const struct __ns1__setWayFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__setWayFilterRequest(soap, &a->ns4__setWayFilterRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setWayFilter(struct soap *soap, const char *tag, int id, const struct __ns1__setWayFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__setWayFilterRequest(soap, "ns4:setWayFilterRequest", -1, &a->ns4__setWayFilterRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setWayFilter * SOAP_FMAC4 soap_in___ns1__setWayFilter(struct soap *soap, const char *tag, struct __ns1__setWayFilter *a, const char *type)
{
	size_t soap_flag_ns4__setWayFilterRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setWayFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setWayFilter, sizeof(struct __ns1__setWayFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setWayFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__setWayFilterRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__setWayFilterRequest(soap, "ns4:setWayFilterRequest", &a->ns4__setWayFilterRequest, ""))
				{	soap_flag_ns4__setWayFilterRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setWayFilter(struct soap *soap, const struct __ns1__setWayFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setWayFilter(soap, tag?tag:"-ns1:setWayFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setWayFilter * SOAP_FMAC4 soap_get___ns1__setWayFilter(struct soap *soap, struct __ns1__setWayFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setWayFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setWayFilter * SOAP_FMAC2 soap_instantiate___ns1__setWayFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setWayFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setWayFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setWayFilter);
		if (size)
			*size = sizeof(struct __ns1__setWayFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setWayFilter, n);
		if (size)
			*size = n * sizeof(struct __ns1__setWayFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setWayFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setWayFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setWayFilter %p -> %p\n", q, p));
	*(struct __ns1__setWayFilter*)p = *(struct __ns1__setWayFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getWayFilters(struct soap *soap, struct __ns1__getWayFilters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__getWayFiltersRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getWayFilters(struct soap *soap, const struct __ns1__getWayFilters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__getWayFiltersRequest(soap, &a->ns4__getWayFiltersRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getWayFilters(struct soap *soap, const char *tag, int id, const struct __ns1__getWayFilters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__getWayFiltersRequest(soap, "ns4:getWayFiltersRequest", -1, &a->ns4__getWayFiltersRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWayFilters * SOAP_FMAC4 soap_in___ns1__getWayFilters(struct soap *soap, const char *tag, struct __ns1__getWayFilters *a, const char *type)
{
	size_t soap_flag_ns4__getWayFiltersRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getWayFilters *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getWayFilters, sizeof(struct __ns1__getWayFilters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getWayFilters(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__getWayFiltersRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__getWayFiltersRequest(soap, "ns4:getWayFiltersRequest", &a->ns4__getWayFiltersRequest, ""))
				{	soap_flag_ns4__getWayFiltersRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getWayFilters(struct soap *soap, const struct __ns1__getWayFilters *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getWayFilters(soap, tag?tag:"-ns1:getWayFilters", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWayFilters * SOAP_FMAC4 soap_get___ns1__getWayFilters(struct soap *soap, struct __ns1__getWayFilters *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getWayFilters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getWayFilters * SOAP_FMAC2 soap_instantiate___ns1__getWayFilters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getWayFilters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getWayFilters, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getWayFilters);
		if (size)
			*size = sizeof(struct __ns1__getWayFilters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getWayFilters, n);
		if (size)
			*size = n * sizeof(struct __ns1__getWayFilters);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getWayFilters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getWayFilters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getWayFilters %p -> %p\n", q, p));
	*(struct __ns1__getWayFilters*)p = *(struct __ns1__getWayFilters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getWayParams(struct soap *soap, struct __ns1__getWayParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__getWayParamsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getWayParams(struct soap *soap, const struct __ns1__getWayParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__getWayParamsRequest(soap, &a->ns4__getWayParamsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getWayParams(struct soap *soap, const char *tag, int id, const struct __ns1__getWayParams *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__getWayParamsRequest(soap, "ns4:getWayParamsRequest", -1, &a->ns4__getWayParamsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWayParams * SOAP_FMAC4 soap_in___ns1__getWayParams(struct soap *soap, const char *tag, struct __ns1__getWayParams *a, const char *type)
{
	size_t soap_flag_ns4__getWayParamsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getWayParams *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getWayParams, sizeof(struct __ns1__getWayParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getWayParams(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__getWayParamsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__getWayParamsRequest(soap, "ns4:getWayParamsRequest", &a->ns4__getWayParamsRequest, ""))
				{	soap_flag_ns4__getWayParamsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getWayParams(struct soap *soap, const struct __ns1__getWayParams *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getWayParams(soap, tag?tag:"-ns1:getWayParams", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWayParams * SOAP_FMAC4 soap_get___ns1__getWayParams(struct soap *soap, struct __ns1__getWayParams *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getWayParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getWayParams * SOAP_FMAC2 soap_instantiate___ns1__getWayParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getWayParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getWayParams, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getWayParams);
		if (size)
			*size = sizeof(struct __ns1__getWayParams);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getWayParams, n);
		if (size)
			*size = n * sizeof(struct __ns1__getWayParams);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getWayParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getWayParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getWayParams %p -> %p\n", q, p));
	*(struct __ns1__getWayParams*)p = *(struct __ns1__getWayParams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setWayParams(struct soap *soap, struct __ns1__setWayParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__setWayParamsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setWayParams(struct soap *soap, const struct __ns1__setWayParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__setWayParamsRequest(soap, &a->ns4__setWayParamsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setWayParams(struct soap *soap, const char *tag, int id, const struct __ns1__setWayParams *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__setWayParamsRequest(soap, "ns4:setWayParamsRequest", -1, &a->ns4__setWayParamsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setWayParams * SOAP_FMAC4 soap_in___ns1__setWayParams(struct soap *soap, const char *tag, struct __ns1__setWayParams *a, const char *type)
{
	size_t soap_flag_ns4__setWayParamsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setWayParams *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setWayParams, sizeof(struct __ns1__setWayParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setWayParams(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__setWayParamsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__setWayParamsRequest(soap, "ns4:setWayParamsRequest", &a->ns4__setWayParamsRequest, ""))
				{	soap_flag_ns4__setWayParamsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setWayParams(struct soap *soap, const struct __ns1__setWayParams *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setWayParams(soap, tag?tag:"-ns1:setWayParams", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setWayParams * SOAP_FMAC4 soap_get___ns1__setWayParams(struct soap *soap, struct __ns1__setWayParams *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setWayParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setWayParams * SOAP_FMAC2 soap_instantiate___ns1__setWayParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setWayParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setWayParams, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setWayParams);
		if (size)
			*size = sizeof(struct __ns1__setWayParams);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setWayParams, n);
		if (size)
			*size = n * sizeof(struct __ns1__setWayParams);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setWayParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setWayParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setWayParams %p -> %p\n", q, p));
	*(struct __ns1__setWayParams*)p = *(struct __ns1__setWayParams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSystemVersions(struct soap *soap, struct __ns1__getSystemVersions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__getSystemVersionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSystemVersions(struct soap *soap, const struct __ns1__getSystemVersions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__getSystemVersionsRequest(soap, &a->ns4__getSystemVersionsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSystemVersions(struct soap *soap, const char *tag, int id, const struct __ns1__getSystemVersions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__getSystemVersionsRequest(soap, "ns4:getSystemVersionsRequest", -1, &a->ns4__getSystemVersionsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemVersions * SOAP_FMAC4 soap_in___ns1__getSystemVersions(struct soap *soap, const char *tag, struct __ns1__getSystemVersions *a, const char *type)
{
	size_t soap_flag_ns4__getSystemVersionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getSystemVersions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSystemVersions, sizeof(struct __ns1__getSystemVersions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSystemVersions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__getSystemVersionsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__getSystemVersionsRequest(soap, "ns4:getSystemVersionsRequest", &a->ns4__getSystemVersionsRequest, ""))
				{	soap_flag_ns4__getSystemVersionsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSystemVersions(struct soap *soap, const struct __ns1__getSystemVersions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSystemVersions(soap, tag?tag:"-ns1:getSystemVersions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemVersions * SOAP_FMAC4 soap_get___ns1__getSystemVersions(struct soap *soap, struct __ns1__getSystemVersions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSystemVersions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSystemVersions * SOAP_FMAC2 soap_instantiate___ns1__getSystemVersions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSystemVersions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSystemVersions, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSystemVersions);
		if (size)
			*size = sizeof(struct __ns1__getSystemVersions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSystemVersions, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSystemVersions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSystemVersions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSystemVersions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSystemVersions %p -> %p\n", q, p));
	*(struct __ns1__getSystemVersions*)p = *(struct __ns1__getSystemVersions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCertificate(struct soap *soap, struct __ns1__getCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__getCertificateRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCertificate(struct soap *soap, const struct __ns1__getCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns4__getCertificateRequest(soap, &a->ns4__getCertificateRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCertificate(struct soap *soap, const char *tag, int id, const struct __ns1__getCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns4__getCertificateRequest(soap, "ns4:getCertificateRequest", -1, &a->ns4__getCertificateRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCertificate * SOAP_FMAC4 soap_in___ns1__getCertificate(struct soap *soap, const char *tag, struct __ns1__getCertificate *a, const char *type)
{
	size_t soap_flag_ns4__getCertificateRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCertificate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCertificate, sizeof(struct __ns1__getCertificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCertificate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__getCertificateRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__getCertificateRequest(soap, "ns4:getCertificateRequest", &a->ns4__getCertificateRequest, ""))
				{	soap_flag_ns4__getCertificateRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCertificate(struct soap *soap, const struct __ns1__getCertificate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCertificate(soap, tag?tag:"-ns1:getCertificate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCertificate * SOAP_FMAC4 soap_get___ns1__getCertificate(struct soap *soap, struct __ns1__getCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCertificate * SOAP_FMAC2 soap_instantiate___ns1__getCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCertificate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCertificate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCertificate);
		if (size)
			*size = sizeof(struct __ns1__getCertificate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCertificate, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCertificate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCertificate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCertificate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCertificate %p -> %p\n", q, p));
	*(struct __ns1__getCertificate*)p = *(struct __ns1__getCertificate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__performSystemUpgrade_(struct soap *soap, struct __ns1__performSystemUpgrade_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__performSystemUpgradeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__performSystemUpgrade_(struct soap *soap, const struct __ns1__performSystemUpgrade_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__performSystemUpgradeRequest(soap, &a->ns3__performSystemUpgradeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__performSystemUpgrade_(struct soap *soap, const char *tag, int id, const struct __ns1__performSystemUpgrade_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__performSystemUpgradeRequest(soap, "ns3:performSystemUpgradeRequest", -1, &a->ns3__performSystemUpgradeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__performSystemUpgrade_ * SOAP_FMAC4 soap_in___ns1__performSystemUpgrade_(struct soap *soap, const char *tag, struct __ns1__performSystemUpgrade_ *a, const char *type)
{
	size_t soap_flag_ns3__performSystemUpgradeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__performSystemUpgrade_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__performSystemUpgrade_, sizeof(struct __ns1__performSystemUpgrade_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__performSystemUpgrade_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__performSystemUpgradeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__performSystemUpgradeRequest(soap, "ns3:performSystemUpgradeRequest", &a->ns3__performSystemUpgradeRequest, ""))
				{	soap_flag_ns3__performSystemUpgradeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__performSystemUpgrade_(struct soap *soap, const struct __ns1__performSystemUpgrade_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__performSystemUpgrade_(soap, tag?tag:"-ns1:performSystemUpgrade", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__performSystemUpgrade_ * SOAP_FMAC4 soap_get___ns1__performSystemUpgrade_(struct soap *soap, struct __ns1__performSystemUpgrade_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__performSystemUpgrade_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__performSystemUpgrade_ * SOAP_FMAC2 soap_instantiate___ns1__performSystemUpgrade_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__performSystemUpgrade_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__performSystemUpgrade_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__performSystemUpgrade_);
		if (size)
			*size = sizeof(struct __ns1__performSystemUpgrade_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__performSystemUpgrade_, n);
		if (size)
			*size = n * sizeof(struct __ns1__performSystemUpgrade_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__performSystemUpgrade_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__performSystemUpgrade_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__performSystemUpgrade_ %p -> %p\n", q, p));
	*(struct __ns1__performSystemUpgrade_*)p = *(struct __ns1__performSystemUpgrade_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enableAutoEqMode_(struct soap *soap, struct __ns1__enableAutoEqMode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__enableAutoEqModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enableAutoEqMode_(struct soap *soap, const struct __ns1__enableAutoEqMode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__enableAutoEqModeRequest(soap, &a->ns3__enableAutoEqModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enableAutoEqMode_(struct soap *soap, const char *tag, int id, const struct __ns1__enableAutoEqMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__enableAutoEqModeRequest(soap, "ns3:enableAutoEqModeRequest", -1, &a->ns3__enableAutoEqModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableAutoEqMode_ * SOAP_FMAC4 soap_in___ns1__enableAutoEqMode_(struct soap *soap, const char *tag, struct __ns1__enableAutoEqMode_ *a, const char *type)
{
	size_t soap_flag_ns3__enableAutoEqModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__enableAutoEqMode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enableAutoEqMode_, sizeof(struct __ns1__enableAutoEqMode_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enableAutoEqMode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__enableAutoEqModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__enableAutoEqModeRequest(soap, "ns3:enableAutoEqModeRequest", &a->ns3__enableAutoEqModeRequest, ""))
				{	soap_flag_ns3__enableAutoEqModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enableAutoEqMode_(struct soap *soap, const struct __ns1__enableAutoEqMode_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enableAutoEqMode_(soap, tag?tag:"-ns1:enableAutoEqMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableAutoEqMode_ * SOAP_FMAC4 soap_get___ns1__enableAutoEqMode_(struct soap *soap, struct __ns1__enableAutoEqMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enableAutoEqMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__enableAutoEqMode_ * SOAP_FMAC2 soap_instantiate___ns1__enableAutoEqMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enableAutoEqMode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enableAutoEqMode_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__enableAutoEqMode_);
		if (size)
			*size = sizeof(struct __ns1__enableAutoEqMode_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__enableAutoEqMode_, n);
		if (size)
			*size = n * sizeof(struct __ns1__enableAutoEqMode_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__enableAutoEqMode_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enableAutoEqMode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enableAutoEqMode_ %p -> %p\n", q, p));
	*(struct __ns1__enableAutoEqMode_*)p = *(struct __ns1__enableAutoEqMode_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isAutoEqModeEnabled_(struct soap *soap, struct __ns1__isAutoEqModeEnabled_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isAutoEqModeEnabledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isAutoEqModeEnabled_(struct soap *soap, const struct __ns1__isAutoEqModeEnabled_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, &a->ns3__isAutoEqModeEnabledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isAutoEqModeEnabled_(struct soap *soap, const char *tag, int id, const struct __ns1__isAutoEqModeEnabled_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, "ns3:isAutoEqModeEnabledRequest", -1, &a->ns3__isAutoEqModeEnabledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAutoEqModeEnabled_ * SOAP_FMAC4 soap_in___ns1__isAutoEqModeEnabled_(struct soap *soap, const char *tag, struct __ns1__isAutoEqModeEnabled_ *a, const char *type)
{
	size_t soap_flag_ns3__isAutoEqModeEnabledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isAutoEqModeEnabled_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isAutoEqModeEnabled_, sizeof(struct __ns1__isAutoEqModeEnabled_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isAutoEqModeEnabled_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isAutoEqModeEnabledRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, "ns3:isAutoEqModeEnabledRequest", &a->ns3__isAutoEqModeEnabledRequest, ""))
				{	soap_flag_ns3__isAutoEqModeEnabledRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isAutoEqModeEnabled_(struct soap *soap, const struct __ns1__isAutoEqModeEnabled_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isAutoEqModeEnabled_(soap, tag?tag:"-ns1:isAutoEqModeEnabled", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAutoEqModeEnabled_ * SOAP_FMAC4 soap_get___ns1__isAutoEqModeEnabled_(struct soap *soap, struct __ns1__isAutoEqModeEnabled_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isAutoEqModeEnabled_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isAutoEqModeEnabled_ * SOAP_FMAC2 soap_instantiate___ns1__isAutoEqModeEnabled_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isAutoEqModeEnabled_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isAutoEqModeEnabled_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isAutoEqModeEnabled_);
		if (size)
			*size = sizeof(struct __ns1__isAutoEqModeEnabled_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isAutoEqModeEnabled_, n);
		if (size)
			*size = n * sizeof(struct __ns1__isAutoEqModeEnabled_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isAutoEqModeEnabled_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isAutoEqModeEnabled_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isAutoEqModeEnabled_ %p -> %p\n", q, p));
	*(struct __ns1__isAutoEqModeEnabled_*)p = *(struct __ns1__isAutoEqModeEnabled_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTimeZone_(struct soap *soap, struct __ns1__setTimeZone_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setTimeZoneRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTimeZone_(struct soap *soap, const struct __ns1__setTimeZone_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setTimeZoneRequest(soap, &a->ns3__setTimeZoneRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTimeZone_(struct soap *soap, const char *tag, int id, const struct __ns1__setTimeZone_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setTimeZoneRequest(soap, "ns3:setTimeZoneRequest", -1, &a->ns3__setTimeZoneRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTimeZone_ * SOAP_FMAC4 soap_in___ns1__setTimeZone_(struct soap *soap, const char *tag, struct __ns1__setTimeZone_ *a, const char *type)
{
	size_t soap_flag_ns3__setTimeZoneRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setTimeZone_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTimeZone_, sizeof(struct __ns1__setTimeZone_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTimeZone_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setTimeZoneRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setTimeZoneRequest(soap, "ns3:setTimeZoneRequest", &a->ns3__setTimeZoneRequest, ""))
				{	soap_flag_ns3__setTimeZoneRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTimeZone_(struct soap *soap, const struct __ns1__setTimeZone_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTimeZone_(soap, tag?tag:"-ns1:setTimeZone", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTimeZone_ * SOAP_FMAC4 soap_get___ns1__setTimeZone_(struct soap *soap, struct __ns1__setTimeZone_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTimeZone_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setTimeZone_ * SOAP_FMAC2 soap_instantiate___ns1__setTimeZone_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setTimeZone_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setTimeZone_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setTimeZone_);
		if (size)
			*size = sizeof(struct __ns1__setTimeZone_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setTimeZone_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setTimeZone_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setTimeZone_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setTimeZone_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setTimeZone_ %p -> %p\n", q, p));
	*(struct __ns1__setTimeZone_*)p = *(struct __ns1__setTimeZone_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTimeZone_(struct soap *soap, struct __ns1__getTimeZone_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getTimeZoneRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTimeZone_(struct soap *soap, const struct __ns1__getTimeZone_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getTimeZoneRequest(soap, &a->ns3__getTimeZoneRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTimeZone_(struct soap *soap, const char *tag, int id, const struct __ns1__getTimeZone_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getTimeZoneRequest(soap, "ns3:getTimeZoneRequest", -1, &a->ns3__getTimeZoneRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTimeZone_ * SOAP_FMAC4 soap_in___ns1__getTimeZone_(struct soap *soap, const char *tag, struct __ns1__getTimeZone_ *a, const char *type)
{
	size_t soap_flag_ns3__getTimeZoneRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getTimeZone_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTimeZone_, sizeof(struct __ns1__getTimeZone_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTimeZone_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getTimeZoneRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getTimeZoneRequest(soap, "ns3:getTimeZoneRequest", &a->ns3__getTimeZoneRequest, ""))
				{	soap_flag_ns3__getTimeZoneRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTimeZone_(struct soap *soap, const struct __ns1__getTimeZone_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTimeZone_(soap, tag?tag:"-ns1:getTimeZone", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTimeZone_ * SOAP_FMAC4 soap_get___ns1__getTimeZone_(struct soap *soap, struct __ns1__getTimeZone_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTimeZone_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTimeZone_ * SOAP_FMAC2 soap_instantiate___ns1__getTimeZone_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTimeZone_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTimeZone_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTimeZone_);
		if (size)
			*size = sizeof(struct __ns1__getTimeZone_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTimeZone_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTimeZone_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTimeZone_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTimeZone_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTimeZone_ %p -> %p\n", q, p));
	*(struct __ns1__getTimeZone_*)p = *(struct __ns1__getTimeZone_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeviceAlarms_(struct soap *soap, struct __ns1__getDeviceAlarms_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getDeviceAlarmsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeviceAlarms_(struct soap *soap, const struct __ns1__getDeviceAlarms_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getDeviceAlarmsRequest(soap, &a->ns3__getDeviceAlarmsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeviceAlarms_(struct soap *soap, const char *tag, int id, const struct __ns1__getDeviceAlarms_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getDeviceAlarmsRequest(soap, "ns3:getDeviceAlarmsRequest", -1, &a->ns3__getDeviceAlarmsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceAlarms_ * SOAP_FMAC4 soap_in___ns1__getDeviceAlarms_(struct soap *soap, const char *tag, struct __ns1__getDeviceAlarms_ *a, const char *type)
{
	size_t soap_flag_ns3__getDeviceAlarmsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getDeviceAlarms_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeviceAlarms_, sizeof(struct __ns1__getDeviceAlarms_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeviceAlarms_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getDeviceAlarmsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getDeviceAlarmsRequest(soap, "ns3:getDeviceAlarmsRequest", &a->ns3__getDeviceAlarmsRequest, ""))
				{	soap_flag_ns3__getDeviceAlarmsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeviceAlarms_(struct soap *soap, const struct __ns1__getDeviceAlarms_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeviceAlarms_(soap, tag?tag:"-ns1:getDeviceAlarms", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceAlarms_ * SOAP_FMAC4 soap_get___ns1__getDeviceAlarms_(struct soap *soap, struct __ns1__getDeviceAlarms_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeviceAlarms_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDeviceAlarms_ * SOAP_FMAC2 soap_instantiate___ns1__getDeviceAlarms_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDeviceAlarms_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDeviceAlarms_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDeviceAlarms_);
		if (size)
			*size = sizeof(struct __ns1__getDeviceAlarms_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDeviceAlarms_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDeviceAlarms_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDeviceAlarms_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDeviceAlarms_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDeviceAlarms_ %p -> %p\n", q, p));
	*(struct __ns1__getDeviceAlarms_*)p = *(struct __ns1__getDeviceAlarms_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeviceInfo_(struct soap *soap, struct __ns1__getDeviceInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getDeviceInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeviceInfo_(struct soap *soap, const struct __ns1__getDeviceInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getDeviceInfoRequest(soap, &a->ns3__getDeviceInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeviceInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__getDeviceInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getDeviceInfoRequest(soap, "ns3:getDeviceInfoRequest", -1, &a->ns3__getDeviceInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceInfo_ * SOAP_FMAC4 soap_in___ns1__getDeviceInfo_(struct soap *soap, const char *tag, struct __ns1__getDeviceInfo_ *a, const char *type)
{
	size_t soap_flag_ns3__getDeviceInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getDeviceInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeviceInfo_, sizeof(struct __ns1__getDeviceInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeviceInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getDeviceInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getDeviceInfoRequest(soap, "ns3:getDeviceInfoRequest", &a->ns3__getDeviceInfoRequest, ""))
				{	soap_flag_ns3__getDeviceInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeviceInfo_(struct soap *soap, const struct __ns1__getDeviceInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeviceInfo_(soap, tag?tag:"-ns1:getDeviceInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceInfo_ * SOAP_FMAC4 soap_get___ns1__getDeviceInfo_(struct soap *soap, struct __ns1__getDeviceInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeviceInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDeviceInfo_ * SOAP_FMAC2 soap_instantiate___ns1__getDeviceInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDeviceInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDeviceInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDeviceInfo_);
		if (size)
			*size = sizeof(struct __ns1__getDeviceInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDeviceInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDeviceInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDeviceInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDeviceInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDeviceInfo_ %p -> %p\n", q, p));
	*(struct __ns1__getDeviceInfo_*)p = *(struct __ns1__getDeviceInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enableGlobalEq_(struct soap *soap, struct __ns1__enableGlobalEq_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__enableGlobalEqRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enableGlobalEq_(struct soap *soap, const struct __ns1__enableGlobalEq_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__enableGlobalEqRequest(soap, &a->ns3__enableGlobalEqRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enableGlobalEq_(struct soap *soap, const char *tag, int id, const struct __ns1__enableGlobalEq_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__enableGlobalEqRequest(soap, "ns3:enableGlobalEqRequest", -1, &a->ns3__enableGlobalEqRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableGlobalEq_ * SOAP_FMAC4 soap_in___ns1__enableGlobalEq_(struct soap *soap, const char *tag, struct __ns1__enableGlobalEq_ *a, const char *type)
{
	size_t soap_flag_ns3__enableGlobalEqRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__enableGlobalEq_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enableGlobalEq_, sizeof(struct __ns1__enableGlobalEq_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enableGlobalEq_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__enableGlobalEqRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__enableGlobalEqRequest(soap, "ns3:enableGlobalEqRequest", &a->ns3__enableGlobalEqRequest, ""))
				{	soap_flag_ns3__enableGlobalEqRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enableGlobalEq_(struct soap *soap, const struct __ns1__enableGlobalEq_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enableGlobalEq_(soap, tag?tag:"-ns1:enableGlobalEq", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableGlobalEq_ * SOAP_FMAC4 soap_get___ns1__enableGlobalEq_(struct soap *soap, struct __ns1__enableGlobalEq_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enableGlobalEq_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__enableGlobalEq_ * SOAP_FMAC2 soap_instantiate___ns1__enableGlobalEq_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enableGlobalEq_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enableGlobalEq_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__enableGlobalEq_);
		if (size)
			*size = sizeof(struct __ns1__enableGlobalEq_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__enableGlobalEq_, n);
		if (size)
			*size = n * sizeof(struct __ns1__enableGlobalEq_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__enableGlobalEq_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enableGlobalEq_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enableGlobalEq_ %p -> %p\n", q, p));
	*(struct __ns1__enableGlobalEq_*)p = *(struct __ns1__enableGlobalEq_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isGlobalEqEnabled_(struct soap *soap, struct __ns1__isGlobalEqEnabled_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isGlobalEqEnabledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isGlobalEqEnabled_(struct soap *soap, const struct __ns1__isGlobalEqEnabled_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isGlobalEqEnabledRequest(soap, &a->ns3__isGlobalEqEnabledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isGlobalEqEnabled_(struct soap *soap, const char *tag, int id, const struct __ns1__isGlobalEqEnabled_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isGlobalEqEnabledRequest(soap, "ns3:isGlobalEqEnabledRequest", -1, &a->ns3__isGlobalEqEnabledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isGlobalEqEnabled_ * SOAP_FMAC4 soap_in___ns1__isGlobalEqEnabled_(struct soap *soap, const char *tag, struct __ns1__isGlobalEqEnabled_ *a, const char *type)
{
	size_t soap_flag_ns3__isGlobalEqEnabledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isGlobalEqEnabled_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isGlobalEqEnabled_, sizeof(struct __ns1__isGlobalEqEnabled_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isGlobalEqEnabled_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isGlobalEqEnabledRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isGlobalEqEnabledRequest(soap, "ns3:isGlobalEqEnabledRequest", &a->ns3__isGlobalEqEnabledRequest, ""))
				{	soap_flag_ns3__isGlobalEqEnabledRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isGlobalEqEnabled_(struct soap *soap, const struct __ns1__isGlobalEqEnabled_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isGlobalEqEnabled_(soap, tag?tag:"-ns1:isGlobalEqEnabled", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isGlobalEqEnabled_ * SOAP_FMAC4 soap_get___ns1__isGlobalEqEnabled_(struct soap *soap, struct __ns1__isGlobalEqEnabled_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isGlobalEqEnabled_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isGlobalEqEnabled_ * SOAP_FMAC2 soap_instantiate___ns1__isGlobalEqEnabled_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isGlobalEqEnabled_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isGlobalEqEnabled_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isGlobalEqEnabled_);
		if (size)
			*size = sizeof(struct __ns1__isGlobalEqEnabled_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isGlobalEqEnabled_, n);
		if (size)
			*size = n * sizeof(struct __ns1__isGlobalEqEnabled_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isGlobalEqEnabled_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isGlobalEqEnabled_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isGlobalEqEnabled_ %p -> %p\n", q, p));
	*(struct __ns1__isGlobalEqEnabled_*)p = *(struct __ns1__isGlobalEqEnabled_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enableBassManagement_(struct soap *soap, struct __ns1__enableBassManagement_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__enableBassManagementRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enableBassManagement_(struct soap *soap, const struct __ns1__enableBassManagement_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__enableBassManagementRequest(soap, &a->ns3__enableBassManagementRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enableBassManagement_(struct soap *soap, const char *tag, int id, const struct __ns1__enableBassManagement_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__enableBassManagementRequest(soap, "ns3:enableBassManagementRequest", -1, &a->ns3__enableBassManagementRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableBassManagement_ * SOAP_FMAC4 soap_in___ns1__enableBassManagement_(struct soap *soap, const char *tag, struct __ns1__enableBassManagement_ *a, const char *type)
{
	size_t soap_flag_ns3__enableBassManagementRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__enableBassManagement_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enableBassManagement_, sizeof(struct __ns1__enableBassManagement_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enableBassManagement_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__enableBassManagementRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__enableBassManagementRequest(soap, "ns3:enableBassManagementRequest", &a->ns3__enableBassManagementRequest, ""))
				{	soap_flag_ns3__enableBassManagementRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enableBassManagement_(struct soap *soap, const struct __ns1__enableBassManagement_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enableBassManagement_(soap, tag?tag:"-ns1:enableBassManagement", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableBassManagement_ * SOAP_FMAC4 soap_get___ns1__enableBassManagement_(struct soap *soap, struct __ns1__enableBassManagement_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enableBassManagement_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__enableBassManagement_ * SOAP_FMAC2 soap_instantiate___ns1__enableBassManagement_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enableBassManagement_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enableBassManagement_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__enableBassManagement_);
		if (size)
			*size = sizeof(struct __ns1__enableBassManagement_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__enableBassManagement_, n);
		if (size)
			*size = n * sizeof(struct __ns1__enableBassManagement_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__enableBassManagement_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enableBassManagement_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enableBassManagement_ %p -> %p\n", q, p));
	*(struct __ns1__enableBassManagement_*)p = *(struct __ns1__enableBassManagement_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isBassManagementEnabled_(struct soap *soap, struct __ns1__isBassManagementEnabled_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isBassManagementEnabledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isBassManagementEnabled_(struct soap *soap, const struct __ns1__isBassManagementEnabled_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isBassManagementEnabledRequest(soap, &a->ns3__isBassManagementEnabledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isBassManagementEnabled_(struct soap *soap, const char *tag, int id, const struct __ns1__isBassManagementEnabled_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isBassManagementEnabledRequest(soap, "ns3:isBassManagementEnabledRequest", -1, &a->ns3__isBassManagementEnabledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isBassManagementEnabled_ * SOAP_FMAC4 soap_in___ns1__isBassManagementEnabled_(struct soap *soap, const char *tag, struct __ns1__isBassManagementEnabled_ *a, const char *type)
{
	size_t soap_flag_ns3__isBassManagementEnabledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isBassManagementEnabled_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isBassManagementEnabled_, sizeof(struct __ns1__isBassManagementEnabled_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isBassManagementEnabled_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isBassManagementEnabledRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isBassManagementEnabledRequest(soap, "ns3:isBassManagementEnabledRequest", &a->ns3__isBassManagementEnabledRequest, ""))
				{	soap_flag_ns3__isBassManagementEnabledRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isBassManagementEnabled_(struct soap *soap, const struct __ns1__isBassManagementEnabled_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isBassManagementEnabled_(soap, tag?tag:"-ns1:isBassManagementEnabled", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isBassManagementEnabled_ * SOAP_FMAC4 soap_get___ns1__isBassManagementEnabled_(struct soap *soap, struct __ns1__isBassManagementEnabled_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isBassManagementEnabled_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isBassManagementEnabled_ * SOAP_FMAC2 soap_instantiate___ns1__isBassManagementEnabled_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isBassManagementEnabled_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isBassManagementEnabled_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isBassManagementEnabled_);
		if (size)
			*size = sizeof(struct __ns1__isBassManagementEnabled_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isBassManagementEnabled_, n);
		if (size)
			*size = n * sizeof(struct __ns1__isBassManagementEnabled_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isBassManagementEnabled_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isBassManagementEnabled_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isBassManagementEnabled_ %p -> %p\n", q, p));
	*(struct __ns1__isBassManagementEnabled_*)p = *(struct __ns1__isBassManagementEnabled_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTestSignalMode_(struct soap *soap, struct __ns1__setTestSignalMode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setTestSignalModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTestSignalMode_(struct soap *soap, const struct __ns1__setTestSignalMode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setTestSignalModeRequest(soap, &a->ns3__setTestSignalModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTestSignalMode_(struct soap *soap, const char *tag, int id, const struct __ns1__setTestSignalMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setTestSignalModeRequest(soap, "ns3:setTestSignalModeRequest", -1, &a->ns3__setTestSignalModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalMode_ * SOAP_FMAC4 soap_in___ns1__setTestSignalMode_(struct soap *soap, const char *tag, struct __ns1__setTestSignalMode_ *a, const char *type)
{
	size_t soap_flag_ns3__setTestSignalModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setTestSignalMode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTestSignalMode_, sizeof(struct __ns1__setTestSignalMode_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTestSignalMode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setTestSignalModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setTestSignalModeRequest(soap, "ns3:setTestSignalModeRequest", &a->ns3__setTestSignalModeRequest, ""))
				{	soap_flag_ns3__setTestSignalModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTestSignalMode_(struct soap *soap, const struct __ns1__setTestSignalMode_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTestSignalMode_(soap, tag?tag:"-ns1:setTestSignalMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalMode_ * SOAP_FMAC4 soap_get___ns1__setTestSignalMode_(struct soap *soap, struct __ns1__setTestSignalMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTestSignalMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setTestSignalMode_ * SOAP_FMAC2 soap_instantiate___ns1__setTestSignalMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setTestSignalMode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setTestSignalMode_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setTestSignalMode_);
		if (size)
			*size = sizeof(struct __ns1__setTestSignalMode_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setTestSignalMode_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setTestSignalMode_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setTestSignalMode_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setTestSignalMode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setTestSignalMode_ %p -> %p\n", q, p));
	*(struct __ns1__setTestSignalMode_*)p = *(struct __ns1__setTestSignalMode_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTestSignalMode_(struct soap *soap, struct __ns1__getTestSignalMode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getTestSignalModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTestSignalMode_(struct soap *soap, const struct __ns1__getTestSignalMode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getTestSignalModeRequest(soap, &a->ns3__getTestSignalModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTestSignalMode_(struct soap *soap, const char *tag, int id, const struct __ns1__getTestSignalMode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getTestSignalModeRequest(soap, "ns3:getTestSignalModeRequest", -1, &a->ns3__getTestSignalModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalMode_ * SOAP_FMAC4 soap_in___ns1__getTestSignalMode_(struct soap *soap, const char *tag, struct __ns1__getTestSignalMode_ *a, const char *type)
{
	size_t soap_flag_ns3__getTestSignalModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getTestSignalMode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTestSignalMode_, sizeof(struct __ns1__getTestSignalMode_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTestSignalMode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getTestSignalModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getTestSignalModeRequest(soap, "ns3:getTestSignalModeRequest", &a->ns3__getTestSignalModeRequest, ""))
				{	soap_flag_ns3__getTestSignalModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTestSignalMode_(struct soap *soap, const struct __ns1__getTestSignalMode_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTestSignalMode_(soap, tag?tag:"-ns1:getTestSignalMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalMode_ * SOAP_FMAC4 soap_get___ns1__getTestSignalMode_(struct soap *soap, struct __ns1__getTestSignalMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTestSignalMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTestSignalMode_ * SOAP_FMAC2 soap_instantiate___ns1__getTestSignalMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTestSignalMode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTestSignalMode_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTestSignalMode_);
		if (size)
			*size = sizeof(struct __ns1__getTestSignalMode_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTestSignalMode_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTestSignalMode_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTestSignalMode_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTestSignalMode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTestSignalMode_ %p -> %p\n", q, p));
	*(struct __ns1__getTestSignalMode_*)p = *(struct __ns1__getTestSignalMode_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTestSignalOutput_(struct soap *soap, struct __ns1__setTestSignalOutput_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setTestSignalOutputRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTestSignalOutput_(struct soap *soap, const struct __ns1__setTestSignalOutput_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setTestSignalOutputRequest(soap, &a->ns3__setTestSignalOutputRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTestSignalOutput_(struct soap *soap, const char *tag, int id, const struct __ns1__setTestSignalOutput_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setTestSignalOutputRequest(soap, "ns3:setTestSignalOutputRequest", -1, &a->ns3__setTestSignalOutputRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalOutput_ * SOAP_FMAC4 soap_in___ns1__setTestSignalOutput_(struct soap *soap, const char *tag, struct __ns1__setTestSignalOutput_ *a, const char *type)
{
	size_t soap_flag_ns3__setTestSignalOutputRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setTestSignalOutput_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTestSignalOutput_, sizeof(struct __ns1__setTestSignalOutput_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTestSignalOutput_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setTestSignalOutputRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setTestSignalOutputRequest(soap, "ns3:setTestSignalOutputRequest", &a->ns3__setTestSignalOutputRequest, ""))
				{	soap_flag_ns3__setTestSignalOutputRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTestSignalOutput_(struct soap *soap, const struct __ns1__setTestSignalOutput_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTestSignalOutput_(soap, tag?tag:"-ns1:setTestSignalOutput", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalOutput_ * SOAP_FMAC4 soap_get___ns1__setTestSignalOutput_(struct soap *soap, struct __ns1__setTestSignalOutput_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTestSignalOutput_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setTestSignalOutput_ * SOAP_FMAC2 soap_instantiate___ns1__setTestSignalOutput_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setTestSignalOutput_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setTestSignalOutput_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setTestSignalOutput_);
		if (size)
			*size = sizeof(struct __ns1__setTestSignalOutput_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setTestSignalOutput_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setTestSignalOutput_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setTestSignalOutput_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setTestSignalOutput_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setTestSignalOutput_ %p -> %p\n", q, p));
	*(struct __ns1__setTestSignalOutput_*)p = *(struct __ns1__setTestSignalOutput_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTestSignalOutput_(struct soap *soap, struct __ns1__getTestSignalOutput_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getTestSignalOutputRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTestSignalOutput_(struct soap *soap, const struct __ns1__getTestSignalOutput_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getTestSignalOutputRequest(soap, &a->ns3__getTestSignalOutputRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTestSignalOutput_(struct soap *soap, const char *tag, int id, const struct __ns1__getTestSignalOutput_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getTestSignalOutputRequest(soap, "ns3:getTestSignalOutputRequest", -1, &a->ns3__getTestSignalOutputRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalOutput_ * SOAP_FMAC4 soap_in___ns1__getTestSignalOutput_(struct soap *soap, const char *tag, struct __ns1__getTestSignalOutput_ *a, const char *type)
{
	size_t soap_flag_ns3__getTestSignalOutputRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getTestSignalOutput_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTestSignalOutput_, sizeof(struct __ns1__getTestSignalOutput_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTestSignalOutput_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getTestSignalOutputRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getTestSignalOutputRequest(soap, "ns3:getTestSignalOutputRequest", &a->ns3__getTestSignalOutputRequest, ""))
				{	soap_flag_ns3__getTestSignalOutputRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTestSignalOutput_(struct soap *soap, const struct __ns1__getTestSignalOutput_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTestSignalOutput_(soap, tag?tag:"-ns1:getTestSignalOutput", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalOutput_ * SOAP_FMAC4 soap_get___ns1__getTestSignalOutput_(struct soap *soap, struct __ns1__getTestSignalOutput_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTestSignalOutput_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTestSignalOutput_ * SOAP_FMAC2 soap_instantiate___ns1__getTestSignalOutput_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTestSignalOutput_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTestSignalOutput_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTestSignalOutput_);
		if (size)
			*size = sizeof(struct __ns1__getTestSignalOutput_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTestSignalOutput_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTestSignalOutput_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTestSignalOutput_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTestSignalOutput_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTestSignalOutput_ %p -> %p\n", q, p));
	*(struct __ns1__getTestSignalOutput_*)p = *(struct __ns1__getTestSignalOutput_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setAtmosConfig_(struct soap *soap, struct __ns1__setAtmosConfig_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setAtmosConfigRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setAtmosConfig_(struct soap *soap, const struct __ns1__setAtmosConfig_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setAtmosConfigRequest(soap, &a->ns3__setAtmosConfigRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setAtmosConfig_(struct soap *soap, const char *tag, int id, const struct __ns1__setAtmosConfig_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setAtmosConfigRequest(soap, "ns3:setAtmosConfigRequest", -1, &a->ns3__setAtmosConfigRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAtmosConfig_ * SOAP_FMAC4 soap_in___ns1__setAtmosConfig_(struct soap *soap, const char *tag, struct __ns1__setAtmosConfig_ *a, const char *type)
{
	size_t soap_flag_ns3__setAtmosConfigRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setAtmosConfig_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setAtmosConfig_, sizeof(struct __ns1__setAtmosConfig_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setAtmosConfig_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setAtmosConfigRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setAtmosConfigRequest(soap, "ns3:setAtmosConfigRequest", &a->ns3__setAtmosConfigRequest, ""))
				{	soap_flag_ns3__setAtmosConfigRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setAtmosConfig_(struct soap *soap, const struct __ns1__setAtmosConfig_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setAtmosConfig_(soap, tag?tag:"-ns1:setAtmosConfig", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAtmosConfig_ * SOAP_FMAC4 soap_get___ns1__setAtmosConfig_(struct soap *soap, struct __ns1__setAtmosConfig_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setAtmosConfig_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setAtmosConfig_ * SOAP_FMAC2 soap_instantiate___ns1__setAtmosConfig_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setAtmosConfig_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setAtmosConfig_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setAtmosConfig_);
		if (size)
			*size = sizeof(struct __ns1__setAtmosConfig_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setAtmosConfig_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setAtmosConfig_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setAtmosConfig_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setAtmosConfig_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setAtmosConfig_ %p -> %p\n", q, p));
	*(struct __ns1__setAtmosConfig_*)p = *(struct __ns1__setAtmosConfig_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAtmosConfig_(struct soap *soap, struct __ns1__getAtmosConfig_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getAtmosConfigRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAtmosConfig_(struct soap *soap, const struct __ns1__getAtmosConfig_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getAtmosConfigRequest(soap, &a->ns3__getAtmosConfigRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAtmosConfig_(struct soap *soap, const char *tag, int id, const struct __ns1__getAtmosConfig_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getAtmosConfigRequest(soap, "ns3:getAtmosConfigRequest", -1, &a->ns3__getAtmosConfigRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfig_ * SOAP_FMAC4 soap_in___ns1__getAtmosConfig_(struct soap *soap, const char *tag, struct __ns1__getAtmosConfig_ *a, const char *type)
{
	size_t soap_flag_ns3__getAtmosConfigRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAtmosConfig_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAtmosConfig_, sizeof(struct __ns1__getAtmosConfig_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAtmosConfig_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getAtmosConfigRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getAtmosConfigRequest(soap, "ns3:getAtmosConfigRequest", &a->ns3__getAtmosConfigRequest, ""))
				{	soap_flag_ns3__getAtmosConfigRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAtmosConfig_(struct soap *soap, const struct __ns1__getAtmosConfig_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAtmosConfig_(soap, tag?tag:"-ns1:getAtmosConfig", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfig_ * SOAP_FMAC4 soap_get___ns1__getAtmosConfig_(struct soap *soap, struct __ns1__getAtmosConfig_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAtmosConfig_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAtmosConfig_ * SOAP_FMAC2 soap_instantiate___ns1__getAtmosConfig_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAtmosConfig_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAtmosConfig_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAtmosConfig_);
		if (size)
			*size = sizeof(struct __ns1__getAtmosConfig_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAtmosConfig_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAtmosConfig_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAtmosConfig_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAtmosConfig_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAtmosConfig_ %p -> %p\n", q, p));
	*(struct __ns1__getAtmosConfig_*)p = *(struct __ns1__getAtmosConfig_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAtmosConfigInfo_(struct soap *soap, struct __ns1__getAtmosConfigInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getAtmosConfigInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAtmosConfigInfo_(struct soap *soap, const struct __ns1__getAtmosConfigInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getAtmosConfigInfoRequest(soap, &a->ns3__getAtmosConfigInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAtmosConfigInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__getAtmosConfigInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getAtmosConfigInfoRequest(soap, "ns3:getAtmosConfigInfoRequest", -1, &a->ns3__getAtmosConfigInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfigInfo_ * SOAP_FMAC4 soap_in___ns1__getAtmosConfigInfo_(struct soap *soap, const char *tag, struct __ns1__getAtmosConfigInfo_ *a, const char *type)
{
	size_t soap_flag_ns3__getAtmosConfigInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAtmosConfigInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAtmosConfigInfo_, sizeof(struct __ns1__getAtmosConfigInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAtmosConfigInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getAtmosConfigInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getAtmosConfigInfoRequest(soap, "ns3:getAtmosConfigInfoRequest", &a->ns3__getAtmosConfigInfoRequest, ""))
				{	soap_flag_ns3__getAtmosConfigInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAtmosConfigInfo_(struct soap *soap, const struct __ns1__getAtmosConfigInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAtmosConfigInfo_(soap, tag?tag:"-ns1:getAtmosConfigInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfigInfo_ * SOAP_FMAC4 soap_get___ns1__getAtmosConfigInfo_(struct soap *soap, struct __ns1__getAtmosConfigInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAtmosConfigInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAtmosConfigInfo_ * SOAP_FMAC2 soap_instantiate___ns1__getAtmosConfigInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAtmosConfigInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAtmosConfigInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAtmosConfigInfo_);
		if (size)
			*size = sizeof(struct __ns1__getAtmosConfigInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAtmosConfigInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAtmosConfigInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAtmosConfigInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAtmosConfigInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAtmosConfigInfo_ %p -> %p\n", q, p));
	*(struct __ns1__getAtmosConfigInfo_*)p = *(struct __ns1__getAtmosConfigInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAudioStreamInfo_(struct soap *soap, struct __ns1__getAudioStreamInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getAudioStreamInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAudioStreamInfo_(struct soap *soap, const struct __ns1__getAudioStreamInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getAudioStreamInfoRequest(soap, &a->ns3__getAudioStreamInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAudioStreamInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__getAudioStreamInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getAudioStreamInfoRequest(soap, "ns3:getAudioStreamInfoRequest", -1, &a->ns3__getAudioStreamInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAudioStreamInfo_ * SOAP_FMAC4 soap_in___ns1__getAudioStreamInfo_(struct soap *soap, const char *tag, struct __ns1__getAudioStreamInfo_ *a, const char *type)
{
	size_t soap_flag_ns3__getAudioStreamInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAudioStreamInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAudioStreamInfo_, sizeof(struct __ns1__getAudioStreamInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAudioStreamInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getAudioStreamInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getAudioStreamInfoRequest(soap, "ns3:getAudioStreamInfoRequest", &a->ns3__getAudioStreamInfoRequest, ""))
				{	soap_flag_ns3__getAudioStreamInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAudioStreamInfo_(struct soap *soap, const struct __ns1__getAudioStreamInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAudioStreamInfo_(soap, tag?tag:"-ns1:getAudioStreamInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAudioStreamInfo_ * SOAP_FMAC4 soap_get___ns1__getAudioStreamInfo_(struct soap *soap, struct __ns1__getAudioStreamInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAudioStreamInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAudioStreamInfo_ * SOAP_FMAC2 soap_instantiate___ns1__getAudioStreamInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAudioStreamInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAudioStreamInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAudioStreamInfo_);
		if (size)
			*size = sizeof(struct __ns1__getAudioStreamInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAudioStreamInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAudioStreamInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAudioStreamInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAudioStreamInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAudioStreamInfo_ %p -> %p\n", q, p));
	*(struct __ns1__getAudioStreamInfo_*)p = *(struct __ns1__getAudioStreamInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isAtmosContent_(struct soap *soap, struct __ns1__isAtmosContent_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isAtmosContentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isAtmosContent_(struct soap *soap, const struct __ns1__isAtmosContent_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isAtmosContentRequest(soap, &a->ns3__isAtmosContentRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isAtmosContent_(struct soap *soap, const char *tag, int id, const struct __ns1__isAtmosContent_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isAtmosContentRequest(soap, "ns3:isAtmosContentRequest", -1, &a->ns3__isAtmosContentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAtmosContent_ * SOAP_FMAC4 soap_in___ns1__isAtmosContent_(struct soap *soap, const char *tag, struct __ns1__isAtmosContent_ *a, const char *type)
{
	size_t soap_flag_ns3__isAtmosContentRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isAtmosContent_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isAtmosContent_, sizeof(struct __ns1__isAtmosContent_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isAtmosContent_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isAtmosContentRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isAtmosContentRequest(soap, "ns3:isAtmosContentRequest", &a->ns3__isAtmosContentRequest, ""))
				{	soap_flag_ns3__isAtmosContentRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isAtmosContent_(struct soap *soap, const struct __ns1__isAtmosContent_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isAtmosContent_(soap, tag?tag:"-ns1:isAtmosContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAtmosContent_ * SOAP_FMAC4 soap_get___ns1__isAtmosContent_(struct soap *soap, struct __ns1__isAtmosContent_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isAtmosContent_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isAtmosContent_ * SOAP_FMAC2 soap_instantiate___ns1__isAtmosContent_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isAtmosContent_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isAtmosContent_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isAtmosContent_);
		if (size)
			*size = sizeof(struct __ns1__isAtmosContent_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isAtmosContent_, n);
		if (size)
			*size = n * sizeof(struct __ns1__isAtmosContent_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isAtmosContent_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isAtmosContent_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isAtmosContent_ %p -> %p\n", q, p));
	*(struct __ns1__isAtmosContent_*)p = *(struct __ns1__isAtmosContent_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setMute_(struct soap *soap, struct __ns1__setMute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setMuteRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setMute_(struct soap *soap, const struct __ns1__setMute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setMuteRequest(soap, &a->ns3__setMuteRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setMute_(struct soap *soap, const char *tag, int id, const struct __ns1__setMute_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setMuteRequest(soap, "ns3:setMuteRequest", -1, &a->ns3__setMuteRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setMute_ * SOAP_FMAC4 soap_in___ns1__setMute_(struct soap *soap, const char *tag, struct __ns1__setMute_ *a, const char *type)
{
	size_t soap_flag_ns3__setMuteRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setMute_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setMute_, sizeof(struct __ns1__setMute_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setMute_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setMuteRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setMuteRequest(soap, "ns3:setMuteRequest", &a->ns3__setMuteRequest, ""))
				{	soap_flag_ns3__setMuteRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setMute_(struct soap *soap, const struct __ns1__setMute_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setMute_(soap, tag?tag:"-ns1:setMute", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setMute_ * SOAP_FMAC4 soap_get___ns1__setMute_(struct soap *soap, struct __ns1__setMute_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setMute_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setMute_ * SOAP_FMAC2 soap_instantiate___ns1__setMute_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setMute_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setMute_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setMute_);
		if (size)
			*size = sizeof(struct __ns1__setMute_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setMute_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setMute_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setMute_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setMute_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setMute_ %p -> %p\n", q, p));
	*(struct __ns1__setMute_*)p = *(struct __ns1__setMute_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMute_(struct soap *soap, struct __ns1__getMute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getMuteRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMute_(struct soap *soap, const struct __ns1__getMute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getMuteRequest(soap, &a->ns3__getMuteRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMute_(struct soap *soap, const char *tag, int id, const struct __ns1__getMute_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getMuteRequest(soap, "ns3:getMuteRequest", -1, &a->ns3__getMuteRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMute_ * SOAP_FMAC4 soap_in___ns1__getMute_(struct soap *soap, const char *tag, struct __ns1__getMute_ *a, const char *type)
{
	size_t soap_flag_ns3__getMuteRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMute_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMute_, sizeof(struct __ns1__getMute_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMute_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getMuteRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getMuteRequest(soap, "ns3:getMuteRequest", &a->ns3__getMuteRequest, ""))
				{	soap_flag_ns3__getMuteRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMute_(struct soap *soap, const struct __ns1__getMute_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMute_(soap, tag?tag:"-ns1:getMute", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMute_ * SOAP_FMAC4 soap_get___ns1__getMute_(struct soap *soap, struct __ns1__getMute_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMute_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMute_ * SOAP_FMAC2 soap_instantiate___ns1__getMute_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMute_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMute_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMute_);
		if (size)
			*size = sizeof(struct __ns1__getMute_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getMute_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getMute_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getMute_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMute_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMute_ %p -> %p\n", q, p));
	*(struct __ns1__getMute_*)p = *(struct __ns1__getMute_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setGain_(struct soap *soap, struct __ns1__setGain_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setGainRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setGain_(struct soap *soap, const struct __ns1__setGain_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setGainRequest(soap, &a->ns3__setGainRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setGain_(struct soap *soap, const char *tag, int id, const struct __ns1__setGain_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setGainRequest(soap, "ns3:setGainRequest", -1, &a->ns3__setGainRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGain_ * SOAP_FMAC4 soap_in___ns1__setGain_(struct soap *soap, const char *tag, struct __ns1__setGain_ *a, const char *type)
{
	size_t soap_flag_ns3__setGainRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setGain_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setGain_, sizeof(struct __ns1__setGain_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setGain_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setGainRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setGainRequest(soap, "ns3:setGainRequest", &a->ns3__setGainRequest, ""))
				{	soap_flag_ns3__setGainRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setGain_(struct soap *soap, const struct __ns1__setGain_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setGain_(soap, tag?tag:"-ns1:setGain", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGain_ * SOAP_FMAC4 soap_get___ns1__setGain_(struct soap *soap, struct __ns1__setGain_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setGain_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setGain_ * SOAP_FMAC2 soap_instantiate___ns1__setGain_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setGain_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setGain_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setGain_);
		if (size)
			*size = sizeof(struct __ns1__setGain_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setGain_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setGain_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setGain_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setGain_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setGain_ %p -> %p\n", q, p));
	*(struct __ns1__setGain_*)p = *(struct __ns1__setGain_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getGain_(struct soap *soap, struct __ns1__getGain_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getGainRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getGain_(struct soap *soap, const struct __ns1__getGain_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getGainRequest(soap, &a->ns3__getGainRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getGain_(struct soap *soap, const char *tag, int id, const struct __ns1__getGain_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getGainRequest(soap, "ns3:getGainRequest", -1, &a->ns3__getGainRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGain_ * SOAP_FMAC4 soap_in___ns1__getGain_(struct soap *soap, const char *tag, struct __ns1__getGain_ *a, const char *type)
{
	size_t soap_flag_ns3__getGainRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getGain_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getGain_, sizeof(struct __ns1__getGain_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getGain_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getGainRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getGainRequest(soap, "ns3:getGainRequest", &a->ns3__getGainRequest, ""))
				{	soap_flag_ns3__getGainRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getGain_(struct soap *soap, const struct __ns1__getGain_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getGain_(soap, tag?tag:"-ns1:getGain", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGain_ * SOAP_FMAC4 soap_get___ns1__getGain_(struct soap *soap, struct __ns1__getGain_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getGain_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getGain_ * SOAP_FMAC2 soap_instantiate___ns1__getGain_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getGain_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getGain_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getGain_);
		if (size)
			*size = sizeof(struct __ns1__getGain_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getGain_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getGain_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getGain_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getGain_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getGain_ %p -> %p\n", q, p));
	*(struct __ns1__getGain_*)p = *(struct __ns1__getGain_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setCurrentMacro_(struct soap *soap, struct __ns1__setCurrentMacro_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setCurrentMacroRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setCurrentMacro_(struct soap *soap, const struct __ns1__setCurrentMacro_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setCurrentMacroRequest(soap, &a->ns3__setCurrentMacroRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setCurrentMacro_(struct soap *soap, const char *tag, int id, const struct __ns1__setCurrentMacro_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setCurrentMacroRequest(soap, "ns3:setCurrentMacroRequest", -1, &a->ns3__setCurrentMacroRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCurrentMacro_ * SOAP_FMAC4 soap_in___ns1__setCurrentMacro_(struct soap *soap, const char *tag, struct __ns1__setCurrentMacro_ *a, const char *type)
{
	size_t soap_flag_ns3__setCurrentMacroRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setCurrentMacro_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setCurrentMacro_, sizeof(struct __ns1__setCurrentMacro_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setCurrentMacro_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setCurrentMacroRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setCurrentMacroRequest(soap, "ns3:setCurrentMacroRequest", &a->ns3__setCurrentMacroRequest, ""))
				{	soap_flag_ns3__setCurrentMacroRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setCurrentMacro_(struct soap *soap, const struct __ns1__setCurrentMacro_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setCurrentMacro_(soap, tag?tag:"-ns1:setCurrentMacro", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCurrentMacro_ * SOAP_FMAC4 soap_get___ns1__setCurrentMacro_(struct soap *soap, struct __ns1__setCurrentMacro_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setCurrentMacro_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setCurrentMacro_ * SOAP_FMAC2 soap_instantiate___ns1__setCurrentMacro_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setCurrentMacro_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setCurrentMacro_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setCurrentMacro_);
		if (size)
			*size = sizeof(struct __ns1__setCurrentMacro_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setCurrentMacro_, n);
		if (size)
			*size = n * sizeof(struct __ns1__setCurrentMacro_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setCurrentMacro_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setCurrentMacro_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setCurrentMacro_ %p -> %p\n", q, p));
	*(struct __ns1__setCurrentMacro_*)p = *(struct __ns1__setCurrentMacro_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCurrentMacro_(struct soap *soap, struct __ns1__getCurrentMacro_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getCurrentMacroRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCurrentMacro_(struct soap *soap, const struct __ns1__getCurrentMacro_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getCurrentMacroRequest(soap, &a->ns3__getCurrentMacroRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCurrentMacro_(struct soap *soap, const char *tag, int id, const struct __ns1__getCurrentMacro_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getCurrentMacroRequest(soap, "ns3:getCurrentMacroRequest", -1, &a->ns3__getCurrentMacroRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCurrentMacro_ * SOAP_FMAC4 soap_in___ns1__getCurrentMacro_(struct soap *soap, const char *tag, struct __ns1__getCurrentMacro_ *a, const char *type)
{
	size_t soap_flag_ns3__getCurrentMacroRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCurrentMacro_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCurrentMacro_, sizeof(struct __ns1__getCurrentMacro_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCurrentMacro_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getCurrentMacroRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getCurrentMacroRequest(soap, "ns3:getCurrentMacroRequest", &a->ns3__getCurrentMacroRequest, ""))
				{	soap_flag_ns3__getCurrentMacroRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCurrentMacro_(struct soap *soap, const struct __ns1__getCurrentMacro_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCurrentMacro_(soap, tag?tag:"-ns1:getCurrentMacro", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCurrentMacro_ * SOAP_FMAC4 soap_get___ns1__getCurrentMacro_(struct soap *soap, struct __ns1__getCurrentMacro_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCurrentMacro_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCurrentMacro_ * SOAP_FMAC2 soap_instantiate___ns1__getCurrentMacro_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCurrentMacro_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCurrentMacro_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCurrentMacro_);
		if (size)
			*size = sizeof(struct __ns1__getCurrentMacro_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCurrentMacro_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCurrentMacro_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCurrentMacro_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCurrentMacro_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCurrentMacro_ %p -> %p\n", q, p));
	*(struct __ns1__getCurrentMacro_*)p = *(struct __ns1__getCurrentMacro_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listMacros_(struct soap *soap, struct __ns1__listMacros_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__listMacrosRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listMacros_(struct soap *soap, const struct __ns1__listMacros_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__listMacrosRequest(soap, &a->ns3__listMacrosRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listMacros_(struct soap *soap, const char *tag, int id, const struct __ns1__listMacros_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__listMacrosRequest(soap, "ns3:listMacrosRequest", -1, &a->ns3__listMacrosRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listMacros_ * SOAP_FMAC4 soap_in___ns1__listMacros_(struct soap *soap, const char *tag, struct __ns1__listMacros_ *a, const char *type)
{
	size_t soap_flag_ns3__listMacrosRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__listMacros_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listMacros_, sizeof(struct __ns1__listMacros_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listMacros_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__listMacrosRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__listMacrosRequest(soap, "ns3:listMacrosRequest", &a->ns3__listMacrosRequest, ""))
				{	soap_flag_ns3__listMacrosRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listMacros_(struct soap *soap, const struct __ns1__listMacros_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listMacros_(soap, tag?tag:"-ns1:listMacros", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listMacros_ * SOAP_FMAC4 soap_get___ns1__listMacros_(struct soap *soap, struct __ns1__listMacros_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listMacros_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listMacros_ * SOAP_FMAC2 soap_instantiate___ns1__listMacros_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listMacros_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listMacros_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listMacros_);
		if (size)
			*size = sizeof(struct __ns1__listMacros_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__listMacros_, n);
		if (size)
			*size = n * sizeof(struct __ns1__listMacros_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__listMacros_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listMacros_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listMacros_ %p -> %p\n", q, p));
	*(struct __ns1__listMacros_*)p = *(struct __ns1__listMacros_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__performSystemUpgrade(struct soap *soap, struct __ns1__performSystemUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__performSystemUpgradeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__performSystemUpgrade(struct soap *soap, const struct __ns1__performSystemUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__performSystemUpgradeRequest(soap, &a->ns3__performSystemUpgradeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__performSystemUpgrade(struct soap *soap, const char *tag, int id, const struct __ns1__performSystemUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__performSystemUpgradeRequest(soap, "ns3:performSystemUpgradeRequest", -1, &a->ns3__performSystemUpgradeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__performSystemUpgrade * SOAP_FMAC4 soap_in___ns1__performSystemUpgrade(struct soap *soap, const char *tag, struct __ns1__performSystemUpgrade *a, const char *type)
{
	size_t soap_flag_ns3__performSystemUpgradeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__performSystemUpgrade *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__performSystemUpgrade, sizeof(struct __ns1__performSystemUpgrade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__performSystemUpgrade(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__performSystemUpgradeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__performSystemUpgradeRequest(soap, "ns3:performSystemUpgradeRequest", &a->ns3__performSystemUpgradeRequest, ""))
				{	soap_flag_ns3__performSystemUpgradeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__performSystemUpgrade(struct soap *soap, const struct __ns1__performSystemUpgrade *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__performSystemUpgrade(soap, tag?tag:"-ns1:performSystemUpgrade", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__performSystemUpgrade * SOAP_FMAC4 soap_get___ns1__performSystemUpgrade(struct soap *soap, struct __ns1__performSystemUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__performSystemUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__performSystemUpgrade * SOAP_FMAC2 soap_instantiate___ns1__performSystemUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__performSystemUpgrade(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__performSystemUpgrade, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__performSystemUpgrade);
		if (size)
			*size = sizeof(struct __ns1__performSystemUpgrade);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__performSystemUpgrade, n);
		if (size)
			*size = n * sizeof(struct __ns1__performSystemUpgrade);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__performSystemUpgrade*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__performSystemUpgrade(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__performSystemUpgrade %p -> %p\n", q, p));
	*(struct __ns1__performSystemUpgrade*)p = *(struct __ns1__performSystemUpgrade*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enableAutoEqMode(struct soap *soap, struct __ns1__enableAutoEqMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__enableAutoEqModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enableAutoEqMode(struct soap *soap, const struct __ns1__enableAutoEqMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__enableAutoEqModeRequest(soap, &a->ns3__enableAutoEqModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enableAutoEqMode(struct soap *soap, const char *tag, int id, const struct __ns1__enableAutoEqMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__enableAutoEqModeRequest(soap, "ns3:enableAutoEqModeRequest", -1, &a->ns3__enableAutoEqModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableAutoEqMode * SOAP_FMAC4 soap_in___ns1__enableAutoEqMode(struct soap *soap, const char *tag, struct __ns1__enableAutoEqMode *a, const char *type)
{
	size_t soap_flag_ns3__enableAutoEqModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__enableAutoEqMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enableAutoEqMode, sizeof(struct __ns1__enableAutoEqMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enableAutoEqMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__enableAutoEqModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__enableAutoEqModeRequest(soap, "ns3:enableAutoEqModeRequest", &a->ns3__enableAutoEqModeRequest, ""))
				{	soap_flag_ns3__enableAutoEqModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enableAutoEqMode(struct soap *soap, const struct __ns1__enableAutoEqMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enableAutoEqMode(soap, tag?tag:"-ns1:enableAutoEqMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableAutoEqMode * SOAP_FMAC4 soap_get___ns1__enableAutoEqMode(struct soap *soap, struct __ns1__enableAutoEqMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enableAutoEqMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__enableAutoEqMode * SOAP_FMAC2 soap_instantiate___ns1__enableAutoEqMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enableAutoEqMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enableAutoEqMode, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__enableAutoEqMode);
		if (size)
			*size = sizeof(struct __ns1__enableAutoEqMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__enableAutoEqMode, n);
		if (size)
			*size = n * sizeof(struct __ns1__enableAutoEqMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__enableAutoEqMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enableAutoEqMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enableAutoEqMode %p -> %p\n", q, p));
	*(struct __ns1__enableAutoEqMode*)p = *(struct __ns1__enableAutoEqMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isAutoEqModeEnabled(struct soap *soap, struct __ns1__isAutoEqModeEnabled *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isAutoEqModeEnabledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isAutoEqModeEnabled(struct soap *soap, const struct __ns1__isAutoEqModeEnabled *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, &a->ns3__isAutoEqModeEnabledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isAutoEqModeEnabled(struct soap *soap, const char *tag, int id, const struct __ns1__isAutoEqModeEnabled *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, "ns3:isAutoEqModeEnabledRequest", -1, &a->ns3__isAutoEqModeEnabledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAutoEqModeEnabled * SOAP_FMAC4 soap_in___ns1__isAutoEqModeEnabled(struct soap *soap, const char *tag, struct __ns1__isAutoEqModeEnabled *a, const char *type)
{
	size_t soap_flag_ns3__isAutoEqModeEnabledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isAutoEqModeEnabled *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isAutoEqModeEnabled, sizeof(struct __ns1__isAutoEqModeEnabled), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isAutoEqModeEnabled(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isAutoEqModeEnabledRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, "ns3:isAutoEqModeEnabledRequest", &a->ns3__isAutoEqModeEnabledRequest, ""))
				{	soap_flag_ns3__isAutoEqModeEnabledRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isAutoEqModeEnabled(struct soap *soap, const struct __ns1__isAutoEqModeEnabled *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isAutoEqModeEnabled(soap, tag?tag:"-ns1:isAutoEqModeEnabled", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAutoEqModeEnabled * SOAP_FMAC4 soap_get___ns1__isAutoEqModeEnabled(struct soap *soap, struct __ns1__isAutoEqModeEnabled *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isAutoEqModeEnabled(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isAutoEqModeEnabled * SOAP_FMAC2 soap_instantiate___ns1__isAutoEqModeEnabled(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isAutoEqModeEnabled(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isAutoEqModeEnabled, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isAutoEqModeEnabled);
		if (size)
			*size = sizeof(struct __ns1__isAutoEqModeEnabled);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isAutoEqModeEnabled, n);
		if (size)
			*size = n * sizeof(struct __ns1__isAutoEqModeEnabled);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isAutoEqModeEnabled*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isAutoEqModeEnabled(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isAutoEqModeEnabled %p -> %p\n", q, p));
	*(struct __ns1__isAutoEqModeEnabled*)p = *(struct __ns1__isAutoEqModeEnabled*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTimeZone(struct soap *soap, struct __ns1__setTimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setTimeZoneRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTimeZone(struct soap *soap, const struct __ns1__setTimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setTimeZoneRequest(soap, &a->ns3__setTimeZoneRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTimeZone(struct soap *soap, const char *tag, int id, const struct __ns1__setTimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setTimeZoneRequest(soap, "ns3:setTimeZoneRequest", -1, &a->ns3__setTimeZoneRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTimeZone * SOAP_FMAC4 soap_in___ns1__setTimeZone(struct soap *soap, const char *tag, struct __ns1__setTimeZone *a, const char *type)
{
	size_t soap_flag_ns3__setTimeZoneRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setTimeZone *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTimeZone, sizeof(struct __ns1__setTimeZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTimeZone(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setTimeZoneRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setTimeZoneRequest(soap, "ns3:setTimeZoneRequest", &a->ns3__setTimeZoneRequest, ""))
				{	soap_flag_ns3__setTimeZoneRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTimeZone(struct soap *soap, const struct __ns1__setTimeZone *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTimeZone(soap, tag?tag:"-ns1:setTimeZone", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTimeZone * SOAP_FMAC4 soap_get___ns1__setTimeZone(struct soap *soap, struct __ns1__setTimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setTimeZone * SOAP_FMAC2 soap_instantiate___ns1__setTimeZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setTimeZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setTimeZone, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setTimeZone);
		if (size)
			*size = sizeof(struct __ns1__setTimeZone);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setTimeZone, n);
		if (size)
			*size = n * sizeof(struct __ns1__setTimeZone);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setTimeZone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setTimeZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setTimeZone %p -> %p\n", q, p));
	*(struct __ns1__setTimeZone*)p = *(struct __ns1__setTimeZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTimeZone(struct soap *soap, struct __ns1__getTimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getTimeZoneRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTimeZone(struct soap *soap, const struct __ns1__getTimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getTimeZoneRequest(soap, &a->ns3__getTimeZoneRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTimeZone(struct soap *soap, const char *tag, int id, const struct __ns1__getTimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getTimeZoneRequest(soap, "ns3:getTimeZoneRequest", -1, &a->ns3__getTimeZoneRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTimeZone * SOAP_FMAC4 soap_in___ns1__getTimeZone(struct soap *soap, const char *tag, struct __ns1__getTimeZone *a, const char *type)
{
	size_t soap_flag_ns3__getTimeZoneRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getTimeZone *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTimeZone, sizeof(struct __ns1__getTimeZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTimeZone(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getTimeZoneRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getTimeZoneRequest(soap, "ns3:getTimeZoneRequest", &a->ns3__getTimeZoneRequest, ""))
				{	soap_flag_ns3__getTimeZoneRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTimeZone(struct soap *soap, const struct __ns1__getTimeZone *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTimeZone(soap, tag?tag:"-ns1:getTimeZone", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTimeZone * SOAP_FMAC4 soap_get___ns1__getTimeZone(struct soap *soap, struct __ns1__getTimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTimeZone * SOAP_FMAC2 soap_instantiate___ns1__getTimeZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTimeZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTimeZone, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTimeZone);
		if (size)
			*size = sizeof(struct __ns1__getTimeZone);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTimeZone, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTimeZone);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTimeZone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTimeZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTimeZone %p -> %p\n", q, p));
	*(struct __ns1__getTimeZone*)p = *(struct __ns1__getTimeZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeviceAlarms(struct soap *soap, struct __ns1__getDeviceAlarms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getDeviceAlarmsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeviceAlarms(struct soap *soap, const struct __ns1__getDeviceAlarms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getDeviceAlarmsRequest(soap, &a->ns3__getDeviceAlarmsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeviceAlarms(struct soap *soap, const char *tag, int id, const struct __ns1__getDeviceAlarms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getDeviceAlarmsRequest(soap, "ns3:getDeviceAlarmsRequest", -1, &a->ns3__getDeviceAlarmsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceAlarms * SOAP_FMAC4 soap_in___ns1__getDeviceAlarms(struct soap *soap, const char *tag, struct __ns1__getDeviceAlarms *a, const char *type)
{
	size_t soap_flag_ns3__getDeviceAlarmsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getDeviceAlarms *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeviceAlarms, sizeof(struct __ns1__getDeviceAlarms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeviceAlarms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getDeviceAlarmsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getDeviceAlarmsRequest(soap, "ns3:getDeviceAlarmsRequest", &a->ns3__getDeviceAlarmsRequest, ""))
				{	soap_flag_ns3__getDeviceAlarmsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeviceAlarms(struct soap *soap, const struct __ns1__getDeviceAlarms *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeviceAlarms(soap, tag?tag:"-ns1:getDeviceAlarms", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceAlarms * SOAP_FMAC4 soap_get___ns1__getDeviceAlarms(struct soap *soap, struct __ns1__getDeviceAlarms *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeviceAlarms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDeviceAlarms * SOAP_FMAC2 soap_instantiate___ns1__getDeviceAlarms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDeviceAlarms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDeviceAlarms, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDeviceAlarms);
		if (size)
			*size = sizeof(struct __ns1__getDeviceAlarms);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDeviceAlarms, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDeviceAlarms);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDeviceAlarms*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDeviceAlarms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDeviceAlarms %p -> %p\n", q, p));
	*(struct __ns1__getDeviceAlarms*)p = *(struct __ns1__getDeviceAlarms*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeviceInfo(struct soap *soap, struct __ns1__getDeviceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getDeviceInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeviceInfo(struct soap *soap, const struct __ns1__getDeviceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getDeviceInfoRequest(soap, &a->ns3__getDeviceInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeviceInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getDeviceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getDeviceInfoRequest(soap, "ns3:getDeviceInfoRequest", -1, &a->ns3__getDeviceInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceInfo * SOAP_FMAC4 soap_in___ns1__getDeviceInfo(struct soap *soap, const char *tag, struct __ns1__getDeviceInfo *a, const char *type)
{
	size_t soap_flag_ns3__getDeviceInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getDeviceInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeviceInfo, sizeof(struct __ns1__getDeviceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeviceInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getDeviceInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getDeviceInfoRequest(soap, "ns3:getDeviceInfoRequest", &a->ns3__getDeviceInfoRequest, ""))
				{	soap_flag_ns3__getDeviceInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeviceInfo(struct soap *soap, const struct __ns1__getDeviceInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeviceInfo(soap, tag?tag:"-ns1:getDeviceInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceInfo * SOAP_FMAC4 soap_get___ns1__getDeviceInfo(struct soap *soap, struct __ns1__getDeviceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeviceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDeviceInfo * SOAP_FMAC2 soap_instantiate___ns1__getDeviceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDeviceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDeviceInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDeviceInfo);
		if (size)
			*size = sizeof(struct __ns1__getDeviceInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDeviceInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDeviceInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDeviceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDeviceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDeviceInfo %p -> %p\n", q, p));
	*(struct __ns1__getDeviceInfo*)p = *(struct __ns1__getDeviceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enableGlobalEq(struct soap *soap, struct __ns1__enableGlobalEq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__enableGlobalEqRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enableGlobalEq(struct soap *soap, const struct __ns1__enableGlobalEq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__enableGlobalEqRequest(soap, &a->ns3__enableGlobalEqRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enableGlobalEq(struct soap *soap, const char *tag, int id, const struct __ns1__enableGlobalEq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__enableGlobalEqRequest(soap, "ns3:enableGlobalEqRequest", -1, &a->ns3__enableGlobalEqRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableGlobalEq * SOAP_FMAC4 soap_in___ns1__enableGlobalEq(struct soap *soap, const char *tag, struct __ns1__enableGlobalEq *a, const char *type)
{
	size_t soap_flag_ns3__enableGlobalEqRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__enableGlobalEq *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enableGlobalEq, sizeof(struct __ns1__enableGlobalEq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enableGlobalEq(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__enableGlobalEqRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__enableGlobalEqRequest(soap, "ns3:enableGlobalEqRequest", &a->ns3__enableGlobalEqRequest, ""))
				{	soap_flag_ns3__enableGlobalEqRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enableGlobalEq(struct soap *soap, const struct __ns1__enableGlobalEq *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enableGlobalEq(soap, tag?tag:"-ns1:enableGlobalEq", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableGlobalEq * SOAP_FMAC4 soap_get___ns1__enableGlobalEq(struct soap *soap, struct __ns1__enableGlobalEq *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enableGlobalEq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__enableGlobalEq * SOAP_FMAC2 soap_instantiate___ns1__enableGlobalEq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enableGlobalEq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enableGlobalEq, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__enableGlobalEq);
		if (size)
			*size = sizeof(struct __ns1__enableGlobalEq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__enableGlobalEq, n);
		if (size)
			*size = n * sizeof(struct __ns1__enableGlobalEq);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__enableGlobalEq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enableGlobalEq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enableGlobalEq %p -> %p\n", q, p));
	*(struct __ns1__enableGlobalEq*)p = *(struct __ns1__enableGlobalEq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isGlobalEqEnabled(struct soap *soap, struct __ns1__isGlobalEqEnabled *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isGlobalEqEnabledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isGlobalEqEnabled(struct soap *soap, const struct __ns1__isGlobalEqEnabled *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isGlobalEqEnabledRequest(soap, &a->ns3__isGlobalEqEnabledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isGlobalEqEnabled(struct soap *soap, const char *tag, int id, const struct __ns1__isGlobalEqEnabled *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isGlobalEqEnabledRequest(soap, "ns3:isGlobalEqEnabledRequest", -1, &a->ns3__isGlobalEqEnabledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isGlobalEqEnabled * SOAP_FMAC4 soap_in___ns1__isGlobalEqEnabled(struct soap *soap, const char *tag, struct __ns1__isGlobalEqEnabled *a, const char *type)
{
	size_t soap_flag_ns3__isGlobalEqEnabledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isGlobalEqEnabled *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isGlobalEqEnabled, sizeof(struct __ns1__isGlobalEqEnabled), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isGlobalEqEnabled(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isGlobalEqEnabledRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isGlobalEqEnabledRequest(soap, "ns3:isGlobalEqEnabledRequest", &a->ns3__isGlobalEqEnabledRequest, ""))
				{	soap_flag_ns3__isGlobalEqEnabledRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isGlobalEqEnabled(struct soap *soap, const struct __ns1__isGlobalEqEnabled *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isGlobalEqEnabled(soap, tag?tag:"-ns1:isGlobalEqEnabled", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isGlobalEqEnabled * SOAP_FMAC4 soap_get___ns1__isGlobalEqEnabled(struct soap *soap, struct __ns1__isGlobalEqEnabled *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isGlobalEqEnabled(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isGlobalEqEnabled * SOAP_FMAC2 soap_instantiate___ns1__isGlobalEqEnabled(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isGlobalEqEnabled(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isGlobalEqEnabled, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isGlobalEqEnabled);
		if (size)
			*size = sizeof(struct __ns1__isGlobalEqEnabled);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isGlobalEqEnabled, n);
		if (size)
			*size = n * sizeof(struct __ns1__isGlobalEqEnabled);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isGlobalEqEnabled*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isGlobalEqEnabled(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isGlobalEqEnabled %p -> %p\n", q, p));
	*(struct __ns1__isGlobalEqEnabled*)p = *(struct __ns1__isGlobalEqEnabled*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enableBassManagement(struct soap *soap, struct __ns1__enableBassManagement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__enableBassManagementRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enableBassManagement(struct soap *soap, const struct __ns1__enableBassManagement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__enableBassManagementRequest(soap, &a->ns3__enableBassManagementRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enableBassManagement(struct soap *soap, const char *tag, int id, const struct __ns1__enableBassManagement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__enableBassManagementRequest(soap, "ns3:enableBassManagementRequest", -1, &a->ns3__enableBassManagementRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableBassManagement * SOAP_FMAC4 soap_in___ns1__enableBassManagement(struct soap *soap, const char *tag, struct __ns1__enableBassManagement *a, const char *type)
{
	size_t soap_flag_ns3__enableBassManagementRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__enableBassManagement *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enableBassManagement, sizeof(struct __ns1__enableBassManagement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enableBassManagement(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__enableBassManagementRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__enableBassManagementRequest(soap, "ns3:enableBassManagementRequest", &a->ns3__enableBassManagementRequest, ""))
				{	soap_flag_ns3__enableBassManagementRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enableBassManagement(struct soap *soap, const struct __ns1__enableBassManagement *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enableBassManagement(soap, tag?tag:"-ns1:enableBassManagement", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enableBassManagement * SOAP_FMAC4 soap_get___ns1__enableBassManagement(struct soap *soap, struct __ns1__enableBassManagement *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enableBassManagement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__enableBassManagement * SOAP_FMAC2 soap_instantiate___ns1__enableBassManagement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enableBassManagement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enableBassManagement, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__enableBassManagement);
		if (size)
			*size = sizeof(struct __ns1__enableBassManagement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__enableBassManagement, n);
		if (size)
			*size = n * sizeof(struct __ns1__enableBassManagement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__enableBassManagement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enableBassManagement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enableBassManagement %p -> %p\n", q, p));
	*(struct __ns1__enableBassManagement*)p = *(struct __ns1__enableBassManagement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isBassManagementEnabled(struct soap *soap, struct __ns1__isBassManagementEnabled *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isBassManagementEnabledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isBassManagementEnabled(struct soap *soap, const struct __ns1__isBassManagementEnabled *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isBassManagementEnabledRequest(soap, &a->ns3__isBassManagementEnabledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isBassManagementEnabled(struct soap *soap, const char *tag, int id, const struct __ns1__isBassManagementEnabled *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isBassManagementEnabledRequest(soap, "ns3:isBassManagementEnabledRequest", -1, &a->ns3__isBassManagementEnabledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isBassManagementEnabled * SOAP_FMAC4 soap_in___ns1__isBassManagementEnabled(struct soap *soap, const char *tag, struct __ns1__isBassManagementEnabled *a, const char *type)
{
	size_t soap_flag_ns3__isBassManagementEnabledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isBassManagementEnabled *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isBassManagementEnabled, sizeof(struct __ns1__isBassManagementEnabled), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isBassManagementEnabled(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isBassManagementEnabledRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isBassManagementEnabledRequest(soap, "ns3:isBassManagementEnabledRequest", &a->ns3__isBassManagementEnabledRequest, ""))
				{	soap_flag_ns3__isBassManagementEnabledRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isBassManagementEnabled(struct soap *soap, const struct __ns1__isBassManagementEnabled *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isBassManagementEnabled(soap, tag?tag:"-ns1:isBassManagementEnabled", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isBassManagementEnabled * SOAP_FMAC4 soap_get___ns1__isBassManagementEnabled(struct soap *soap, struct __ns1__isBassManagementEnabled *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isBassManagementEnabled(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isBassManagementEnabled * SOAP_FMAC2 soap_instantiate___ns1__isBassManagementEnabled(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isBassManagementEnabled(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isBassManagementEnabled, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isBassManagementEnabled);
		if (size)
			*size = sizeof(struct __ns1__isBassManagementEnabled);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isBassManagementEnabled, n);
		if (size)
			*size = n * sizeof(struct __ns1__isBassManagementEnabled);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isBassManagementEnabled*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isBassManagementEnabled(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isBassManagementEnabled %p -> %p\n", q, p));
	*(struct __ns1__isBassManagementEnabled*)p = *(struct __ns1__isBassManagementEnabled*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTestSignalMode(struct soap *soap, struct __ns1__setTestSignalMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setTestSignalModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTestSignalMode(struct soap *soap, const struct __ns1__setTestSignalMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setTestSignalModeRequest(soap, &a->ns3__setTestSignalModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTestSignalMode(struct soap *soap, const char *tag, int id, const struct __ns1__setTestSignalMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setTestSignalModeRequest(soap, "ns3:setTestSignalModeRequest", -1, &a->ns3__setTestSignalModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalMode * SOAP_FMAC4 soap_in___ns1__setTestSignalMode(struct soap *soap, const char *tag, struct __ns1__setTestSignalMode *a, const char *type)
{
	size_t soap_flag_ns3__setTestSignalModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setTestSignalMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTestSignalMode, sizeof(struct __ns1__setTestSignalMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTestSignalMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setTestSignalModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setTestSignalModeRequest(soap, "ns3:setTestSignalModeRequest", &a->ns3__setTestSignalModeRequest, ""))
				{	soap_flag_ns3__setTestSignalModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTestSignalMode(struct soap *soap, const struct __ns1__setTestSignalMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTestSignalMode(soap, tag?tag:"-ns1:setTestSignalMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalMode * SOAP_FMAC4 soap_get___ns1__setTestSignalMode(struct soap *soap, struct __ns1__setTestSignalMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTestSignalMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setTestSignalMode * SOAP_FMAC2 soap_instantiate___ns1__setTestSignalMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setTestSignalMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setTestSignalMode, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setTestSignalMode);
		if (size)
			*size = sizeof(struct __ns1__setTestSignalMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setTestSignalMode, n);
		if (size)
			*size = n * sizeof(struct __ns1__setTestSignalMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setTestSignalMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setTestSignalMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setTestSignalMode %p -> %p\n", q, p));
	*(struct __ns1__setTestSignalMode*)p = *(struct __ns1__setTestSignalMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTestSignalMode(struct soap *soap, struct __ns1__getTestSignalMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getTestSignalModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTestSignalMode(struct soap *soap, const struct __ns1__getTestSignalMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getTestSignalModeRequest(soap, &a->ns3__getTestSignalModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTestSignalMode(struct soap *soap, const char *tag, int id, const struct __ns1__getTestSignalMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getTestSignalModeRequest(soap, "ns3:getTestSignalModeRequest", -1, &a->ns3__getTestSignalModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalMode * SOAP_FMAC4 soap_in___ns1__getTestSignalMode(struct soap *soap, const char *tag, struct __ns1__getTestSignalMode *a, const char *type)
{
	size_t soap_flag_ns3__getTestSignalModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getTestSignalMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTestSignalMode, sizeof(struct __ns1__getTestSignalMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTestSignalMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getTestSignalModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getTestSignalModeRequest(soap, "ns3:getTestSignalModeRequest", &a->ns3__getTestSignalModeRequest, ""))
				{	soap_flag_ns3__getTestSignalModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTestSignalMode(struct soap *soap, const struct __ns1__getTestSignalMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTestSignalMode(soap, tag?tag:"-ns1:getTestSignalMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalMode * SOAP_FMAC4 soap_get___ns1__getTestSignalMode(struct soap *soap, struct __ns1__getTestSignalMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTestSignalMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTestSignalMode * SOAP_FMAC2 soap_instantiate___ns1__getTestSignalMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTestSignalMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTestSignalMode, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTestSignalMode);
		if (size)
			*size = sizeof(struct __ns1__getTestSignalMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTestSignalMode, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTestSignalMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTestSignalMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTestSignalMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTestSignalMode %p -> %p\n", q, p));
	*(struct __ns1__getTestSignalMode*)p = *(struct __ns1__getTestSignalMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTestSignalOutput(struct soap *soap, struct __ns1__setTestSignalOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setTestSignalOutputRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTestSignalOutput(struct soap *soap, const struct __ns1__setTestSignalOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setTestSignalOutputRequest(soap, &a->ns3__setTestSignalOutputRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTestSignalOutput(struct soap *soap, const char *tag, int id, const struct __ns1__setTestSignalOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setTestSignalOutputRequest(soap, "ns3:setTestSignalOutputRequest", -1, &a->ns3__setTestSignalOutputRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalOutput * SOAP_FMAC4 soap_in___ns1__setTestSignalOutput(struct soap *soap, const char *tag, struct __ns1__setTestSignalOutput *a, const char *type)
{
	size_t soap_flag_ns3__setTestSignalOutputRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setTestSignalOutput *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTestSignalOutput, sizeof(struct __ns1__setTestSignalOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTestSignalOutput(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setTestSignalOutputRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setTestSignalOutputRequest(soap, "ns3:setTestSignalOutputRequest", &a->ns3__setTestSignalOutputRequest, ""))
				{	soap_flag_ns3__setTestSignalOutputRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTestSignalOutput(struct soap *soap, const struct __ns1__setTestSignalOutput *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTestSignalOutput(soap, tag?tag:"-ns1:setTestSignalOutput", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTestSignalOutput * SOAP_FMAC4 soap_get___ns1__setTestSignalOutput(struct soap *soap, struct __ns1__setTestSignalOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTestSignalOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setTestSignalOutput * SOAP_FMAC2 soap_instantiate___ns1__setTestSignalOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setTestSignalOutput(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setTestSignalOutput, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setTestSignalOutput);
		if (size)
			*size = sizeof(struct __ns1__setTestSignalOutput);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setTestSignalOutput, n);
		if (size)
			*size = n * sizeof(struct __ns1__setTestSignalOutput);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setTestSignalOutput*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setTestSignalOutput(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setTestSignalOutput %p -> %p\n", q, p));
	*(struct __ns1__setTestSignalOutput*)p = *(struct __ns1__setTestSignalOutput*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTestSignalOutput(struct soap *soap, struct __ns1__getTestSignalOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getTestSignalOutputRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTestSignalOutput(struct soap *soap, const struct __ns1__getTestSignalOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getTestSignalOutputRequest(soap, &a->ns3__getTestSignalOutputRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTestSignalOutput(struct soap *soap, const char *tag, int id, const struct __ns1__getTestSignalOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getTestSignalOutputRequest(soap, "ns3:getTestSignalOutputRequest", -1, &a->ns3__getTestSignalOutputRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalOutput * SOAP_FMAC4 soap_in___ns1__getTestSignalOutput(struct soap *soap, const char *tag, struct __ns1__getTestSignalOutput *a, const char *type)
{
	size_t soap_flag_ns3__getTestSignalOutputRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getTestSignalOutput *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTestSignalOutput, sizeof(struct __ns1__getTestSignalOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTestSignalOutput(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getTestSignalOutputRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getTestSignalOutputRequest(soap, "ns3:getTestSignalOutputRequest", &a->ns3__getTestSignalOutputRequest, ""))
				{	soap_flag_ns3__getTestSignalOutputRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTestSignalOutput(struct soap *soap, const struct __ns1__getTestSignalOutput *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTestSignalOutput(soap, tag?tag:"-ns1:getTestSignalOutput", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTestSignalOutput * SOAP_FMAC4 soap_get___ns1__getTestSignalOutput(struct soap *soap, struct __ns1__getTestSignalOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTestSignalOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTestSignalOutput * SOAP_FMAC2 soap_instantiate___ns1__getTestSignalOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTestSignalOutput(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTestSignalOutput, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTestSignalOutput);
		if (size)
			*size = sizeof(struct __ns1__getTestSignalOutput);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTestSignalOutput, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTestSignalOutput);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTestSignalOutput*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTestSignalOutput(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTestSignalOutput %p -> %p\n", q, p));
	*(struct __ns1__getTestSignalOutput*)p = *(struct __ns1__getTestSignalOutput*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setAtmosConfig(struct soap *soap, struct __ns1__setAtmosConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setAtmosConfigRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setAtmosConfig(struct soap *soap, const struct __ns1__setAtmosConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setAtmosConfigRequest(soap, &a->ns3__setAtmosConfigRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setAtmosConfig(struct soap *soap, const char *tag, int id, const struct __ns1__setAtmosConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setAtmosConfigRequest(soap, "ns3:setAtmosConfigRequest", -1, &a->ns3__setAtmosConfigRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAtmosConfig * SOAP_FMAC4 soap_in___ns1__setAtmosConfig(struct soap *soap, const char *tag, struct __ns1__setAtmosConfig *a, const char *type)
{
	size_t soap_flag_ns3__setAtmosConfigRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setAtmosConfig *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setAtmosConfig, sizeof(struct __ns1__setAtmosConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setAtmosConfig(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setAtmosConfigRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setAtmosConfigRequest(soap, "ns3:setAtmosConfigRequest", &a->ns3__setAtmosConfigRequest, ""))
				{	soap_flag_ns3__setAtmosConfigRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setAtmosConfig(struct soap *soap, const struct __ns1__setAtmosConfig *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setAtmosConfig(soap, tag?tag:"-ns1:setAtmosConfig", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAtmosConfig * SOAP_FMAC4 soap_get___ns1__setAtmosConfig(struct soap *soap, struct __ns1__setAtmosConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setAtmosConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setAtmosConfig * SOAP_FMAC2 soap_instantiate___ns1__setAtmosConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setAtmosConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setAtmosConfig, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setAtmosConfig);
		if (size)
			*size = sizeof(struct __ns1__setAtmosConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setAtmosConfig, n);
		if (size)
			*size = n * sizeof(struct __ns1__setAtmosConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setAtmosConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setAtmosConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setAtmosConfig %p -> %p\n", q, p));
	*(struct __ns1__setAtmosConfig*)p = *(struct __ns1__setAtmosConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAtmosConfig(struct soap *soap, struct __ns1__getAtmosConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getAtmosConfigRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAtmosConfig(struct soap *soap, const struct __ns1__getAtmosConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getAtmosConfigRequest(soap, &a->ns3__getAtmosConfigRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAtmosConfig(struct soap *soap, const char *tag, int id, const struct __ns1__getAtmosConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getAtmosConfigRequest(soap, "ns3:getAtmosConfigRequest", -1, &a->ns3__getAtmosConfigRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfig * SOAP_FMAC4 soap_in___ns1__getAtmosConfig(struct soap *soap, const char *tag, struct __ns1__getAtmosConfig *a, const char *type)
{
	size_t soap_flag_ns3__getAtmosConfigRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAtmosConfig *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAtmosConfig, sizeof(struct __ns1__getAtmosConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAtmosConfig(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getAtmosConfigRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getAtmosConfigRequest(soap, "ns3:getAtmosConfigRequest", &a->ns3__getAtmosConfigRequest, ""))
				{	soap_flag_ns3__getAtmosConfigRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAtmosConfig(struct soap *soap, const struct __ns1__getAtmosConfig *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAtmosConfig(soap, tag?tag:"-ns1:getAtmosConfig", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfig * SOAP_FMAC4 soap_get___ns1__getAtmosConfig(struct soap *soap, struct __ns1__getAtmosConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAtmosConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAtmosConfig * SOAP_FMAC2 soap_instantiate___ns1__getAtmosConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAtmosConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAtmosConfig, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAtmosConfig);
		if (size)
			*size = sizeof(struct __ns1__getAtmosConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAtmosConfig, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAtmosConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAtmosConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAtmosConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAtmosConfig %p -> %p\n", q, p));
	*(struct __ns1__getAtmosConfig*)p = *(struct __ns1__getAtmosConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAtmosConfigInfo(struct soap *soap, struct __ns1__getAtmosConfigInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getAtmosConfigInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAtmosConfigInfo(struct soap *soap, const struct __ns1__getAtmosConfigInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getAtmosConfigInfoRequest(soap, &a->ns3__getAtmosConfigInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAtmosConfigInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getAtmosConfigInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getAtmosConfigInfoRequest(soap, "ns3:getAtmosConfigInfoRequest", -1, &a->ns3__getAtmosConfigInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfigInfo * SOAP_FMAC4 soap_in___ns1__getAtmosConfigInfo(struct soap *soap, const char *tag, struct __ns1__getAtmosConfigInfo *a, const char *type)
{
	size_t soap_flag_ns3__getAtmosConfigInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAtmosConfigInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAtmosConfigInfo, sizeof(struct __ns1__getAtmosConfigInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAtmosConfigInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getAtmosConfigInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getAtmosConfigInfoRequest(soap, "ns3:getAtmosConfigInfoRequest", &a->ns3__getAtmosConfigInfoRequest, ""))
				{	soap_flag_ns3__getAtmosConfigInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAtmosConfigInfo(struct soap *soap, const struct __ns1__getAtmosConfigInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAtmosConfigInfo(soap, tag?tag:"-ns1:getAtmosConfigInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAtmosConfigInfo * SOAP_FMAC4 soap_get___ns1__getAtmosConfigInfo(struct soap *soap, struct __ns1__getAtmosConfigInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAtmosConfigInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAtmosConfigInfo * SOAP_FMAC2 soap_instantiate___ns1__getAtmosConfigInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAtmosConfigInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAtmosConfigInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAtmosConfigInfo);
		if (size)
			*size = sizeof(struct __ns1__getAtmosConfigInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAtmosConfigInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAtmosConfigInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAtmosConfigInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAtmosConfigInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAtmosConfigInfo %p -> %p\n", q, p));
	*(struct __ns1__getAtmosConfigInfo*)p = *(struct __ns1__getAtmosConfigInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAudioStreamInfo(struct soap *soap, struct __ns1__getAudioStreamInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getAudioStreamInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAudioStreamInfo(struct soap *soap, const struct __ns1__getAudioStreamInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getAudioStreamInfoRequest(soap, &a->ns3__getAudioStreamInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAudioStreamInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getAudioStreamInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getAudioStreamInfoRequest(soap, "ns3:getAudioStreamInfoRequest", -1, &a->ns3__getAudioStreamInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAudioStreamInfo * SOAP_FMAC4 soap_in___ns1__getAudioStreamInfo(struct soap *soap, const char *tag, struct __ns1__getAudioStreamInfo *a, const char *type)
{
	size_t soap_flag_ns3__getAudioStreamInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAudioStreamInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAudioStreamInfo, sizeof(struct __ns1__getAudioStreamInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAudioStreamInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getAudioStreamInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getAudioStreamInfoRequest(soap, "ns3:getAudioStreamInfoRequest", &a->ns3__getAudioStreamInfoRequest, ""))
				{	soap_flag_ns3__getAudioStreamInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAudioStreamInfo(struct soap *soap, const struct __ns1__getAudioStreamInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAudioStreamInfo(soap, tag?tag:"-ns1:getAudioStreamInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAudioStreamInfo * SOAP_FMAC4 soap_get___ns1__getAudioStreamInfo(struct soap *soap, struct __ns1__getAudioStreamInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAudioStreamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAudioStreamInfo * SOAP_FMAC2 soap_instantiate___ns1__getAudioStreamInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAudioStreamInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAudioStreamInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAudioStreamInfo);
		if (size)
			*size = sizeof(struct __ns1__getAudioStreamInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAudioStreamInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAudioStreamInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAudioStreamInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAudioStreamInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAudioStreamInfo %p -> %p\n", q, p));
	*(struct __ns1__getAudioStreamInfo*)p = *(struct __ns1__getAudioStreamInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isAtmosContent(struct soap *soap, struct __ns1__isAtmosContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__isAtmosContentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isAtmosContent(struct soap *soap, const struct __ns1__isAtmosContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__isAtmosContentRequest(soap, &a->ns3__isAtmosContentRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isAtmosContent(struct soap *soap, const char *tag, int id, const struct __ns1__isAtmosContent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__isAtmosContentRequest(soap, "ns3:isAtmosContentRequest", -1, &a->ns3__isAtmosContentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAtmosContent * SOAP_FMAC4 soap_in___ns1__isAtmosContent(struct soap *soap, const char *tag, struct __ns1__isAtmosContent *a, const char *type)
{
	size_t soap_flag_ns3__isAtmosContentRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__isAtmosContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isAtmosContent, sizeof(struct __ns1__isAtmosContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isAtmosContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__isAtmosContentRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__isAtmosContentRequest(soap, "ns3:isAtmosContentRequest", &a->ns3__isAtmosContentRequest, ""))
				{	soap_flag_ns3__isAtmosContentRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isAtmosContent(struct soap *soap, const struct __ns1__isAtmosContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isAtmosContent(soap, tag?tag:"-ns1:isAtmosContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAtmosContent * SOAP_FMAC4 soap_get___ns1__isAtmosContent(struct soap *soap, struct __ns1__isAtmosContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isAtmosContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isAtmosContent * SOAP_FMAC2 soap_instantiate___ns1__isAtmosContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isAtmosContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isAtmosContent, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isAtmosContent);
		if (size)
			*size = sizeof(struct __ns1__isAtmosContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__isAtmosContent, n);
		if (size)
			*size = n * sizeof(struct __ns1__isAtmosContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__isAtmosContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isAtmosContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isAtmosContent %p -> %p\n", q, p));
	*(struct __ns1__isAtmosContent*)p = *(struct __ns1__isAtmosContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setMute(struct soap *soap, struct __ns1__setMute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setMuteRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setMute(struct soap *soap, const struct __ns1__setMute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setMuteRequest(soap, &a->ns3__setMuteRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setMute(struct soap *soap, const char *tag, int id, const struct __ns1__setMute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setMuteRequest(soap, "ns3:setMuteRequest", -1, &a->ns3__setMuteRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setMute * SOAP_FMAC4 soap_in___ns1__setMute(struct soap *soap, const char *tag, struct __ns1__setMute *a, const char *type)
{
	size_t soap_flag_ns3__setMuteRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setMute *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setMute, sizeof(struct __ns1__setMute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setMute(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setMuteRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setMuteRequest(soap, "ns3:setMuteRequest", &a->ns3__setMuteRequest, ""))
				{	soap_flag_ns3__setMuteRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setMute(struct soap *soap, const struct __ns1__setMute *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setMute(soap, tag?tag:"-ns1:setMute", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setMute * SOAP_FMAC4 soap_get___ns1__setMute(struct soap *soap, struct __ns1__setMute *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setMute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setMute * SOAP_FMAC2 soap_instantiate___ns1__setMute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setMute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setMute, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setMute);
		if (size)
			*size = sizeof(struct __ns1__setMute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setMute, n);
		if (size)
			*size = n * sizeof(struct __ns1__setMute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setMute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setMute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setMute %p -> %p\n", q, p));
	*(struct __ns1__setMute*)p = *(struct __ns1__setMute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMute(struct soap *soap, struct __ns1__getMute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getMuteRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMute(struct soap *soap, const struct __ns1__getMute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getMuteRequest(soap, &a->ns3__getMuteRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMute(struct soap *soap, const char *tag, int id, const struct __ns1__getMute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getMuteRequest(soap, "ns3:getMuteRequest", -1, &a->ns3__getMuteRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMute * SOAP_FMAC4 soap_in___ns1__getMute(struct soap *soap, const char *tag, struct __ns1__getMute *a, const char *type)
{
	size_t soap_flag_ns3__getMuteRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMute *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMute, sizeof(struct __ns1__getMute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMute(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getMuteRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getMuteRequest(soap, "ns3:getMuteRequest", &a->ns3__getMuteRequest, ""))
				{	soap_flag_ns3__getMuteRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMute(struct soap *soap, const struct __ns1__getMute *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMute(soap, tag?tag:"-ns1:getMute", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMute * SOAP_FMAC4 soap_get___ns1__getMute(struct soap *soap, struct __ns1__getMute *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMute * SOAP_FMAC2 soap_instantiate___ns1__getMute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMute, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMute);
		if (size)
			*size = sizeof(struct __ns1__getMute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getMute, n);
		if (size)
			*size = n * sizeof(struct __ns1__getMute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getMute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMute %p -> %p\n", q, p));
	*(struct __ns1__getMute*)p = *(struct __ns1__getMute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setGain(struct soap *soap, struct __ns1__setGain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setGainRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setGain(struct soap *soap, const struct __ns1__setGain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setGainRequest(soap, &a->ns3__setGainRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setGain(struct soap *soap, const char *tag, int id, const struct __ns1__setGain *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setGainRequest(soap, "ns3:setGainRequest", -1, &a->ns3__setGainRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGain * SOAP_FMAC4 soap_in___ns1__setGain(struct soap *soap, const char *tag, struct __ns1__setGain *a, const char *type)
{
	size_t soap_flag_ns3__setGainRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setGain *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setGain, sizeof(struct __ns1__setGain), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setGain(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setGainRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setGainRequest(soap, "ns3:setGainRequest", &a->ns3__setGainRequest, ""))
				{	soap_flag_ns3__setGainRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setGain(struct soap *soap, const struct __ns1__setGain *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setGain(soap, tag?tag:"-ns1:setGain", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGain * SOAP_FMAC4 soap_get___ns1__setGain(struct soap *soap, struct __ns1__setGain *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setGain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setGain * SOAP_FMAC2 soap_instantiate___ns1__setGain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setGain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setGain, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setGain);
		if (size)
			*size = sizeof(struct __ns1__setGain);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setGain, n);
		if (size)
			*size = n * sizeof(struct __ns1__setGain);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setGain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setGain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setGain %p -> %p\n", q, p));
	*(struct __ns1__setGain*)p = *(struct __ns1__setGain*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getGain(struct soap *soap, struct __ns1__getGain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getGainRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getGain(struct soap *soap, const struct __ns1__getGain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getGainRequest(soap, &a->ns3__getGainRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getGain(struct soap *soap, const char *tag, int id, const struct __ns1__getGain *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getGainRequest(soap, "ns3:getGainRequest", -1, &a->ns3__getGainRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGain * SOAP_FMAC4 soap_in___ns1__getGain(struct soap *soap, const char *tag, struct __ns1__getGain *a, const char *type)
{
	size_t soap_flag_ns3__getGainRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getGain *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getGain, sizeof(struct __ns1__getGain), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getGain(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getGainRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getGainRequest(soap, "ns3:getGainRequest", &a->ns3__getGainRequest, ""))
				{	soap_flag_ns3__getGainRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getGain(struct soap *soap, const struct __ns1__getGain *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getGain(soap, tag?tag:"-ns1:getGain", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGain * SOAP_FMAC4 soap_get___ns1__getGain(struct soap *soap, struct __ns1__getGain *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getGain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getGain * SOAP_FMAC2 soap_instantiate___ns1__getGain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getGain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getGain, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getGain);
		if (size)
			*size = sizeof(struct __ns1__getGain);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getGain, n);
		if (size)
			*size = n * sizeof(struct __ns1__getGain);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getGain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getGain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getGain %p -> %p\n", q, p));
	*(struct __ns1__getGain*)p = *(struct __ns1__getGain*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setCurrentMacro(struct soap *soap, struct __ns1__setCurrentMacro *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__setCurrentMacroRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setCurrentMacro(struct soap *soap, const struct __ns1__setCurrentMacro *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__setCurrentMacroRequest(soap, &a->ns3__setCurrentMacroRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setCurrentMacro(struct soap *soap, const char *tag, int id, const struct __ns1__setCurrentMacro *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__setCurrentMacroRequest(soap, "ns3:setCurrentMacroRequest", -1, &a->ns3__setCurrentMacroRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCurrentMacro * SOAP_FMAC4 soap_in___ns1__setCurrentMacro(struct soap *soap, const char *tag, struct __ns1__setCurrentMacro *a, const char *type)
{
	size_t soap_flag_ns3__setCurrentMacroRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setCurrentMacro *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setCurrentMacro, sizeof(struct __ns1__setCurrentMacro), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setCurrentMacro(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__setCurrentMacroRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__setCurrentMacroRequest(soap, "ns3:setCurrentMacroRequest", &a->ns3__setCurrentMacroRequest, ""))
				{	soap_flag_ns3__setCurrentMacroRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setCurrentMacro(struct soap *soap, const struct __ns1__setCurrentMacro *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setCurrentMacro(soap, tag?tag:"-ns1:setCurrentMacro", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCurrentMacro * SOAP_FMAC4 soap_get___ns1__setCurrentMacro(struct soap *soap, struct __ns1__setCurrentMacro *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setCurrentMacro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setCurrentMacro * SOAP_FMAC2 soap_instantiate___ns1__setCurrentMacro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setCurrentMacro(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setCurrentMacro, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setCurrentMacro);
		if (size)
			*size = sizeof(struct __ns1__setCurrentMacro);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setCurrentMacro, n);
		if (size)
			*size = n * sizeof(struct __ns1__setCurrentMacro);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setCurrentMacro*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setCurrentMacro(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setCurrentMacro %p -> %p\n", q, p));
	*(struct __ns1__setCurrentMacro*)p = *(struct __ns1__setCurrentMacro*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCurrentMacro(struct soap *soap, struct __ns1__getCurrentMacro *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__getCurrentMacroRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCurrentMacro(struct soap *soap, const struct __ns1__getCurrentMacro *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__getCurrentMacroRequest(soap, &a->ns3__getCurrentMacroRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCurrentMacro(struct soap *soap, const char *tag, int id, const struct __ns1__getCurrentMacro *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__getCurrentMacroRequest(soap, "ns3:getCurrentMacroRequest", -1, &a->ns3__getCurrentMacroRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCurrentMacro * SOAP_FMAC4 soap_in___ns1__getCurrentMacro(struct soap *soap, const char *tag, struct __ns1__getCurrentMacro *a, const char *type)
{
	size_t soap_flag_ns3__getCurrentMacroRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCurrentMacro *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCurrentMacro, sizeof(struct __ns1__getCurrentMacro), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCurrentMacro(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__getCurrentMacroRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__getCurrentMacroRequest(soap, "ns3:getCurrentMacroRequest", &a->ns3__getCurrentMacroRequest, ""))
				{	soap_flag_ns3__getCurrentMacroRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCurrentMacro(struct soap *soap, const struct __ns1__getCurrentMacro *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCurrentMacro(soap, tag?tag:"-ns1:getCurrentMacro", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCurrentMacro * SOAP_FMAC4 soap_get___ns1__getCurrentMacro(struct soap *soap, struct __ns1__getCurrentMacro *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCurrentMacro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCurrentMacro * SOAP_FMAC2 soap_instantiate___ns1__getCurrentMacro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCurrentMacro(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCurrentMacro, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCurrentMacro);
		if (size)
			*size = sizeof(struct __ns1__getCurrentMacro);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCurrentMacro, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCurrentMacro);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCurrentMacro*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCurrentMacro(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCurrentMacro %p -> %p\n", q, p));
	*(struct __ns1__getCurrentMacro*)p = *(struct __ns1__getCurrentMacro*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listMacros(struct soap *soap, struct __ns1__listMacros *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__listMacrosRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listMacros(struct soap *soap, const struct __ns1__listMacros *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__listMacrosRequest(soap, &a->ns3__listMacrosRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listMacros(struct soap *soap, const char *tag, int id, const struct __ns1__listMacros *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__listMacrosRequest(soap, "ns3:listMacrosRequest", -1, &a->ns3__listMacrosRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listMacros * SOAP_FMAC4 soap_in___ns1__listMacros(struct soap *soap, const char *tag, struct __ns1__listMacros *a, const char *type)
{
	size_t soap_flag_ns3__listMacrosRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__listMacros *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listMacros, sizeof(struct __ns1__listMacros), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listMacros(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__listMacrosRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__listMacrosRequest(soap, "ns3:listMacrosRequest", &a->ns3__listMacrosRequest, ""))
				{	soap_flag_ns3__listMacrosRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listMacros(struct soap *soap, const struct __ns1__listMacros *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listMacros(soap, tag?tag:"-ns1:listMacros", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listMacros * SOAP_FMAC4 soap_get___ns1__listMacros(struct soap *soap, struct __ns1__listMacros *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listMacros(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listMacros * SOAP_FMAC2 soap_instantiate___ns1__listMacros(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listMacros(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listMacros, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listMacros);
		if (size)
			*size = sizeof(struct __ns1__listMacros);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__listMacros, n);
		if (size)
			*size = n * sizeof(struct __ns1__listMacros);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__listMacros*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listMacros(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listMacros %p -> %p\n", q, p));
	*(struct __ns1__listMacros*)p = *(struct __ns1__listMacros*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__fault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__fault(soap, &a->ns3__fault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons2__fault(soap, "ns3:fault", -1, &a->ns3__fault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns3__fault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__fault(soap, "ns3:fault", &a->ns3__fault, "ns2:fault"))
				{	soap_flag_ns3__fault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__deleteWayFilterRequest(struct soap *soap, _ns4__deleteWayFilterRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__deleteWayFilterRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__deleteWayFilterRequest(struct soap *soap, const char *tag, int id, _ns4__deleteWayFilterRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__deleteWayFilterRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__deleteWayFilterRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__deleteWayFilterRequest(struct soap *soap, const char *tag, _ns4__deleteWayFilterRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__deleteWayFilterRequest **)soap_malloc(soap, sizeof(_ns4__deleteWayFilterRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__deleteWayFilterRequest *)soap_instantiate__ns4__deleteWayFilterRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__deleteWayFilterRequest ** p = (_ns4__deleteWayFilterRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__deleteWayFilterRequest, sizeof(_ns4__deleteWayFilterRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__deleteWayFilterRequest(struct soap *soap, _ns4__deleteWayFilterRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__deleteWayFilterRequest);
	if (soap_out_PointerTo_ns4__deleteWayFilterRequest(soap, tag?tag:"ns4:deleteWayFilterRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__deleteWayFilterRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__deleteWayFilterRequest(struct soap *soap, _ns4__deleteWayFilterRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__deleteWayFilterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__setWayFilterRequest(struct soap *soap, _ns4__setWayFilterRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__setWayFilterRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__setWayFilterRequest(struct soap *soap, const char *tag, int id, _ns4__setWayFilterRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__setWayFilterRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__setWayFilterRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__setWayFilterRequest(struct soap *soap, const char *tag, _ns4__setWayFilterRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__setWayFilterRequest **)soap_malloc(soap, sizeof(_ns4__setWayFilterRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__setWayFilterRequest *)soap_instantiate__ns4__setWayFilterRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__setWayFilterRequest ** p = (_ns4__setWayFilterRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__setWayFilterRequest, sizeof(_ns4__setWayFilterRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__setWayFilterRequest(struct soap *soap, _ns4__setWayFilterRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__setWayFilterRequest);
	if (soap_out_PointerTo_ns4__setWayFilterRequest(soap, tag?tag:"ns4:setWayFilterRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__setWayFilterRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__setWayFilterRequest(struct soap *soap, _ns4__setWayFilterRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__setWayFilterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__getWayFiltersRequest(struct soap *soap, _ns4__getWayFiltersRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__getWayFiltersRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__getWayFiltersRequest(struct soap *soap, const char *tag, int id, _ns4__getWayFiltersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__getWayFiltersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__getWayFiltersRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__getWayFiltersRequest(struct soap *soap, const char *tag, _ns4__getWayFiltersRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__getWayFiltersRequest **)soap_malloc(soap, sizeof(_ns4__getWayFiltersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__getWayFiltersRequest *)soap_instantiate__ns4__getWayFiltersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__getWayFiltersRequest ** p = (_ns4__getWayFiltersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__getWayFiltersRequest, sizeof(_ns4__getWayFiltersRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__getWayFiltersRequest(struct soap *soap, _ns4__getWayFiltersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__getWayFiltersRequest);
	if (soap_out_PointerTo_ns4__getWayFiltersRequest(soap, tag?tag:"ns4:getWayFiltersRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__getWayFiltersRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__getWayFiltersRequest(struct soap *soap, _ns4__getWayFiltersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__getWayFiltersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__getWayParamsRequest(struct soap *soap, _ns4__getWayParamsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__getWayParamsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__getWayParamsRequest(struct soap *soap, const char *tag, int id, _ns4__getWayParamsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__getWayParamsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__getWayParamsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__getWayParamsRequest(struct soap *soap, const char *tag, _ns4__getWayParamsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__getWayParamsRequest **)soap_malloc(soap, sizeof(_ns4__getWayParamsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__getWayParamsRequest *)soap_instantiate__ns4__getWayParamsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__getWayParamsRequest ** p = (_ns4__getWayParamsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__getWayParamsRequest, sizeof(_ns4__getWayParamsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__getWayParamsRequest(struct soap *soap, _ns4__getWayParamsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__getWayParamsRequest);
	if (soap_out_PointerTo_ns4__getWayParamsRequest(soap, tag?tag:"ns4:getWayParamsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__getWayParamsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__getWayParamsRequest(struct soap *soap, _ns4__getWayParamsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__getWayParamsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__setWayParamsRequest(struct soap *soap, _ns4__setWayParamsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__setWayParamsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__setWayParamsRequest(struct soap *soap, const char *tag, int id, _ns4__setWayParamsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__setWayParamsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__setWayParamsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__setWayParamsRequest(struct soap *soap, const char *tag, _ns4__setWayParamsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__setWayParamsRequest **)soap_malloc(soap, sizeof(_ns4__setWayParamsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__setWayParamsRequest *)soap_instantiate__ns4__setWayParamsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__setWayParamsRequest ** p = (_ns4__setWayParamsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__setWayParamsRequest, sizeof(_ns4__setWayParamsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__setWayParamsRequest(struct soap *soap, _ns4__setWayParamsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__setWayParamsRequest);
	if (soap_out_PointerTo_ns4__setWayParamsRequest(soap, tag?tag:"ns4:setWayParamsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__setWayParamsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__setWayParamsRequest(struct soap *soap, _ns4__setWayParamsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__setWayParamsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__getSystemVersionsRequest(struct soap *soap, _ns4__getSystemVersionsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__getSystemVersionsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__getSystemVersionsRequest(struct soap *soap, const char *tag, int id, _ns4__getSystemVersionsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__getSystemVersionsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__getSystemVersionsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__getSystemVersionsRequest(struct soap *soap, const char *tag, _ns4__getSystemVersionsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__getSystemVersionsRequest **)soap_malloc(soap, sizeof(_ns4__getSystemVersionsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__getSystemVersionsRequest *)soap_instantiate__ns4__getSystemVersionsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__getSystemVersionsRequest ** p = (_ns4__getSystemVersionsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__getSystemVersionsRequest, sizeof(_ns4__getSystemVersionsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__getSystemVersionsRequest(struct soap *soap, _ns4__getSystemVersionsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__getSystemVersionsRequest);
	if (soap_out_PointerTo_ns4__getSystemVersionsRequest(soap, tag?tag:"ns4:getSystemVersionsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__getSystemVersionsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__getSystemVersionsRequest(struct soap *soap, _ns4__getSystemVersionsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__getSystemVersionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__getCertificateRequest(struct soap *soap, _ns4__getCertificateRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__getCertificateRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__getCertificateRequest(struct soap *soap, const char *tag, int id, _ns4__getCertificateRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__getCertificateRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__getCertificateRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__getCertificateRequest(struct soap *soap, const char *tag, _ns4__getCertificateRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__getCertificateRequest **)soap_malloc(soap, sizeof(_ns4__getCertificateRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__getCertificateRequest *)soap_instantiate__ns4__getCertificateRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__getCertificateRequest ** p = (_ns4__getCertificateRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__getCertificateRequest, sizeof(_ns4__getCertificateRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__getCertificateRequest(struct soap *soap, _ns4__getCertificateRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns4__getCertificateRequest);
	if (soap_out_PointerTo_ns4__getCertificateRequest(soap, tag?tag:"ns4:getCertificateRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__getCertificateRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__getCertificateRequest(struct soap *soap, _ns4__getCertificateRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__getCertificateRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__performSystemUpgradeRequest(struct soap *soap, _ns3__performSystemUpgradeRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__performSystemUpgradeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__performSystemUpgradeRequest(struct soap *soap, const char *tag, int id, _ns3__performSystemUpgradeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__performSystemUpgradeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__performSystemUpgradeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__performSystemUpgradeRequest(struct soap *soap, const char *tag, _ns3__performSystemUpgradeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__performSystemUpgradeRequest **)soap_malloc(soap, sizeof(_ns3__performSystemUpgradeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__performSystemUpgradeRequest *)soap_instantiate__ns3__performSystemUpgradeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__performSystemUpgradeRequest ** p = (_ns3__performSystemUpgradeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__performSystemUpgradeRequest, sizeof(_ns3__performSystemUpgradeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__performSystemUpgradeRequest(struct soap *soap, _ns3__performSystemUpgradeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__performSystemUpgradeRequest);
	if (soap_out_PointerTo_ns3__performSystemUpgradeRequest(soap, tag?tag:"ns3:performSystemUpgradeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__performSystemUpgradeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__performSystemUpgradeRequest(struct soap *soap, _ns3__performSystemUpgradeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__performSystemUpgradeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__enableAutoEqModeRequest(struct soap *soap, _ns3__enableAutoEqModeRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__enableAutoEqModeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__enableAutoEqModeRequest(struct soap *soap, const char *tag, int id, _ns3__enableAutoEqModeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__enableAutoEqModeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__enableAutoEqModeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__enableAutoEqModeRequest(struct soap *soap, const char *tag, _ns3__enableAutoEqModeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__enableAutoEqModeRequest **)soap_malloc(soap, sizeof(_ns3__enableAutoEqModeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__enableAutoEqModeRequest *)soap_instantiate__ns3__enableAutoEqModeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__enableAutoEqModeRequest ** p = (_ns3__enableAutoEqModeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__enableAutoEqModeRequest, sizeof(_ns3__enableAutoEqModeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__enableAutoEqModeRequest(struct soap *soap, _ns3__enableAutoEqModeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__enableAutoEqModeRequest);
	if (soap_out_PointerTo_ns3__enableAutoEqModeRequest(soap, tag?tag:"ns3:enableAutoEqModeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__enableAutoEqModeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__enableAutoEqModeRequest(struct soap *soap, _ns3__enableAutoEqModeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__enableAutoEqModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__isAutoEqModeEnabledRequest(struct soap *soap, _ns3__isAutoEqModeEnabledRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__isAutoEqModeEnabledRequest(struct soap *soap, const char *tag, int id, _ns3__isAutoEqModeEnabledRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__isAutoEqModeEnabledRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__isAutoEqModeEnabledRequest(struct soap *soap, const char *tag, _ns3__isAutoEqModeEnabledRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__isAutoEqModeEnabledRequest **)soap_malloc(soap, sizeof(_ns3__isAutoEqModeEnabledRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__isAutoEqModeEnabledRequest *)soap_instantiate__ns3__isAutoEqModeEnabledRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__isAutoEqModeEnabledRequest ** p = (_ns3__isAutoEqModeEnabledRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__isAutoEqModeEnabledRequest, sizeof(_ns3__isAutoEqModeEnabledRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__isAutoEqModeEnabledRequest(struct soap *soap, _ns3__isAutoEqModeEnabledRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__isAutoEqModeEnabledRequest);
	if (soap_out_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, tag?tag:"ns3:isAutoEqModeEnabledRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__isAutoEqModeEnabledRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__isAutoEqModeEnabledRequest(struct soap *soap, _ns3__isAutoEqModeEnabledRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__isAutoEqModeEnabledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setTimeZoneRequest(struct soap *soap, _ns3__setTimeZoneRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setTimeZoneRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setTimeZoneRequest(struct soap *soap, const char *tag, int id, _ns3__setTimeZoneRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setTimeZoneRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setTimeZoneRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setTimeZoneRequest(struct soap *soap, const char *tag, _ns3__setTimeZoneRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setTimeZoneRequest **)soap_malloc(soap, sizeof(_ns3__setTimeZoneRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setTimeZoneRequest *)soap_instantiate__ns3__setTimeZoneRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setTimeZoneRequest ** p = (_ns3__setTimeZoneRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setTimeZoneRequest, sizeof(_ns3__setTimeZoneRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setTimeZoneRequest(struct soap *soap, _ns3__setTimeZoneRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setTimeZoneRequest);
	if (soap_out_PointerTo_ns3__setTimeZoneRequest(soap, tag?tag:"ns3:setTimeZoneRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setTimeZoneRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setTimeZoneRequest(struct soap *soap, _ns3__setTimeZoneRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setTimeZoneRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getTimeZoneRequest(struct soap *soap, _ns3__getTimeZoneRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getTimeZoneRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getTimeZoneRequest(struct soap *soap, const char *tag, int id, _ns3__getTimeZoneRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getTimeZoneRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getTimeZoneRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getTimeZoneRequest(struct soap *soap, const char *tag, _ns3__getTimeZoneRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getTimeZoneRequest **)soap_malloc(soap, sizeof(_ns3__getTimeZoneRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getTimeZoneRequest *)soap_instantiate__ns3__getTimeZoneRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getTimeZoneRequest ** p = (_ns3__getTimeZoneRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getTimeZoneRequest, sizeof(_ns3__getTimeZoneRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getTimeZoneRequest(struct soap *soap, _ns3__getTimeZoneRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getTimeZoneRequest);
	if (soap_out_PointerTo_ns3__getTimeZoneRequest(soap, tag?tag:"ns3:getTimeZoneRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getTimeZoneRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getTimeZoneRequest(struct soap *soap, _ns3__getTimeZoneRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getTimeZoneRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getDeviceAlarmsRequest(struct soap *soap, _ns3__getDeviceAlarmsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getDeviceAlarmsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getDeviceAlarmsRequest(struct soap *soap, const char *tag, int id, _ns3__getDeviceAlarmsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getDeviceAlarmsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getDeviceAlarmsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getDeviceAlarmsRequest(struct soap *soap, const char *tag, _ns3__getDeviceAlarmsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getDeviceAlarmsRequest **)soap_malloc(soap, sizeof(_ns3__getDeviceAlarmsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getDeviceAlarmsRequest *)soap_instantiate__ns3__getDeviceAlarmsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getDeviceAlarmsRequest ** p = (_ns3__getDeviceAlarmsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getDeviceAlarmsRequest, sizeof(_ns3__getDeviceAlarmsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getDeviceAlarmsRequest(struct soap *soap, _ns3__getDeviceAlarmsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getDeviceAlarmsRequest);
	if (soap_out_PointerTo_ns3__getDeviceAlarmsRequest(soap, tag?tag:"ns3:getDeviceAlarmsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getDeviceAlarmsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getDeviceAlarmsRequest(struct soap *soap, _ns3__getDeviceAlarmsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getDeviceAlarmsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getDeviceInfoRequest(struct soap *soap, _ns3__getDeviceInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getDeviceInfoRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getDeviceInfoRequest(struct soap *soap, const char *tag, int id, _ns3__getDeviceInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getDeviceInfoRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getDeviceInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getDeviceInfoRequest(struct soap *soap, const char *tag, _ns3__getDeviceInfoRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getDeviceInfoRequest **)soap_malloc(soap, sizeof(_ns3__getDeviceInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getDeviceInfoRequest *)soap_instantiate__ns3__getDeviceInfoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getDeviceInfoRequest ** p = (_ns3__getDeviceInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getDeviceInfoRequest, sizeof(_ns3__getDeviceInfoRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getDeviceInfoRequest(struct soap *soap, _ns3__getDeviceInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getDeviceInfoRequest);
	if (soap_out_PointerTo_ns3__getDeviceInfoRequest(soap, tag?tag:"ns3:getDeviceInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getDeviceInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getDeviceInfoRequest(struct soap *soap, _ns3__getDeviceInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getDeviceInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__enableGlobalEqRequest(struct soap *soap, _ns3__enableGlobalEqRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__enableGlobalEqRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__enableGlobalEqRequest(struct soap *soap, const char *tag, int id, _ns3__enableGlobalEqRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__enableGlobalEqRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__enableGlobalEqRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__enableGlobalEqRequest(struct soap *soap, const char *tag, _ns3__enableGlobalEqRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__enableGlobalEqRequest **)soap_malloc(soap, sizeof(_ns3__enableGlobalEqRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__enableGlobalEqRequest *)soap_instantiate__ns3__enableGlobalEqRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__enableGlobalEqRequest ** p = (_ns3__enableGlobalEqRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__enableGlobalEqRequest, sizeof(_ns3__enableGlobalEqRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__enableGlobalEqRequest(struct soap *soap, _ns3__enableGlobalEqRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__enableGlobalEqRequest);
	if (soap_out_PointerTo_ns3__enableGlobalEqRequest(soap, tag?tag:"ns3:enableGlobalEqRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__enableGlobalEqRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__enableGlobalEqRequest(struct soap *soap, _ns3__enableGlobalEqRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__enableGlobalEqRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__isGlobalEqEnabledRequest(struct soap *soap, _ns3__isGlobalEqEnabledRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__isGlobalEqEnabledRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__isGlobalEqEnabledRequest(struct soap *soap, const char *tag, int id, _ns3__isGlobalEqEnabledRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__isGlobalEqEnabledRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__isGlobalEqEnabledRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__isGlobalEqEnabledRequest(struct soap *soap, const char *tag, _ns3__isGlobalEqEnabledRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__isGlobalEqEnabledRequest **)soap_malloc(soap, sizeof(_ns3__isGlobalEqEnabledRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__isGlobalEqEnabledRequest *)soap_instantiate__ns3__isGlobalEqEnabledRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__isGlobalEqEnabledRequest ** p = (_ns3__isGlobalEqEnabledRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__isGlobalEqEnabledRequest, sizeof(_ns3__isGlobalEqEnabledRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__isGlobalEqEnabledRequest(struct soap *soap, _ns3__isGlobalEqEnabledRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__isGlobalEqEnabledRequest);
	if (soap_out_PointerTo_ns3__isGlobalEqEnabledRequest(soap, tag?tag:"ns3:isGlobalEqEnabledRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__isGlobalEqEnabledRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__isGlobalEqEnabledRequest(struct soap *soap, _ns3__isGlobalEqEnabledRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__isGlobalEqEnabledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__enableBassManagementRequest(struct soap *soap, _ns3__enableBassManagementRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__enableBassManagementRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__enableBassManagementRequest(struct soap *soap, const char *tag, int id, _ns3__enableBassManagementRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__enableBassManagementRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__enableBassManagementRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__enableBassManagementRequest(struct soap *soap, const char *tag, _ns3__enableBassManagementRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__enableBassManagementRequest **)soap_malloc(soap, sizeof(_ns3__enableBassManagementRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__enableBassManagementRequest *)soap_instantiate__ns3__enableBassManagementRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__enableBassManagementRequest ** p = (_ns3__enableBassManagementRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__enableBassManagementRequest, sizeof(_ns3__enableBassManagementRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__enableBassManagementRequest(struct soap *soap, _ns3__enableBassManagementRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__enableBassManagementRequest);
	if (soap_out_PointerTo_ns3__enableBassManagementRequest(soap, tag?tag:"ns3:enableBassManagementRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__enableBassManagementRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__enableBassManagementRequest(struct soap *soap, _ns3__enableBassManagementRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__enableBassManagementRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__isBassManagementEnabledRequest(struct soap *soap, _ns3__isBassManagementEnabledRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__isBassManagementEnabledRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__isBassManagementEnabledRequest(struct soap *soap, const char *tag, int id, _ns3__isBassManagementEnabledRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__isBassManagementEnabledRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__isBassManagementEnabledRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__isBassManagementEnabledRequest(struct soap *soap, const char *tag, _ns3__isBassManagementEnabledRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__isBassManagementEnabledRequest **)soap_malloc(soap, sizeof(_ns3__isBassManagementEnabledRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__isBassManagementEnabledRequest *)soap_instantiate__ns3__isBassManagementEnabledRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__isBassManagementEnabledRequest ** p = (_ns3__isBassManagementEnabledRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__isBassManagementEnabledRequest, sizeof(_ns3__isBassManagementEnabledRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__isBassManagementEnabledRequest(struct soap *soap, _ns3__isBassManagementEnabledRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__isBassManagementEnabledRequest);
	if (soap_out_PointerTo_ns3__isBassManagementEnabledRequest(soap, tag?tag:"ns3:isBassManagementEnabledRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__isBassManagementEnabledRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__isBassManagementEnabledRequest(struct soap *soap, _ns3__isBassManagementEnabledRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__isBassManagementEnabledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setTestSignalModeRequest(struct soap *soap, _ns3__setTestSignalModeRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setTestSignalModeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setTestSignalModeRequest(struct soap *soap, const char *tag, int id, _ns3__setTestSignalModeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setTestSignalModeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setTestSignalModeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setTestSignalModeRequest(struct soap *soap, const char *tag, _ns3__setTestSignalModeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setTestSignalModeRequest **)soap_malloc(soap, sizeof(_ns3__setTestSignalModeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setTestSignalModeRequest *)soap_instantiate__ns3__setTestSignalModeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setTestSignalModeRequest ** p = (_ns3__setTestSignalModeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setTestSignalModeRequest, sizeof(_ns3__setTestSignalModeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setTestSignalModeRequest(struct soap *soap, _ns3__setTestSignalModeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setTestSignalModeRequest);
	if (soap_out_PointerTo_ns3__setTestSignalModeRequest(soap, tag?tag:"ns3:setTestSignalModeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setTestSignalModeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setTestSignalModeRequest(struct soap *soap, _ns3__setTestSignalModeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setTestSignalModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getTestSignalModeRequest(struct soap *soap, _ns3__getTestSignalModeRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getTestSignalModeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getTestSignalModeRequest(struct soap *soap, const char *tag, int id, _ns3__getTestSignalModeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getTestSignalModeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getTestSignalModeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getTestSignalModeRequest(struct soap *soap, const char *tag, _ns3__getTestSignalModeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getTestSignalModeRequest **)soap_malloc(soap, sizeof(_ns3__getTestSignalModeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getTestSignalModeRequest *)soap_instantiate__ns3__getTestSignalModeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getTestSignalModeRequest ** p = (_ns3__getTestSignalModeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getTestSignalModeRequest, sizeof(_ns3__getTestSignalModeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getTestSignalModeRequest(struct soap *soap, _ns3__getTestSignalModeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getTestSignalModeRequest);
	if (soap_out_PointerTo_ns3__getTestSignalModeRequest(soap, tag?tag:"ns3:getTestSignalModeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getTestSignalModeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getTestSignalModeRequest(struct soap *soap, _ns3__getTestSignalModeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getTestSignalModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setTestSignalOutputRequest(struct soap *soap, _ns3__setTestSignalOutputRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setTestSignalOutputRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setTestSignalOutputRequest(struct soap *soap, const char *tag, int id, _ns3__setTestSignalOutputRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setTestSignalOutputRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setTestSignalOutputRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setTestSignalOutputRequest(struct soap *soap, const char *tag, _ns3__setTestSignalOutputRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setTestSignalOutputRequest **)soap_malloc(soap, sizeof(_ns3__setTestSignalOutputRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setTestSignalOutputRequest *)soap_instantiate__ns3__setTestSignalOutputRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setTestSignalOutputRequest ** p = (_ns3__setTestSignalOutputRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setTestSignalOutputRequest, sizeof(_ns3__setTestSignalOutputRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setTestSignalOutputRequest(struct soap *soap, _ns3__setTestSignalOutputRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setTestSignalOutputRequest);
	if (soap_out_PointerTo_ns3__setTestSignalOutputRequest(soap, tag?tag:"ns3:setTestSignalOutputRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setTestSignalOutputRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setTestSignalOutputRequest(struct soap *soap, _ns3__setTestSignalOutputRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setTestSignalOutputRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getTestSignalOutputRequest(struct soap *soap, _ns3__getTestSignalOutputRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getTestSignalOutputRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getTestSignalOutputRequest(struct soap *soap, const char *tag, int id, _ns3__getTestSignalOutputRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getTestSignalOutputRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getTestSignalOutputRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getTestSignalOutputRequest(struct soap *soap, const char *tag, _ns3__getTestSignalOutputRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getTestSignalOutputRequest **)soap_malloc(soap, sizeof(_ns3__getTestSignalOutputRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getTestSignalOutputRequest *)soap_instantiate__ns3__getTestSignalOutputRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getTestSignalOutputRequest ** p = (_ns3__getTestSignalOutputRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getTestSignalOutputRequest, sizeof(_ns3__getTestSignalOutputRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getTestSignalOutputRequest(struct soap *soap, _ns3__getTestSignalOutputRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getTestSignalOutputRequest);
	if (soap_out_PointerTo_ns3__getTestSignalOutputRequest(soap, tag?tag:"ns3:getTestSignalOutputRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getTestSignalOutputRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getTestSignalOutputRequest(struct soap *soap, _ns3__getTestSignalOutputRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getTestSignalOutputRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setAtmosConfigRequest(struct soap *soap, _ns3__setAtmosConfigRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setAtmosConfigRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setAtmosConfigRequest(struct soap *soap, const char *tag, int id, _ns3__setAtmosConfigRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setAtmosConfigRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setAtmosConfigRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setAtmosConfigRequest(struct soap *soap, const char *tag, _ns3__setAtmosConfigRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setAtmosConfigRequest **)soap_malloc(soap, sizeof(_ns3__setAtmosConfigRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setAtmosConfigRequest *)soap_instantiate__ns3__setAtmosConfigRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setAtmosConfigRequest ** p = (_ns3__setAtmosConfigRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setAtmosConfigRequest, sizeof(_ns3__setAtmosConfigRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setAtmosConfigRequest(struct soap *soap, _ns3__setAtmosConfigRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setAtmosConfigRequest);
	if (soap_out_PointerTo_ns3__setAtmosConfigRequest(soap, tag?tag:"ns3:setAtmosConfigRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setAtmosConfigRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setAtmosConfigRequest(struct soap *soap, _ns3__setAtmosConfigRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setAtmosConfigRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getAtmosConfigRequest(struct soap *soap, _ns3__getAtmosConfigRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getAtmosConfigRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getAtmosConfigRequest(struct soap *soap, const char *tag, int id, _ns3__getAtmosConfigRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getAtmosConfigRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getAtmosConfigRequest(struct soap *soap, const char *tag, _ns3__getAtmosConfigRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getAtmosConfigRequest **)soap_malloc(soap, sizeof(_ns3__getAtmosConfigRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getAtmosConfigRequest *)soap_instantiate__ns3__getAtmosConfigRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getAtmosConfigRequest ** p = (_ns3__getAtmosConfigRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getAtmosConfigRequest, sizeof(_ns3__getAtmosConfigRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getAtmosConfigRequest(struct soap *soap, _ns3__getAtmosConfigRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getAtmosConfigRequest);
	if (soap_out_PointerTo_ns3__getAtmosConfigRequest(soap, tag?tag:"ns3:getAtmosConfigRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getAtmosConfigRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getAtmosConfigRequest(struct soap *soap, _ns3__getAtmosConfigRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getAtmosConfigRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getAtmosConfigInfoRequest(struct soap *soap, _ns3__getAtmosConfigInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getAtmosConfigInfoRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getAtmosConfigInfoRequest(struct soap *soap, const char *tag, int id, _ns3__getAtmosConfigInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getAtmosConfigInfoRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getAtmosConfigInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getAtmosConfigInfoRequest(struct soap *soap, const char *tag, _ns3__getAtmosConfigInfoRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getAtmosConfigInfoRequest **)soap_malloc(soap, sizeof(_ns3__getAtmosConfigInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getAtmosConfigInfoRequest *)soap_instantiate__ns3__getAtmosConfigInfoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getAtmosConfigInfoRequest ** p = (_ns3__getAtmosConfigInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getAtmosConfigInfoRequest, sizeof(_ns3__getAtmosConfigInfoRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getAtmosConfigInfoRequest(struct soap *soap, _ns3__getAtmosConfigInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getAtmosConfigInfoRequest);
	if (soap_out_PointerTo_ns3__getAtmosConfigInfoRequest(soap, tag?tag:"ns3:getAtmosConfigInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getAtmosConfigInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getAtmosConfigInfoRequest(struct soap *soap, _ns3__getAtmosConfigInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getAtmosConfigInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getAudioStreamInfoRequest(struct soap *soap, _ns3__getAudioStreamInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getAudioStreamInfoRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getAudioStreamInfoRequest(struct soap *soap, const char *tag, int id, _ns3__getAudioStreamInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getAudioStreamInfoRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getAudioStreamInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getAudioStreamInfoRequest(struct soap *soap, const char *tag, _ns3__getAudioStreamInfoRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getAudioStreamInfoRequest **)soap_malloc(soap, sizeof(_ns3__getAudioStreamInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getAudioStreamInfoRequest *)soap_instantiate__ns3__getAudioStreamInfoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getAudioStreamInfoRequest ** p = (_ns3__getAudioStreamInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getAudioStreamInfoRequest, sizeof(_ns3__getAudioStreamInfoRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getAudioStreamInfoRequest(struct soap *soap, _ns3__getAudioStreamInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getAudioStreamInfoRequest);
	if (soap_out_PointerTo_ns3__getAudioStreamInfoRequest(soap, tag?tag:"ns3:getAudioStreamInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getAudioStreamInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getAudioStreamInfoRequest(struct soap *soap, _ns3__getAudioStreamInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getAudioStreamInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__isAtmosContentRequest(struct soap *soap, _ns3__isAtmosContentRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__isAtmosContentRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__isAtmosContentRequest(struct soap *soap, const char *tag, int id, _ns3__isAtmosContentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__isAtmosContentRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__isAtmosContentRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__isAtmosContentRequest(struct soap *soap, const char *tag, _ns3__isAtmosContentRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__isAtmosContentRequest **)soap_malloc(soap, sizeof(_ns3__isAtmosContentRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__isAtmosContentRequest *)soap_instantiate__ns3__isAtmosContentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__isAtmosContentRequest ** p = (_ns3__isAtmosContentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__isAtmosContentRequest, sizeof(_ns3__isAtmosContentRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__isAtmosContentRequest(struct soap *soap, _ns3__isAtmosContentRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__isAtmosContentRequest);
	if (soap_out_PointerTo_ns3__isAtmosContentRequest(soap, tag?tag:"ns3:isAtmosContentRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__isAtmosContentRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__isAtmosContentRequest(struct soap *soap, _ns3__isAtmosContentRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__isAtmosContentRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setMuteRequest(struct soap *soap, _ns3__setMuteRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setMuteRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setMuteRequest(struct soap *soap, const char *tag, int id, _ns3__setMuteRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setMuteRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setMuteRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setMuteRequest(struct soap *soap, const char *tag, _ns3__setMuteRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setMuteRequest **)soap_malloc(soap, sizeof(_ns3__setMuteRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setMuteRequest *)soap_instantiate__ns3__setMuteRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setMuteRequest ** p = (_ns3__setMuteRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setMuteRequest, sizeof(_ns3__setMuteRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setMuteRequest(struct soap *soap, _ns3__setMuteRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setMuteRequest);
	if (soap_out_PointerTo_ns3__setMuteRequest(soap, tag?tag:"ns3:setMuteRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setMuteRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setMuteRequest(struct soap *soap, _ns3__setMuteRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setMuteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getMuteRequest(struct soap *soap, _ns3__getMuteRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getMuteRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getMuteRequest(struct soap *soap, const char *tag, int id, _ns3__getMuteRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getMuteRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getMuteRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getMuteRequest(struct soap *soap, const char *tag, _ns3__getMuteRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getMuteRequest **)soap_malloc(soap, sizeof(_ns3__getMuteRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getMuteRequest *)soap_instantiate__ns3__getMuteRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getMuteRequest ** p = (_ns3__getMuteRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getMuteRequest, sizeof(_ns3__getMuteRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getMuteRequest(struct soap *soap, _ns3__getMuteRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getMuteRequest);
	if (soap_out_PointerTo_ns3__getMuteRequest(soap, tag?tag:"ns3:getMuteRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getMuteRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getMuteRequest(struct soap *soap, _ns3__getMuteRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getMuteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setGainRequest(struct soap *soap, _ns3__setGainRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setGainRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setGainRequest(struct soap *soap, const char *tag, int id, _ns3__setGainRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setGainRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setGainRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setGainRequest(struct soap *soap, const char *tag, _ns3__setGainRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setGainRequest **)soap_malloc(soap, sizeof(_ns3__setGainRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setGainRequest *)soap_instantiate__ns3__setGainRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setGainRequest ** p = (_ns3__setGainRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setGainRequest, sizeof(_ns3__setGainRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setGainRequest(struct soap *soap, _ns3__setGainRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setGainRequest);
	if (soap_out_PointerTo_ns3__setGainRequest(soap, tag?tag:"ns3:setGainRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setGainRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setGainRequest(struct soap *soap, _ns3__setGainRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setGainRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getGainRequest(struct soap *soap, _ns3__getGainRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getGainRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getGainRequest(struct soap *soap, const char *tag, int id, _ns3__getGainRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getGainRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getGainRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getGainRequest(struct soap *soap, const char *tag, _ns3__getGainRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getGainRequest **)soap_malloc(soap, sizeof(_ns3__getGainRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getGainRequest *)soap_instantiate__ns3__getGainRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getGainRequest ** p = (_ns3__getGainRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getGainRequest, sizeof(_ns3__getGainRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getGainRequest(struct soap *soap, _ns3__getGainRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getGainRequest);
	if (soap_out_PointerTo_ns3__getGainRequest(soap, tag?tag:"ns3:getGainRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getGainRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getGainRequest(struct soap *soap, _ns3__getGainRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getGainRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__setCurrentMacroRequest(struct soap *soap, _ns3__setCurrentMacroRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__setCurrentMacroRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__setCurrentMacroRequest(struct soap *soap, const char *tag, int id, _ns3__setCurrentMacroRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__setCurrentMacroRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__setCurrentMacroRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__setCurrentMacroRequest(struct soap *soap, const char *tag, _ns3__setCurrentMacroRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__setCurrentMacroRequest **)soap_malloc(soap, sizeof(_ns3__setCurrentMacroRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__setCurrentMacroRequest *)soap_instantiate__ns3__setCurrentMacroRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__setCurrentMacroRequest ** p = (_ns3__setCurrentMacroRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__setCurrentMacroRequest, sizeof(_ns3__setCurrentMacroRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__setCurrentMacroRequest(struct soap *soap, _ns3__setCurrentMacroRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__setCurrentMacroRequest);
	if (soap_out_PointerTo_ns3__setCurrentMacroRequest(soap, tag?tag:"ns3:setCurrentMacroRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__setCurrentMacroRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__setCurrentMacroRequest(struct soap *soap, _ns3__setCurrentMacroRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__setCurrentMacroRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__getCurrentMacroRequest(struct soap *soap, _ns3__getCurrentMacroRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__getCurrentMacroRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__getCurrentMacroRequest(struct soap *soap, const char *tag, int id, _ns3__getCurrentMacroRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__getCurrentMacroRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__getCurrentMacroRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__getCurrentMacroRequest(struct soap *soap, const char *tag, _ns3__getCurrentMacroRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__getCurrentMacroRequest **)soap_malloc(soap, sizeof(_ns3__getCurrentMacroRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__getCurrentMacroRequest *)soap_instantiate__ns3__getCurrentMacroRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__getCurrentMacroRequest ** p = (_ns3__getCurrentMacroRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__getCurrentMacroRequest, sizeof(_ns3__getCurrentMacroRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__getCurrentMacroRequest(struct soap *soap, _ns3__getCurrentMacroRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__getCurrentMacroRequest);
	if (soap_out_PointerTo_ns3__getCurrentMacroRequest(soap, tag?tag:"ns3:getCurrentMacroRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__getCurrentMacroRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__getCurrentMacroRequest(struct soap *soap, _ns3__getCurrentMacroRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__getCurrentMacroRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__listMacrosRequest(struct soap *soap, _ns3__listMacrosRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__listMacrosRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__listMacrosRequest(struct soap *soap, const char *tag, int id, _ns3__listMacrosRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__listMacrosRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__listMacrosRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__listMacrosRequest(struct soap *soap, const char *tag, _ns3__listMacrosRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__listMacrosRequest **)soap_malloc(soap, sizeof(_ns3__listMacrosRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__listMacrosRequest *)soap_instantiate__ns3__listMacrosRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__listMacrosRequest ** p = (_ns3__listMacrosRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__listMacrosRequest, sizeof(_ns3__listMacrosRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__listMacrosRequest(struct soap *soap, _ns3__listMacrosRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns3__listMacrosRequest);
	if (soap_out_PointerTo_ns3__listMacrosRequest(soap, tag?tag:"ns3:listMacrosRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__listMacrosRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__listMacrosRequest(struct soap *soap, _ns3__listMacrosRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__listMacrosRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__fault(struct soap *soap, ns2__fault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__fault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__fault(struct soap *soap, const char *tag, int id, ns2__fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__fault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__fault ** SOAP_FMAC4 soap_in_PointerTons2__fault(struct soap *soap, const char *tag, ns2__fault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__fault **)soap_malloc(soap, sizeof(ns2__fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__fault *)soap_instantiate_ns2__fault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__fault ** p = (ns2__fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__fault, sizeof(ns2__fault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__fault(struct soap *soap, ns2__fault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__fault);
	if (soap_out_PointerTons2__fault(soap, tag?tag:"ns2:fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__fault ** SOAP_FMAC4 soap_get_PointerTons2__fault(struct soap *soap, ns2__fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__allPassFilter(struct soap *soap, ns2__allPassFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__allPassFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__allPassFilter(struct soap *soap, const char *tag, int id, ns2__allPassFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__allPassFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__allPassFilter ** SOAP_FMAC4 soap_in_PointerTons2__allPassFilter(struct soap *soap, const char *tag, ns2__allPassFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__allPassFilter **)soap_malloc(soap, sizeof(ns2__allPassFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__allPassFilter *)soap_instantiate_ns2__allPassFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__allPassFilter ** p = (ns2__allPassFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__allPassFilter, sizeof(ns2__allPassFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__allPassFilter(struct soap *soap, ns2__allPassFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__allPassFilter);
	if (soap_out_PointerTons2__allPassFilter(soap, tag?tag:"ns2:allPassFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__allPassFilter ** SOAP_FMAC4 soap_get_PointerTons2__allPassFilter(struct soap *soap, ns2__allPassFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__allPassFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__parametricFilter(struct soap *soap, ns2__parametricFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__parametricFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__parametricFilter(struct soap *soap, const char *tag, int id, ns2__parametricFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__parametricFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__parametricFilter ** SOAP_FMAC4 soap_in_PointerTons2__parametricFilter(struct soap *soap, const char *tag, ns2__parametricFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__parametricFilter **)soap_malloc(soap, sizeof(ns2__parametricFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__parametricFilter *)soap_instantiate_ns2__parametricFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__parametricFilter ** p = (ns2__parametricFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__parametricFilter, sizeof(ns2__parametricFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__parametricFilter(struct soap *soap, ns2__parametricFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__parametricFilter);
	if (soap_out_PointerTons2__parametricFilter(soap, tag?tag:"ns2:parametricFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__parametricFilter ** SOAP_FMAC4 soap_get_PointerTons2__parametricFilter(struct soap *soap, ns2__parametricFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__parametricFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__shelfFilter(struct soap *soap, ns2__shelfFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__shelfFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__shelfFilter(struct soap *soap, const char *tag, int id, ns2__shelfFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__shelfFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__shelfFilter ** SOAP_FMAC4 soap_in_PointerTons2__shelfFilter(struct soap *soap, const char *tag, ns2__shelfFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__shelfFilter **)soap_malloc(soap, sizeof(ns2__shelfFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__shelfFilter *)soap_instantiate_ns2__shelfFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__shelfFilter ** p = (ns2__shelfFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__shelfFilter, sizeof(ns2__shelfFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__shelfFilter(struct soap *soap, ns2__shelfFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__shelfFilter);
	if (soap_out_PointerTons2__shelfFilter(soap, tag?tag:"ns2:shelfFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__shelfFilter ** SOAP_FMAC4 soap_get_PointerTons2__shelfFilter(struct soap *soap, ns2__shelfFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__shelfFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__crossoverFilter(struct soap *soap, ns2__crossoverFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__crossoverFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__crossoverFilter(struct soap *soap, const char *tag, int id, ns2__crossoverFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__crossoverFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__crossoverFilter ** SOAP_FMAC4 soap_in_PointerTons2__crossoverFilter(struct soap *soap, const char *tag, ns2__crossoverFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__crossoverFilter **)soap_malloc(soap, sizeof(ns2__crossoverFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__crossoverFilter *)soap_instantiate_ns2__crossoverFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__crossoverFilter ** p = (ns2__crossoverFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__crossoverFilter, sizeof(ns2__crossoverFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__crossoverFilter(struct soap *soap, ns2__crossoverFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__crossoverFilter);
	if (soap_out_PointerTons2__crossoverFilter(soap, tag?tag:"ns2:crossoverFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__crossoverFilter ** SOAP_FMAC4 soap_get_PointerTons2__crossoverFilter(struct soap *soap, ns2__crossoverFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__crossoverFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns4__getWayParamsResponse_sequence(struct soap *soap, __ns4__getWayParamsResponse_sequence *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns4__getWayParamsResponse_sequence))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns4__getWayParamsResponse_sequence(struct soap *soap, const char *tag, int id, __ns4__getWayParamsResponse_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns4__getWayParamsResponse_sequence);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns4__getWayParamsResponse_sequence ** SOAP_FMAC4 soap_in_PointerTo__ns4__getWayParamsResponse_sequence(struct soap *soap, const char *tag, __ns4__getWayParamsResponse_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns4__getWayParamsResponse_sequence **)soap_malloc(soap, sizeof(__ns4__getWayParamsResponse_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns4__getWayParamsResponse_sequence *)soap_instantiate___ns4__getWayParamsResponse_sequence(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns4__getWayParamsResponse_sequence ** p = (__ns4__getWayParamsResponse_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns4__getWayParamsResponse_sequence, sizeof(__ns4__getWayParamsResponse_sequence), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns4__getWayParamsResponse_sequence(struct soap *soap, __ns4__getWayParamsResponse_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo__ns4__getWayParamsResponse_sequence);
	if (soap_out_PointerTo__ns4__getWayParamsResponse_sequence(soap, tag?tag:"-ns4:getWayParamsResponse-sequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns4__getWayParamsResponse_sequence ** SOAP_FMAC4 soap_get_PointerTo__ns4__getWayParamsResponse_sequence(struct soap *soap, __ns4__getWayParamsResponse_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns4__getWayParamsResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__alarm(struct soap *soap, _ns2__alarm *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__alarm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__alarm(struct soap *soap, const char *tag, int id, _ns2__alarm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__alarm);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__alarm ** SOAP_FMAC4 soap_in_PointerTo_ns2__alarm(struct soap *soap, const char *tag, _ns2__alarm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__alarm **)soap_malloc(soap, sizeof(_ns2__alarm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__alarm *)soap_instantiate__ns2__alarm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__alarm ** p = (_ns2__alarm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__alarm, sizeof(_ns2__alarm), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__alarm(struct soap *soap, _ns2__alarm *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns2__alarm);
	if (soap_out_PointerTo_ns2__alarm(soap, tag?tag:"ns2:alarm", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__alarm ** SOAP_FMAC4 soap_get_PointerTo_ns2__alarm(struct soap *soap, _ns2__alarm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__keyValuePair(struct soap *soap, ns2__keyValuePair *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__keyValuePair))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__keyValuePair(struct soap *soap, const char *tag, int id, ns2__keyValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__keyValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__keyValuePair ** SOAP_FMAC4 soap_in_PointerTons2__keyValuePair(struct soap *soap, const char *tag, ns2__keyValuePair **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__keyValuePair **)soap_malloc(soap, sizeof(ns2__keyValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__keyValuePair *)soap_instantiate_ns2__keyValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__keyValuePair ** p = (ns2__keyValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__keyValuePair, sizeof(ns2__keyValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__keyValuePair(struct soap *soap, ns2__keyValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__keyValuePair);
	if (soap_out_PointerTons2__keyValuePair(soap, tag?tag:"ns2:keyValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__keyValuePair ** SOAP_FMAC4 soap_get_PointerTons2__keyValuePair(struct soap *soap, ns2__keyValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__keyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__testSignalObjectPath(struct soap *soap, enum ns2__testSignalObjectPath *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__testSignalObjectPath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__testSignalObjectPath(struct soap *soap, const char *tag, int id, enum ns2__testSignalObjectPath *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__testSignalObjectPath);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__testSignalObjectPath(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__testSignalObjectPath ** SOAP_FMAC4 soap_in_PointerTons2__testSignalObjectPath(struct soap *soap, const char *tag, enum ns2__testSignalObjectPath **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__testSignalObjectPath **)soap_malloc(soap, sizeof(enum ns2__testSignalObjectPath *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__testSignalObjectPath(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__testSignalObjectPath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__testSignalObjectPath, sizeof(enum ns2__testSignalObjectPath), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__testSignalObjectPath(struct soap *soap, enum ns2__testSignalObjectPath *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__testSignalObjectPath);
	if (soap_out_PointerTons2__testSignalObjectPath(soap, tag?tag:"ns2:testSignalObjectPath", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__testSignalObjectPath ** SOAP_FMAC4 soap_get_PointerTons2__testSignalObjectPath(struct soap *soap, enum ns2__testSignalObjectPath **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__testSignalObjectPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__bedChannelId(struct soap *soap, enum ns2__bedChannelId *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__bedChannelId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__bedChannelId(struct soap *soap, const char *tag, int id, enum ns2__bedChannelId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__bedChannelId);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__bedChannelId(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__bedChannelId ** SOAP_FMAC4 soap_in_PointerTons2__bedChannelId(struct soap *soap, const char *tag, enum ns2__bedChannelId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__bedChannelId **)soap_malloc(soap, sizeof(enum ns2__bedChannelId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__bedChannelId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__bedChannelId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__bedChannelId, sizeof(enum ns2__bedChannelId), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__bedChannelId(struct soap *soap, enum ns2__bedChannelId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__bedChannelId);
	if (soap_out_PointerTons2__bedChannelId(soap, tag?tag:"ns2:bedChannelId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__bedChannelId ** SOAP_FMAC4 soap_get_PointerTons2__bedChannelId(struct soap *soap, enum ns2__bedChannelId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__bedChannelId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__lastAtmosConfigPushErrorType(struct soap *soap, enum ns2__lastAtmosConfigPushErrorType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__lastAtmosConfigPushErrorType(struct soap *soap, const char *tag, int id, enum ns2__lastAtmosConfigPushErrorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__lastAtmosConfigPushErrorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushErrorType ** SOAP_FMAC4 soap_in_PointerTons2__lastAtmosConfigPushErrorType(struct soap *soap, const char *tag, enum ns2__lastAtmosConfigPushErrorType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__lastAtmosConfigPushErrorType **)soap_malloc(soap, sizeof(enum ns2__lastAtmosConfigPushErrorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__lastAtmosConfigPushErrorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__lastAtmosConfigPushErrorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__lastAtmosConfigPushErrorType, sizeof(enum ns2__lastAtmosConfigPushErrorType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__lastAtmosConfigPushErrorType(struct soap *soap, enum ns2__lastAtmosConfigPushErrorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__lastAtmosConfigPushErrorType);
	if (soap_out_PointerTons2__lastAtmosConfigPushErrorType(soap, tag?tag:"ns2:lastAtmosConfigPushErrorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushErrorType ** SOAP_FMAC4 soap_get_PointerTons2__lastAtmosConfigPushErrorType(struct soap *soap, enum ns2__lastAtmosConfigPushErrorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__lastAtmosConfigPushErrorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__lastAtmosConfigPushStatus(struct soap *soap, enum ns2__lastAtmosConfigPushStatus *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__lastAtmosConfigPushStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__lastAtmosConfigPushStatus(struct soap *soap, const char *tag, int id, enum ns2__lastAtmosConfigPushStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__lastAtmosConfigPushStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__lastAtmosConfigPushStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushStatus ** SOAP_FMAC4 soap_in_PointerTons2__lastAtmosConfigPushStatus(struct soap *soap, const char *tag, enum ns2__lastAtmosConfigPushStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__lastAtmosConfigPushStatus **)soap_malloc(soap, sizeof(enum ns2__lastAtmosConfigPushStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__lastAtmosConfigPushStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__lastAtmosConfigPushStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__lastAtmosConfigPushStatus, sizeof(enum ns2__lastAtmosConfigPushStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__lastAtmosConfigPushStatus(struct soap *soap, enum ns2__lastAtmosConfigPushStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__lastAtmosConfigPushStatus);
	if (soap_out_PointerTons2__lastAtmosConfigPushStatus(soap, tag?tag:"ns2:lastAtmosConfigPushStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__lastAtmosConfigPushStatus ** SOAP_FMAC4 soap_get_PointerTons2__lastAtmosConfigPushStatus(struct soap *soap, enum ns2__lastAtmosConfigPushStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__lastAtmosConfigPushStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__audioStreamInfo(struct soap *soap, ns2__audioStreamInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__audioStreamInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__audioStreamInfo(struct soap *soap, const char *tag, int id, ns2__audioStreamInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__audioStreamInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__audioStreamInfo ** SOAP_FMAC4 soap_in_PointerTons2__audioStreamInfo(struct soap *soap, const char *tag, ns2__audioStreamInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__audioStreamInfo **)soap_malloc(soap, sizeof(ns2__audioStreamInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__audioStreamInfo *)soap_instantiate_ns2__audioStreamInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__audioStreamInfo ** p = (ns2__audioStreamInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__audioStreamInfo, sizeof(ns2__audioStreamInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__audioStreamInfo(struct soap *soap, ns2__audioStreamInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__audioStreamInfo);
	if (soap_out_PointerTons2__audioStreamInfo(soap, tag?tag:"ns2:audioStreamInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__audioStreamInfo ** SOAP_FMAC4 soap_get_PointerTons2__audioStreamInfo(struct soap *soap, ns2__audioStreamInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__audioStreamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__macro(struct soap *soap, ns2__macro *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__macro))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__macro(struct soap *soap, const char *tag, int id, ns2__macro *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__macro);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__macro ** SOAP_FMAC4 soap_in_PointerTons2__macro(struct soap *soap, const char *tag, ns2__macro **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__macro **)soap_malloc(soap, sizeof(ns2__macro *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__macro *)soap_instantiate_ns2__macro(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__macro ** p = (ns2__macro **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__macro, sizeof(ns2__macro), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__macro(struct soap *soap, ns2__macro *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__macro);
	if (soap_out_PointerTons2__macro(soap, tag?tag:"ns2:macro", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__macro ** SOAP_FMAC4 soap_get_PointerTons2__macro(struct soap *soap, ns2__macro **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__macro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToxsd__decimal);
	if (soap_out_PointerToxsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UUID(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UUID))
		soap_serialize_ns2__UUID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UUID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UUID);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UUID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__UUID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UUID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UUID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UUID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons2__UUID);
	if (soap_out_PointerTons2__UUID(soap, tag?tag:"ns2:UUID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__UUID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UUID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__allPassFilter(struct soap *soap, std::vector<ns2__allPassFilter * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__allPassFilter(struct soap *soap, const std::vector<ns2__allPassFilter * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__allPassFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__allPassFilter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__allPassFilter(struct soap *soap, const char *tag, int id, const std::vector<ns2__allPassFilter * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__allPassFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__allPassFilter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__allPassFilter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__allPassFilter(struct soap *soap, const char *tag, std::vector<ns2__allPassFilter * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__allPassFilter *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__allPassFilter, SOAP_TYPE_std__vectorTemplateOfPointerTons2__allPassFilter, sizeof(ns2__allPassFilter), 1))
				break;
			if (!soap_in_PointerTons2__allPassFilter(soap, tag, NULL, "ns2:allPassFilter"))
				break;
		}
		else if (!soap_in_PointerTons2__allPassFilter(soap, tag, &n, "ns2:allPassFilter"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__allPassFilter(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__allPassFilter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__allPassFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__allPassFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__allPassFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__allPassFilter * >);
		if (size)
			*size = sizeof(std::vector<ns2__allPassFilter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__allPassFilter * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__allPassFilter * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__allPassFilter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__allPassFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__allPassFilter * > %p -> %p\n", q, p));
	*(std::vector<ns2__allPassFilter * >*)p = *(std::vector<ns2__allPassFilter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__parametricFilter(struct soap *soap, std::vector<ns2__parametricFilter * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__parametricFilter(struct soap *soap, const std::vector<ns2__parametricFilter * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__parametricFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__parametricFilter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__parametricFilter(struct soap *soap, const char *tag, int id, const std::vector<ns2__parametricFilter * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__parametricFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__parametricFilter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__parametricFilter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__parametricFilter(struct soap *soap, const char *tag, std::vector<ns2__parametricFilter * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__parametricFilter *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__parametricFilter, SOAP_TYPE_std__vectorTemplateOfPointerTons2__parametricFilter, sizeof(ns2__parametricFilter), 1))
				break;
			if (!soap_in_PointerTons2__parametricFilter(soap, tag, NULL, "ns2:parametricFilter"))
				break;
		}
		else if (!soap_in_PointerTons2__parametricFilter(soap, tag, &n, "ns2:parametricFilter"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__parametricFilter(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__parametricFilter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__parametricFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__parametricFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__parametricFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__parametricFilter * >);
		if (size)
			*size = sizeof(std::vector<ns2__parametricFilter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__parametricFilter * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__parametricFilter * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__parametricFilter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__parametricFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__parametricFilter * > %p -> %p\n", q, p));
	*(std::vector<ns2__parametricFilter * >*)p = *(std::vector<ns2__parametricFilter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__shelfFilter(struct soap *soap, std::vector<ns2__shelfFilter * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__shelfFilter(struct soap *soap, const std::vector<ns2__shelfFilter * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__shelfFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__shelfFilter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__shelfFilter(struct soap *soap, const char *tag, int id, const std::vector<ns2__shelfFilter * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__shelfFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__shelfFilter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__shelfFilter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__shelfFilter(struct soap *soap, const char *tag, std::vector<ns2__shelfFilter * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__shelfFilter *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__shelfFilter, SOAP_TYPE_std__vectorTemplateOfPointerTons2__shelfFilter, sizeof(ns2__shelfFilter), 1))
				break;
			if (!soap_in_PointerTons2__shelfFilter(soap, tag, NULL, "ns2:shelfFilter"))
				break;
		}
		else if (!soap_in_PointerTons2__shelfFilter(soap, tag, &n, "ns2:shelfFilter"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__shelfFilter(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__shelfFilter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__shelfFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__shelfFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__shelfFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__shelfFilter * >);
		if (size)
			*size = sizeof(std::vector<ns2__shelfFilter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__shelfFilter * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__shelfFilter * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__shelfFilter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__shelfFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__shelfFilter * > %p -> %p\n", q, p));
	*(std::vector<ns2__shelfFilter * >*)p = *(std::vector<ns2__shelfFilter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__crossoverFilter(struct soap *soap, std::vector<ns2__crossoverFilter * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__crossoverFilter(struct soap *soap, const std::vector<ns2__crossoverFilter * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__crossoverFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__crossoverFilter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__crossoverFilter(struct soap *soap, const char *tag, int id, const std::vector<ns2__crossoverFilter * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__crossoverFilter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__crossoverFilter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__crossoverFilter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__crossoverFilter(struct soap *soap, const char *tag, std::vector<ns2__crossoverFilter * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__crossoverFilter *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__crossoverFilter, SOAP_TYPE_std__vectorTemplateOfPointerTons2__crossoverFilter, sizeof(ns2__crossoverFilter), 1))
				break;
			if (!soap_in_PointerTons2__crossoverFilter(soap, tag, NULL, "ns2:crossoverFilter"))
				break;
		}
		else if (!soap_in_PointerTons2__crossoverFilter(soap, tag, &n, "ns2:crossoverFilter"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__crossoverFilter(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__crossoverFilter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__crossoverFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__crossoverFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__crossoverFilter, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__crossoverFilter * >);
		if (size)
			*size = sizeof(std::vector<ns2__crossoverFilter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__crossoverFilter * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__crossoverFilter * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__crossoverFilter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__crossoverFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__crossoverFilter * > %p -> %p\n", q, p));
	*(std::vector<ns2__crossoverFilter * >*)p = *(std::vector<ns2__crossoverFilter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_ns2__alarm(struct soap *soap, std::vector<_ns2__alarm * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_ns2__alarm(struct soap *soap, const std::vector<_ns2__alarm * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__alarm * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_ns2__alarm(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_ns2__alarm(struct soap *soap, const char *tag, int id, const std::vector<_ns2__alarm * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns2__alarm * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_ns2__alarm(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__alarm * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_ns2__alarm(struct soap *soap, const char *tag, std::vector<_ns2__alarm * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	_ns2__alarm *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__ns2__alarm, SOAP_TYPE_std__vectorTemplateOfPointerTo_ns2__alarm, sizeof(_ns2__alarm), 1))
				break;
			if (!soap_in_PointerTo_ns2__alarm(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in_PointerTo_ns2__alarm(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_ns2__alarm(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__alarm * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTo_ns2__alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_ns2__alarm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_ns2__alarm, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_ns2__alarm * >);
		if (size)
			*size = sizeof(std::vector<_ns2__alarm * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_ns2__alarm * >, n);
		if (size)
			*size = n * sizeof(std::vector<_ns2__alarm * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_ns2__alarm * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_ns2__alarm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns2__alarm * > %p -> %p\n", q, p));
	*(std::vector<_ns2__alarm * >*)p = *(std::vector<_ns2__alarm * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__keyValuePair(struct soap *soap, std::vector<ns2__keyValuePair * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__keyValuePair(struct soap *soap, const std::vector<ns2__keyValuePair * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__keyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__keyValuePair(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__keyValuePair(struct soap *soap, const char *tag, int id, const std::vector<ns2__keyValuePair * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__keyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__keyValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__keyValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__keyValuePair(struct soap *soap, const char *tag, std::vector<ns2__keyValuePair * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__keyValuePair *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__keyValuePair, SOAP_TYPE_std__vectorTemplateOfPointerTons2__keyValuePair, sizeof(ns2__keyValuePair), 1))
				break;
			if (!soap_in_PointerTons2__keyValuePair(soap, tag, NULL, "ns2:keyValuePair"))
				break;
		}
		else if (!soap_in_PointerTons2__keyValuePair(soap, tag, &n, "ns2:keyValuePair"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__keyValuePair(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__keyValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__keyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__keyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__keyValuePair, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__keyValuePair * >);
		if (size)
			*size = sizeof(std::vector<ns2__keyValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__keyValuePair * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__keyValuePair * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__keyValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__keyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__keyValuePair * > %p -> %p\n", q, p));
	*(std::vector<ns2__keyValuePair * >*)p = *(std::vector<ns2__keyValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__integer(struct soap *soap, std::vector<std::string >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__integer(struct soap *soap, const std::vector<std::string >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__integer(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__integer(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__integer(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__integer(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__integer(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__integer, SOAP_TYPE_std__vectorTemplateOfxsd__integer, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__integer(soap, tag, NULL, "xsd:integer"))
				break;
		}
		else if (!soap_in_xsd__integer(soap, tag, &n, "xsd:integer"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__integer(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__integer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__integer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__integer, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__integer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__macro(struct soap *soap, std::vector<ns2__macro * >*p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__macro(struct soap *soap, const std::vector<ns2__macro * >*a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__macro * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__macro(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__macro(struct soap *soap, const char *tag, int id, const std::vector<ns2__macro * >*a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__macro * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__macro(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__macro * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__macro(struct soap *soap, const char *tag, std::vector<ns2__macro * >*a, const char *type)
{
	short soap_flag;
	(void)type; /* appease -Wall -Werror */
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__macro *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__macro, SOAP_TYPE_std__vectorTemplateOfPointerTons2__macro, sizeof(ns2__macro), 1))
				break;
			if (!soap_in_PointerTons2__macro(soap, tag, NULL, "ns2:macro"))
				break;
		}
		else if (!soap_in_PointerTons2__macro(soap, tag, &n, "ns2:macro"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__macro(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__macro * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__macro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__macro(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__macro, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__macro * >);
		if (size)
			*size = sizeof(std::vector<ns2__macro * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__macro * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__macro * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__macro * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__macro(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__macro * > %p -> %p\n", q, p));
	*(std::vector<ns2__macro * >*)p = *(std::vector<ns2__macro * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
