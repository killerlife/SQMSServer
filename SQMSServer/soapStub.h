/* soapStub.h
   Generated by gSOAP 2.8.21 from cp850.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://www.dolby.com/cp/ws/smi/v1/schemas/systemmanagement"
#define SOAP_NAMESPACE_OF_ns3	"http://www.dolby.com/cp/ws/smi/v1_0"
#define SOAP_NAMESPACE_OF_ns4	"http://www.dolby.com/cp/ws/smi/v1_1"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20821
# error "GSOAP VERSION 20821 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns2__MPAARating
#define SOAP_TYPE_ns2__MPAARating (90)
/* ns2:MPAARating */
enum ns2__MPAARating { ns2__MPAARating__G = 0, ns2__MPAARating__PG = 1, ns2__MPAARating__PG_13 = 2, ns2__MPAARating__NC_17 = 3, ns2__MPAARating__R = 4, ns2__MPAARating__X = 5, ns2__MPAARating__unrated = 6, ns2__MPAARating__unknown = 7 };
#endif

#ifndef SOAP_TYPE_ns2__ErrorType
#define SOAP_TYPE_ns2__ErrorType (91)
/* ns2:ErrorType */
enum ns2__ErrorType { ns2__ErrorType__missing = 0, ns2__ErrorType__corrupt = 1, ns2__ErrorType__not_licensed = 2, ns2__ErrorType__not_clip = 3, ns2__ErrorType__not_still = 4, ns2__ErrorType__transferring = 5, ns2__ErrorType__unsupported = 6 };
#endif

#ifndef SOAP_TYPE_ns2__LensFormat
#define SOAP_TYPE_ns2__LensFormat (94)
/* ns2:LensFormat */
enum ns2__LensFormat { ns2__LensFormat__flat = 0, ns2__LensFormat__anamorphic = 1, ns2__LensFormat__unknown = 2 };
#endif

#ifndef SOAP_TYPE_ns2__CueMarkerType
#define SOAP_TYPE_ns2__CueMarkerType (95)
/* ns2:CueMarkerType */
enum ns2__CueMarkerType { ns2__CueMarkerType__clipStart = 0, ns2__CueMarkerType__clipEnd = 1, ns2__CueMarkerType__FFOC = 2, ns2__CueMarkerType__LFOC = 3, ns2__CueMarkerType__FFTC = 4, ns2__CueMarkerType__LFTC = 5, ns2__CueMarkerType__FFOI = 6, ns2__CueMarkerType__LFOI = 7, ns2__CueMarkerType__FFEC = 8, ns2__CueMarkerType__LFEC = 9, ns2__CueMarkerType__FFOB = 10, ns2__CueMarkerType__LFOB = 11, ns2__CueMarkerType__FFMC = 12, ns2__CueMarkerType__LFMC = 13 };
#endif

#ifndef SOAP_TYPE_ns2__Category
#define SOAP_TYPE_ns2__Category (96)
/* ns2:Category */
enum ns2__Category { ns2__Category__feature = 0, ns2__Category__trailer = 1, ns2__Category__advertisement = 2, ns2__Category__policy = 3, ns2__Category__test = 4, ns2__Category__unknown = 5, ns2__Category__transitional = 6, ns2__Category__teaser = 7, ns2__Category__rating = 8, ns2__Category__short_ = 9, ns2__Category__psa = 10 };
#endif

#ifndef SOAP_TYPE_ns2__StorageType
#define SOAP_TYPE_ns2__StorageType (97)
/* ns2:StorageType */
enum ns2__StorageType { ns2__StorageType__MainStore = 0, ns2__StorageType__Removable = 1, ns2__StorageType__DVD = 2, ns2__StorageType__USB = 3, ns2__StorageType__SasStore = 4, ns2__StorageType__NetworkStore = 5, ns2__StorageType__ModemStore = 6, ns2__StorageType__Unknown = 7 };
#endif

#ifndef SOAP_TYPE_ns2__TransferType
#define SOAP_TYPE_ns2__TransferType (98)
/* ns2:TransferType */
enum ns2__TransferType { ns2__TransferType__CPL = 0, ns2__TransferType__KDM = 1, ns2__TransferType__PKL = 2, ns2__TransferType__SPL = 3, ns2__TransferType__UNKNOWN = 4 };
#endif

#ifndef SOAP_TYPE_ns2__CueType
#define SOAP_TYPE_ns2__CueType (99)
/* ns2:CueType */
enum ns2__CueType { ns2__CueType__light = 0, ns2__CueType__audio = 1, ns2__CueType__projector = 2, ns2__CueType__other = 3 };
#endif

#ifndef SOAP_TYPE_ns2__crossoverSlope
#define SOAP_TYPE_ns2__crossoverSlope (100)
/* ns2:crossoverSlope */
enum ns2__crossoverSlope { ns2__crossoverSlope__6dB = 0, ns2__crossoverSlope__12dB = 1, ns2__crossoverSlope__18dB = 2, ns2__crossoverSlope__24dB = 3, ns2__crossoverSlope__30dB = 4, ns2__crossoverSlope__36dB = 5, ns2__crossoverSlope__42dB = 6, ns2__crossoverSlope__48dB = 7, ns2__crossoverSlope__Brickwall = 8 };
#endif

#ifndef SOAP_TYPE_ns2__crossoverType
#define SOAP_TYPE_ns2__crossoverType (101)
/* ns2:crossoverType */
enum ns2__crossoverType { ns2__crossoverType__LowPass = 0, ns2__crossoverType__HighPass = 1, ns2__crossoverType__BandPass = 2 };
#endif

#ifndef SOAP_TYPE_ns2__crossoverFilterType
#define SOAP_TYPE_ns2__crossoverFilterType (102)
/* ns2:crossoverFilterType */
enum ns2__crossoverFilterType { ns2__crossoverFilterType__Bessel = 0, ns2__crossoverFilterType__Butterworth = 1, ns2__crossoverFilterType__Linkwitzriley = 2, ns2__crossoverFilterType__Crosssplit = 3, ns2__crossoverFilterType__Linphase = 4 };
#endif

#ifndef SOAP_TYPE_ns2__shelfType
#define SOAP_TYPE_ns2__shelfType (103)
/* ns2:shelfType */
enum ns2__shelfType { ns2__shelfType__Low = 0, ns2__shelfType__High = 1 };
#endif

#ifndef SOAP_TYPE_ns2__atmosContentStatus
#define SOAP_TYPE_ns2__atmosContentStatus (105)
/* ns2:atmosContentStatus */
enum ns2__atmosContentStatus { ns2__atmosContentStatus__dolbyAtmos = 0, ns2__atmosContentStatus__pcm = 1, ns2__atmosContentStatus__pcmWhenAtmosExpected = 2 };
#endif

#ifndef SOAP_TYPE_ns2__audioStreamType
#define SOAP_TYPE_ns2__audioStreamType (106)
/* ns2:audioStreamType */
enum ns2__audioStreamType { ns2__audioStreamType__dolbyDigital = 0, ns2__audioStreamType__dolbyDigitalPlus = 1, ns2__audioStreamType__pcm = 2, ns2__audioStreamType__dolbyE = 3 };
#endif

#ifndef SOAP_TYPE_ns2__acmod
#define SOAP_TYPE_ns2__acmod (107)
/* ns2:acmod */
enum ns2__acmod { ns2__acmod__1_x002b1 = 0, ns2__acmod__1_x002e0 = 1, ns2__acmod__2_x002e0 = 2, ns2__acmod__3_x002e0 = 3, ns2__acmod__2_x002e1 = 4, ns2__acmod__3_x002e1 = 5, ns2__acmod__4_x002e1 = 6, ns2__acmod__5_x002e1 = 7, ns2__acmod__6_x002e1 = 8, ns2__acmod__7_x002e1 = 9 };
#endif

#ifndef SOAP_TYPE_ns2__bedChannelId
#define SOAP_TYPE_ns2__bedChannelId (108)
/* ns2:bedChannelId */
enum ns2__bedChannelId { ns2__bedChannelId__l = 0, ns2__bedChannelId__r = 1, ns2__bedChannelId__c = 2, ns2__bedChannelId__lfe = 3, ns2__bedChannelId__lss = 4, ns2__bedChannelId__rss = 5, ns2__bedChannelId__lrs = 6, ns2__bedChannelId__rrs = 7, ns2__bedChannelId__lts = 8, ns2__bedChannelId__rts = 9, ns2__bedChannelId__lc = 10, ns2__bedChannelId__rc = 11, ns2__bedChannelId__ls = 12, ns2__bedChannelId__rs = 13, ns2__bedChannelId__lw = 14, ns2__bedChannelId__rw = 15, ns2__bedChannelId__cts = 16, ns2__bedChannelId__crs = 17 };
#endif

#ifndef SOAP_TYPE_ns2__testSignalType
#define SOAP_TYPE_ns2__testSignalType (109)
/* ns2:testSignalType */
enum ns2__testSignalType { ns2__testSignalType__none = 0, ns2__testSignalType__pinkNoise = 1, ns2__testSignalType__sine100Hz = 2, ns2__testSignalType__sine1kHz = 3, ns2__testSignalType__sine10kHz = 4, ns2__testSignalType__thump = 5, ns2__testSignalType__program = 6, ns2__testSignalType__sweep = 7 };
#endif

#ifndef SOAP_TYPE_ns2__lastAtmosConfigPushStatus
#define SOAP_TYPE_ns2__lastAtmosConfigPushStatus (110)
/* ns2:lastAtmosConfigPushStatus */
enum ns2__lastAtmosConfigPushStatus { ns2__lastAtmosConfigPushStatus__SUCCESS = 0, ns2__lastAtmosConfigPushStatus__PENDING = 1, ns2__lastAtmosConfigPushStatus__ERROR = 2 };
#endif

#ifndef SOAP_TYPE_ns2__lastAtmosConfigPushErrorType
#define SOAP_TYPE_ns2__lastAtmosConfigPushErrorType (111)
/* ns2:lastAtmosConfigPushErrorType */
enum ns2__lastAtmosConfigPushErrorType { ns2__lastAtmosConfigPushErrorType__NO_USCOREERROR = 0, ns2__lastAtmosConfigPushErrorType__UNKNOWN_USCOREERROR = 1, ns2__lastAtmosConfigPushErrorType__VALIDATION_USCOREERROR = 2, ns2__lastAtmosConfigPushErrorType__ENABLEMENT_USCOREDISABLED_USCOREDIGITAL_USCOREOUTPUTS = 3, ns2__lastAtmosConfigPushErrorType__ENABLEMENT_USCOREDISABLED_USCOREATMOS = 4, ns2__lastAtmosConfigPushErrorType__ENABLEMENT_USCOREDISABLED_USCOREINTERNAL_USCOREXOVERS = 5 };
#endif

#ifndef SOAP_TYPE_ns2__testSignalOutputMode
#define SOAP_TYPE_ns2__testSignalOutputMode (112)
/* ns2:testSignalOutputMode */
enum ns2__testSignalOutputMode { ns2__testSignalOutputMode__speaker = 0, ns2__testSignalOutputMode__array = 1, ns2__testSignalOutputMode__object = 2 };
#endif

#ifndef SOAP_TYPE_ns2__testSignalObjectPath
#define SOAP_TYPE_ns2__testSignalObjectPath (113)
/* ns2:testSignalObjectPath */
enum ns2__testSignalObjectPath { ns2__testSignalObjectPath__allSpeakersContinuous = 0, ns2__testSignalObjectPath__allSpeakersSnap = 1 };
#endif

#ifndef SOAP_TYPE_ns2__polarity
#define SOAP_TYPE_ns2__polarity (115)
/* ns2:polarity */
enum ns2__polarity { ns2__polarity__normal = 0, ns2__polarity__inverted = 1 };
#endif

#ifndef SOAP_TYPE__ns2__alarm_severity
#define SOAP_TYPE__ns2__alarm_severity (123)
/* ns2:alarm-severity */
enum _ns2__alarm_severity { _ns2__alarm_severity__warning = 0, _ns2__alarm_severity__error = 1 };
#endif

#ifndef SOAP_TYPE__ns2__alarm_type
#define SOAP_TYPE__ns2__alarm_type (124)
/* ns2:alarm-type */
enum _ns2__alarm_type { _ns2__alarm_type__disk = 0, _ns2__alarm_type__fan = 1, _ns2__alarm_type__temperature = 2, _ns2__alarm_type__hardware = 3, _ns2__alarm_type__software = 4, _ns2__alarm_type__offline = 5, _ns2__alarm_type__power = 6 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns2__crossoverFilter
#define SOAP_TYPE_ns2__crossoverFilter (12)
/* ns2:crossoverFilter */
class SOAP_CMAC ns2__crossoverFilter
{
public:
	std::string id;	/* required element of type ns2:filterID */
	float frequency;	/* required element of type xsd:float */
	enum ns2__crossoverSlope slope;	/* required element of type ns2:crossoverSlope */
	enum ns2__crossoverFilterType filterType;	/* required element of type ns2:crossoverFilterType */
	enum ns2__crossoverType type;	/* required element of type ns2:crossoverType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE_ns2__crossoverFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__crossoverFilter() { ns2__crossoverFilter::soap_default(NULL); }
	virtual ~ns2__crossoverFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__shelfFilter
#define SOAP_TYPE_ns2__shelfFilter (13)
/* ns2:shelfFilter */
class SOAP_CMAC ns2__shelfFilter
{
public:
	std::string id;	/* required element of type ns2:filterID */
	float frequency;	/* required element of type xsd:float */
	float bw;	/* required element of type xsd:float */
	float gain;	/* required element of type xsd:float */
	enum ns2__shelfType type;	/* required element of type ns2:shelfType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique type id SOAP_TYPE_ns2__shelfFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__shelfFilter() { ns2__shelfFilter::soap_default(NULL); }
	virtual ~ns2__shelfFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__parametricFilter
#define SOAP_TYPE_ns2__parametricFilter (14)
/* ns2:parametricFilter */
class SOAP_CMAC ns2__parametricFilter
{
public:
	std::string id;	/* required element of type ns2:filterID */
	float frequency;	/* required element of type xsd:float */
	float bw;	/* required element of type xsd:float */
	float gain;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE_ns2__parametricFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__parametricFilter() { ns2__parametricFilter::soap_default(NULL); }
	virtual ~ns2__parametricFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__allPassFilter
#define SOAP_TYPE_ns2__allPassFilter (15)
/* ns2:allPassFilter */
class SOAP_CMAC ns2__allPassFilter
{
public:
	std::string id;	/* required element of type ns2:filterID */
	float frequency;	/* required element of type xsd:float */
	float bw;	/* required element of type xsd:float */
	std::string order;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_ns2__allPassFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__allPassFilter() { ns2__allPassFilter::soap_default(NULL); }
	virtual ~ns2__allPassFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__macro
#define SOAP_TYPE_ns2__macro (16)
/* ns2:macro */
class SOAP_CMAC ns2__macro
{
public:
	std::string id;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_ns2__macro */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__macro() { ns2__macro::soap_default(NULL); }
	virtual ~ns2__macro() { }
};
#endif

#ifndef SOAP_TYPE_ns2__fault
#define SOAP_TYPE_ns2__fault (17)
/* ns2:fault */
class SOAP_CMAC ns2__fault
{
public:
	std::string *reason;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_ns2__fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__fault() { ns2__fault::soap_default(NULL); }
	virtual ~ns2__fault() { }
};
#endif

#ifndef SOAP_TYPE_ns2__audioStreamInfo
#define SOAP_TYPE_ns2__audioStreamInfo (18)
/* ns2:audioStreamInfo */
class SOAP_CMAC ns2__audioStreamInfo
{
public:
	enum ns2__audioStreamType type;	/* required element of type ns2:audioStreamType */
	enum ns2__acmod acmod;	/* required element of type ns2:acmod */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_ns2__audioStreamInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__audioStreamInfo() { ns2__audioStreamInfo::soap_default(NULL); }
	virtual ~ns2__audioStreamInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__keyValuePair
#define SOAP_TYPE_ns2__keyValuePair (19)
/* ns2:keyValuePair */
class SOAP_CMAC ns2__keyValuePair
{
public:
	std::string key;	/* required element of type xsd:string */
	std::string value;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_ns2__keyValuePair */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__keyValuePair() { ns2__keyValuePair::soap_default(NULL); }
	virtual ~ns2__keyValuePair() { }
};
#endif

#ifndef SOAP_TYPE__ns2__alarm
#define SOAP_TYPE__ns2__alarm (20)
/* ns2:alarm */
class SOAP_CMAC _ns2__alarm
{
public:
	std::string *alarmId;	/* optional attribute */
	std::string *timestamp;	/* optional attribute */
	bool *clearable;	/* optional attribute */
	std::string id;	/* required attribute */
	enum _ns2__alarm_severity severity;	/* required attribute */
	enum _ns2__alarm_type type;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE__ns2__alarm */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__alarm() { _ns2__alarm::soap_default(NULL); }
	virtual ~_ns2__alarm() { }
};
#endif

#ifndef SOAP_TYPE__ns3__listMacrosRequest
#define SOAP_TYPE__ns3__listMacrosRequest (21)
/* ns3:listMacrosRequest */
class SOAP_CMAC _ns3__listMacrosRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE__ns3__listMacrosRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__listMacrosRequest() { _ns3__listMacrosRequest::soap_default(NULL); }
	virtual ~_ns3__listMacrosRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__listMacrosResponse
#define SOAP_TYPE__ns3__listMacrosResponse (22)
/* ns3:listMacrosResponse */
class SOAP_CMAC _ns3__listMacrosResponse
{
public:
	std::vector<ns2__macro * >macros;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:macro */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE__ns3__listMacrosResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__listMacrosResponse() { _ns3__listMacrosResponse::soap_default(NULL); }
	virtual ~_ns3__listMacrosResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getCurrentMacroRequest
#define SOAP_TYPE__ns3__getCurrentMacroRequest (23)
/* ns3:getCurrentMacroRequest */
class SOAP_CMAC _ns3__getCurrentMacroRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE__ns3__getCurrentMacroRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getCurrentMacroRequest() { _ns3__getCurrentMacroRequest::soap_default(NULL); }
	virtual ~_ns3__getCurrentMacroRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getCurrentMacroResponse
#define SOAP_TYPE__ns3__getCurrentMacroResponse (24)
/* ns3:getCurrentMacroResponse */
class SOAP_CMAC _ns3__getCurrentMacroResponse
{
public:
	ns2__macro *macro;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:macro */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE__ns3__getCurrentMacroResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getCurrentMacroResponse() { _ns3__getCurrentMacroResponse::soap_default(NULL); }
	virtual ~_ns3__getCurrentMacroResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setCurrentMacroRequest
#define SOAP_TYPE__ns3__setCurrentMacroRequest (25)
/* ns3:setCurrentMacroRequest */
class SOAP_CMAC _ns3__setCurrentMacroRequest
{
public:
	std::string id;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE__ns3__setCurrentMacroRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setCurrentMacroRequest() { _ns3__setCurrentMacroRequest::soap_default(NULL); }
	virtual ~_ns3__setCurrentMacroRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setCurrentMacroResponse
#define SOAP_TYPE__ns3__setCurrentMacroResponse (26)
/* ns3:setCurrentMacroResponse */
class SOAP_CMAC _ns3__setCurrentMacroResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE__ns3__setCurrentMacroResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setCurrentMacroResponse() { _ns3__setCurrentMacroResponse::soap_default(NULL); }
	virtual ~_ns3__setCurrentMacroResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getGainRequest
#define SOAP_TYPE__ns3__getGainRequest (27)
/* ns3:getGainRequest */
class SOAP_CMAC _ns3__getGainRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE__ns3__getGainRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getGainRequest() { _ns3__getGainRequest::soap_default(NULL); }
	virtual ~_ns3__getGainRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getGainResponse
#define SOAP_TYPE__ns3__getGainResponse (28)
/* ns3:getGainResponse */
class SOAP_CMAC _ns3__getGainResponse
{
public:
	std::string gain;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE__ns3__getGainResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getGainResponse() { _ns3__getGainResponse::soap_default(NULL); }
	virtual ~_ns3__getGainResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setGainRequest
#define SOAP_TYPE__ns3__setGainRequest (29)
/* ns3:setGainRequest */
class SOAP_CMAC _ns3__setGainRequest
{
public:
	std::string gain;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE__ns3__setGainRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setGainRequest() { _ns3__setGainRequest::soap_default(NULL); }
	virtual ~_ns3__setGainRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setGainResponse
#define SOAP_TYPE__ns3__setGainResponse (30)
/* ns3:setGainResponse */
class SOAP_CMAC _ns3__setGainResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE__ns3__setGainResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setGainResponse() { _ns3__setGainResponse::soap_default(NULL); }
	virtual ~_ns3__setGainResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getMuteRequest
#define SOAP_TYPE__ns3__getMuteRequest (31)
/* ns3:getMuteRequest */
class SOAP_CMAC _ns3__getMuteRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE__ns3__getMuteRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getMuteRequest() { _ns3__getMuteRequest::soap_default(NULL); }
	virtual ~_ns3__getMuteRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getMuteResponse
#define SOAP_TYPE__ns3__getMuteResponse (32)
/* ns3:getMuteResponse */
class SOAP_CMAC _ns3__getMuteResponse
{
public:
	bool isMuted;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE__ns3__getMuteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getMuteResponse() { _ns3__getMuteResponse::soap_default(NULL); }
	virtual ~_ns3__getMuteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setMuteRequest
#define SOAP_TYPE__ns3__setMuteRequest (33)
/* ns3:setMuteRequest */
class SOAP_CMAC _ns3__setMuteRequest
{
public:
	bool shouldBeMuted;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE__ns3__setMuteRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setMuteRequest() { _ns3__setMuteRequest::soap_default(NULL); }
	virtual ~_ns3__setMuteRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setMuteResponse
#define SOAP_TYPE__ns3__setMuteResponse (34)
/* ns3:setMuteResponse */
class SOAP_CMAC _ns3__setMuteResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE__ns3__setMuteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setMuteResponse() { _ns3__setMuteResponse::soap_default(NULL); }
	virtual ~_ns3__setMuteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isAtmosContentRequest
#define SOAP_TYPE__ns3__isAtmosContentRequest (35)
/* ns3:isAtmosContentRequest */
class SOAP_CMAC _ns3__isAtmosContentRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE__ns3__isAtmosContentRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isAtmosContentRequest() { _ns3__isAtmosContentRequest::soap_default(NULL); }
	virtual ~_ns3__isAtmosContentRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isAtmosContentResponse
#define SOAP_TYPE__ns3__isAtmosContentResponse (36)
/* ns3:isAtmosContentResponse */
class SOAP_CMAC _ns3__isAtmosContentResponse
{
public:
	enum ns2__atmosContentStatus status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:atmosContentStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE__ns3__isAtmosContentResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isAtmosContentResponse() { _ns3__isAtmosContentResponse::soap_default(NULL); }
	virtual ~_ns3__isAtmosContentResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getAudioStreamInfoRequest
#define SOAP_TYPE__ns3__getAudioStreamInfoRequest (37)
/* ns3:getAudioStreamInfoRequest */
class SOAP_CMAC _ns3__getAudioStreamInfoRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE__ns3__getAudioStreamInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getAudioStreamInfoRequest() { _ns3__getAudioStreamInfoRequest::soap_default(NULL); }
	virtual ~_ns3__getAudioStreamInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getAudioStreamInfoResponse
#define SOAP_TYPE__ns3__getAudioStreamInfoResponse (38)
/* ns3:getAudioStreamInfoResponse */
class SOAP_CMAC _ns3__getAudioStreamInfoResponse
{
public:
	ns2__audioStreamInfo *info;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:audioStreamInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE__ns3__getAudioStreamInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getAudioStreamInfoResponse() { _ns3__getAudioStreamInfoResponse::soap_default(NULL); }
	virtual ~_ns3__getAudioStreamInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getAtmosConfigRequest
#define SOAP_TYPE__ns3__getAtmosConfigRequest (39)
/* ns3:getAtmosConfigRequest */
class SOAP_CMAC _ns3__getAtmosConfigRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE__ns3__getAtmosConfigRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getAtmosConfigRequest() { _ns3__getAtmosConfigRequest::soap_default(NULL); }
	virtual ~_ns3__getAtmosConfigRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getAtmosConfigResponse
#define SOAP_TYPE__ns3__getAtmosConfigResponse (40)
/* ns3:getAtmosConfigResponse */
class SOAP_CMAC _ns3__getAtmosConfigResponse
{
public:
	std::string name;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	std::string config;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE__ns3__getAtmosConfigResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getAtmosConfigResponse() { _ns3__getAtmosConfigResponse::soap_default(NULL); }
	virtual ~_ns3__getAtmosConfigResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setAtmosConfigRequest
#define SOAP_TYPE__ns3__setAtmosConfigRequest (41)
/* ns3:setAtmosConfigRequest */
class SOAP_CMAC _ns3__setAtmosConfigRequest
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string config;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE__ns3__setAtmosConfigRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setAtmosConfigRequest() { _ns3__setAtmosConfigRequest::soap_default(NULL); }
	virtual ~_ns3__setAtmosConfigRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setAtmosConfigResponse
#define SOAP_TYPE__ns3__setAtmosConfigResponse (42)
/* ns3:setAtmosConfigResponse */
class SOAP_CMAC _ns3__setAtmosConfigResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE__ns3__setAtmosConfigResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setAtmosConfigResponse() { _ns3__setAtmosConfigResponse::soap_default(NULL); }
	virtual ~_ns3__setAtmosConfigResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getAtmosConfigInfoRequest
#define SOAP_TYPE__ns3__getAtmosConfigInfoRequest (43)
/* ns3:getAtmosConfigInfoRequest */
class SOAP_CMAC _ns3__getAtmosConfigInfoRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE__ns3__getAtmosConfigInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getAtmosConfigInfoRequest() { _ns3__getAtmosConfigInfoRequest::soap_default(NULL); }
	virtual ~_ns3__getAtmosConfigInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getAtmosConfigInfoResponse
#define SOAP_TYPE__ns3__getAtmosConfigInfoResponse (44)
/* ns3:getAtmosConfigInfoResponse */
class SOAP_CMAC _ns3__getAtmosConfigInfoResponse
{
public:
	std::string uuid;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	std::string name;	/* required element of type xsd:string */
	time_t lastModifiedDateTime;	/* required element of type xsd:dateTime */
	enum ns2__lastAtmosConfigPushStatus *status;	/* optional element of type ns2:lastAtmosConfigPushStatus */
	enum ns2__lastAtmosConfigPushErrorType *errorType;	/* optional element of type ns2:lastAtmosConfigPushErrorType */
	std::string *errorMessage;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE__ns3__getAtmosConfigInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getAtmosConfigInfoResponse() { _ns3__getAtmosConfigInfoResponse::soap_default(NULL); }
	virtual ~_ns3__getAtmosConfigInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getTestSignalOutputRequest
#define SOAP_TYPE__ns3__getTestSignalOutputRequest (45)
/* ns3:getTestSignalOutputRequest */
class SOAP_CMAC _ns3__getTestSignalOutputRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE__ns3__getTestSignalOutputRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getTestSignalOutputRequest() { _ns3__getTestSignalOutputRequest::soap_default(NULL); }
	virtual ~_ns3__getTestSignalOutputRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getTestSignalOutputResponse
#define SOAP_TYPE__ns3__getTestSignalOutputResponse (46)
/* ns3:getTestSignalOutputResponse */
class SOAP_CMAC _ns3__getTestSignalOutputResponse
{
public:
	enum ns2__testSignalOutputMode outputMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:testSignalOutputMode */
	std::vector<std::string >speakerIndex;	/* optional element of type xsd:integer */
	enum ns2__bedChannelId *array;	/* optional element of type ns2:bedChannelId */
	enum ns2__testSignalObjectPath *objectPath;	/* optional element of type ns2:testSignalObjectPath */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE__ns3__getTestSignalOutputResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getTestSignalOutputResponse() { _ns3__getTestSignalOutputResponse::soap_default(NULL); }
	virtual ~_ns3__getTestSignalOutputResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setTestSignalOutputRequest
#define SOAP_TYPE__ns3__setTestSignalOutputRequest (47)
/* ns3:setTestSignalOutputRequest */
class SOAP_CMAC _ns3__setTestSignalOutputRequest
{
public:
	enum ns2__testSignalOutputMode outputMode;	/* required element of type ns2:testSignalOutputMode */
	std::vector<std::string >speakerIndex;	/* optional element of type xsd:integer */
	enum ns2__bedChannelId *array;	/* optional element of type ns2:bedChannelId */
	enum ns2__testSignalObjectPath *objectPath;	/* optional element of type ns2:testSignalObjectPath */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE__ns3__setTestSignalOutputRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setTestSignalOutputRequest() { _ns3__setTestSignalOutputRequest::soap_default(NULL); }
	virtual ~_ns3__setTestSignalOutputRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setTestSignalOutputResponse
#define SOAP_TYPE__ns3__setTestSignalOutputResponse (48)
/* ns3:setTestSignalOutputResponse */
class SOAP_CMAC _ns3__setTestSignalOutputResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE__ns3__setTestSignalOutputResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setTestSignalOutputResponse() { _ns3__setTestSignalOutputResponse::soap_default(NULL); }
	virtual ~_ns3__setTestSignalOutputResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getTestSignalModeRequest
#define SOAP_TYPE__ns3__getTestSignalModeRequest (49)
/* ns3:getTestSignalModeRequest */
class SOAP_CMAC _ns3__getTestSignalModeRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE__ns3__getTestSignalModeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getTestSignalModeRequest() { _ns3__getTestSignalModeRequest::soap_default(NULL); }
	virtual ~_ns3__getTestSignalModeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getTestSignalModeResponse
#define SOAP_TYPE__ns3__getTestSignalModeResponse (50)
/* ns3:getTestSignalModeResponse */
class SOAP_CMAC _ns3__getTestSignalModeResponse
{
public:
	enum ns2__testSignalType signalType;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:testSignalType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE__ns3__getTestSignalModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getTestSignalModeResponse() { _ns3__getTestSignalModeResponse::soap_default(NULL); }
	virtual ~_ns3__getTestSignalModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setTestSignalModeRequest
#define SOAP_TYPE__ns3__setTestSignalModeRequest (51)
/* ns3:setTestSignalModeRequest */
class SOAP_CMAC _ns3__setTestSignalModeRequest
{
public:
	enum ns2__testSignalType signalType;	/* required element of type ns2:testSignalType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE__ns3__setTestSignalModeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setTestSignalModeRequest() { _ns3__setTestSignalModeRequest::soap_default(NULL); }
	virtual ~_ns3__setTestSignalModeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setTestSignalModeResponse
#define SOAP_TYPE__ns3__setTestSignalModeResponse (52)
/* ns3:setTestSignalModeResponse */
class SOAP_CMAC _ns3__setTestSignalModeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE__ns3__setTestSignalModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setTestSignalModeResponse() { _ns3__setTestSignalModeResponse::soap_default(NULL); }
	virtual ~_ns3__setTestSignalModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isBassManagementEnabledRequest
#define SOAP_TYPE__ns3__isBassManagementEnabledRequest (53)
/* ns3:isBassManagementEnabledRequest */
class SOAP_CMAC _ns3__isBassManagementEnabledRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE__ns3__isBassManagementEnabledRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isBassManagementEnabledRequest() { _ns3__isBassManagementEnabledRequest::soap_default(NULL); }
	virtual ~_ns3__isBassManagementEnabledRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isBassManagementEnabledResponse
#define SOAP_TYPE__ns3__isBassManagementEnabledResponse (54)
/* ns3:isBassManagementEnabledResponse */
class SOAP_CMAC _ns3__isBassManagementEnabledResponse
{
public:
	bool enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE__ns3__isBassManagementEnabledResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isBassManagementEnabledResponse() { _ns3__isBassManagementEnabledResponse::soap_default(NULL); }
	virtual ~_ns3__isBassManagementEnabledResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__enableBassManagementRequest
#define SOAP_TYPE__ns3__enableBassManagementRequest (55)
/* ns3:enableBassManagementRequest */
class SOAP_CMAC _ns3__enableBassManagementRequest
{
public:
	bool enable;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE__ns3__enableBassManagementRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__enableBassManagementRequest() { _ns3__enableBassManagementRequest::soap_default(NULL); }
	virtual ~_ns3__enableBassManagementRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__enableBassManagementResponse
#define SOAP_TYPE__ns3__enableBassManagementResponse (56)
/* ns3:enableBassManagementResponse */
class SOAP_CMAC _ns3__enableBassManagementResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE__ns3__enableBassManagementResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__enableBassManagementResponse() { _ns3__enableBassManagementResponse::soap_default(NULL); }
	virtual ~_ns3__enableBassManagementResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isGlobalEqEnabledRequest
#define SOAP_TYPE__ns3__isGlobalEqEnabledRequest (57)
/* ns3:isGlobalEqEnabledRequest */
class SOAP_CMAC _ns3__isGlobalEqEnabledRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE__ns3__isGlobalEqEnabledRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isGlobalEqEnabledRequest() { _ns3__isGlobalEqEnabledRequest::soap_default(NULL); }
	virtual ~_ns3__isGlobalEqEnabledRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isGlobalEqEnabledResponse
#define SOAP_TYPE__ns3__isGlobalEqEnabledResponse (58)
/* ns3:isGlobalEqEnabledResponse */
class SOAP_CMAC _ns3__isGlobalEqEnabledResponse
{
public:
	bool enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE__ns3__isGlobalEqEnabledResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isGlobalEqEnabledResponse() { _ns3__isGlobalEqEnabledResponse::soap_default(NULL); }
	virtual ~_ns3__isGlobalEqEnabledResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__enableGlobalEqRequest
#define SOAP_TYPE__ns3__enableGlobalEqRequest (59)
/* ns3:enableGlobalEqRequest */
class SOAP_CMAC _ns3__enableGlobalEqRequest
{
public:
	bool enable;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE__ns3__enableGlobalEqRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__enableGlobalEqRequest() { _ns3__enableGlobalEqRequest::soap_default(NULL); }
	virtual ~_ns3__enableGlobalEqRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__enableGlobalEqResponse
#define SOAP_TYPE__ns3__enableGlobalEqResponse (60)
/* ns3:enableGlobalEqResponse */
class SOAP_CMAC _ns3__enableGlobalEqResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE__ns3__enableGlobalEqResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__enableGlobalEqResponse() { _ns3__enableGlobalEqResponse::soap_default(NULL); }
	virtual ~_ns3__enableGlobalEqResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getDeviceInfoRequest
#define SOAP_TYPE__ns3__getDeviceInfoRequest (61)
/* ns3:getDeviceInfoRequest */
class SOAP_CMAC _ns3__getDeviceInfoRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE__ns3__getDeviceInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getDeviceInfoRequest() { _ns3__getDeviceInfoRequest::soap_default(NULL); }
	virtual ~_ns3__getDeviceInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getDeviceInfoResponse
#define SOAP_TYPE__ns3__getDeviceInfoResponse (62)
/* ns3:getDeviceInfoResponse */
class SOAP_CMAC _ns3__getDeviceInfoResponse
{
public:
	std::vector<ns2__keyValuePair * >keyValuePair;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:keyValuePair */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE__ns3__getDeviceInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getDeviceInfoResponse() { _ns3__getDeviceInfoResponse::soap_default(NULL); }
	virtual ~_ns3__getDeviceInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getDeviceAlarmsRequest
#define SOAP_TYPE__ns3__getDeviceAlarmsRequest (63)
/* ns3:getDeviceAlarmsRequest */
class SOAP_CMAC _ns3__getDeviceAlarmsRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE__ns3__getDeviceAlarmsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getDeviceAlarmsRequest() { _ns3__getDeviceAlarmsRequest::soap_default(NULL); }
	virtual ~_ns3__getDeviceAlarmsRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getDeviceAlarmsResponse
#define SOAP_TYPE__ns3__getDeviceAlarmsResponse (64)
/* ns3:getDeviceAlarmsResponse */
class SOAP_CMAC _ns3__getDeviceAlarmsResponse
{
public:
	std::vector<_ns2__alarm * >ns2__alarm;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:alarm */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE__ns3__getDeviceAlarmsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getDeviceAlarmsResponse() { _ns3__getDeviceAlarmsResponse::soap_default(NULL); }
	virtual ~_ns3__getDeviceAlarmsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getTimeZoneRequest
#define SOAP_TYPE__ns3__getTimeZoneRequest (65)
/* ns3:getTimeZoneRequest */
class SOAP_CMAC _ns3__getTimeZoneRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE__ns3__getTimeZoneRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getTimeZoneRequest() { _ns3__getTimeZoneRequest::soap_default(NULL); }
	virtual ~_ns3__getTimeZoneRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__getTimeZoneResponse
#define SOAP_TYPE__ns3__getTimeZoneResponse (66)
/* ns3:getTimeZoneResponse */
class SOAP_CMAC _ns3__getTimeZoneResponse
{
public:
	std::string timeZone;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:timeZone */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE__ns3__getTimeZoneResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__getTimeZoneResponse() { _ns3__getTimeZoneResponse::soap_default(NULL); }
	virtual ~_ns3__getTimeZoneResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setTimeZoneRequest
#define SOAP_TYPE__ns3__setTimeZoneRequest (67)
/* ns3:setTimeZoneRequest */
class SOAP_CMAC _ns3__setTimeZoneRequest
{
public:
	std::string timeZone;	/* required element of type ns2:timeZone */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE__ns3__setTimeZoneRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setTimeZoneRequest() { _ns3__setTimeZoneRequest::soap_default(NULL); }
	virtual ~_ns3__setTimeZoneRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__setTimeZoneResponse
#define SOAP_TYPE__ns3__setTimeZoneResponse (68)
/* ns3:setTimeZoneResponse */
class SOAP_CMAC _ns3__setTimeZoneResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE__ns3__setTimeZoneResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__setTimeZoneResponse() { _ns3__setTimeZoneResponse::soap_default(NULL); }
	virtual ~_ns3__setTimeZoneResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isAutoEqModeEnabledRequest
#define SOAP_TYPE__ns3__isAutoEqModeEnabledRequest (69)
/* ns3:isAutoEqModeEnabledRequest */
class SOAP_CMAC _ns3__isAutoEqModeEnabledRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE__ns3__isAutoEqModeEnabledRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isAutoEqModeEnabledRequest() { _ns3__isAutoEqModeEnabledRequest::soap_default(NULL); }
	virtual ~_ns3__isAutoEqModeEnabledRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__isAutoEqModeEnabledResponse
#define SOAP_TYPE__ns3__isAutoEqModeEnabledResponse (70)
/* ns3:isAutoEqModeEnabledResponse */
class SOAP_CMAC _ns3__isAutoEqModeEnabledResponse
{
public:
	bool enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE__ns3__isAutoEqModeEnabledResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__isAutoEqModeEnabledResponse() { _ns3__isAutoEqModeEnabledResponse::soap_default(NULL); }
	virtual ~_ns3__isAutoEqModeEnabledResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__enableAutoEqModeRequest
#define SOAP_TYPE__ns3__enableAutoEqModeRequest (71)
/* ns3:enableAutoEqModeRequest */
class SOAP_CMAC _ns3__enableAutoEqModeRequest
{
public:
	bool enable;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE__ns3__enableAutoEqModeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__enableAutoEqModeRequest() { _ns3__enableAutoEqModeRequest::soap_default(NULL); }
	virtual ~_ns3__enableAutoEqModeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__enableAutoEqModeResponse
#define SOAP_TYPE__ns3__enableAutoEqModeResponse (72)
/* ns3:enableAutoEqModeResponse */
class SOAP_CMAC _ns3__enableAutoEqModeResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique type id SOAP_TYPE__ns3__enableAutoEqModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__enableAutoEqModeResponse() { _ns3__enableAutoEqModeResponse::soap_default(NULL); }
	virtual ~_ns3__enableAutoEqModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__performSystemUpgradeRequest
#define SOAP_TYPE__ns3__performSystemUpgradeRequest (73)
/* ns3:performSystemUpgradeRequest */
class SOAP_CMAC _ns3__performSystemUpgradeRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE__ns3__performSystemUpgradeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__performSystemUpgradeRequest() { _ns3__performSystemUpgradeRequest::soap_default(NULL); }
	virtual ~_ns3__performSystemUpgradeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__performSystemUpgradeResponse
#define SOAP_TYPE__ns3__performSystemUpgradeResponse (74)
/* ns3:performSystemUpgradeResponse */
class SOAP_CMAC _ns3__performSystemUpgradeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique type id SOAP_TYPE__ns3__performSystemUpgradeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__performSystemUpgradeResponse() { _ns3__performSystemUpgradeResponse::soap_default(NULL); }
	virtual ~_ns3__performSystemUpgradeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCertificateRequest
#define SOAP_TYPE__ns4__getCertificateRequest (75)
/* ns4:getCertificateRequest */
class SOAP_CMAC _ns4__getCertificateRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique type id SOAP_TYPE__ns4__getCertificateRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCertificateRequest() { _ns4__getCertificateRequest::soap_default(NULL); }
	virtual ~_ns4__getCertificateRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCertificateResponse
#define SOAP_TYPE__ns4__getCertificateResponse (76)
/* ns4:getCertificateResponse */
class SOAP_CMAC _ns4__getCertificateResponse
{
public:
	std::string name;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	std::string certificate;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE__ns4__getCertificateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCertificateResponse() { _ns4__getCertificateResponse::soap_default(NULL); }
	virtual ~_ns4__getCertificateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getSystemVersionsRequest
#define SOAP_TYPE__ns4__getSystemVersionsRequest (77)
/* ns4:getSystemVersionsRequest */
class SOAP_CMAC _ns4__getSystemVersionsRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique type id SOAP_TYPE__ns4__getSystemVersionsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getSystemVersionsRequest() { _ns4__getSystemVersionsRequest::soap_default(NULL); }
	virtual ~_ns4__getSystemVersionsRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getSystemVersionsResponse
#define SOAP_TYPE__ns4__getSystemVersionsResponse (78)
/* ns4:getSystemVersionsResponse */
class SOAP_CMAC _ns4__getSystemVersionsResponse
{
public:
	std::vector<ns2__keyValuePair * >keyValuePair;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:keyValuePair */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE__ns4__getSystemVersionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getSystemVersionsResponse() { _ns4__getSystemVersionsResponse::soap_default(NULL); }
	virtual ~_ns4__getSystemVersionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__setWayParamsRequest
#define SOAP_TYPE__ns4__setWayParamsRequest (79)
/* ns4:setWayParamsRequest */
class SOAP_CMAC _ns4__setWayParamsRequest
{
public:
	std::string channel;	/* required element of type xsd:integer */
	std::string way;	/* required element of type xsd:integer */
	float gainDB;	/* required element of type xsd:float */
	float delayMs;	/* required element of type xsd:float */
	enum ns2__polarity polarity;	/* required element of type ns2:polarity */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique type id SOAP_TYPE__ns4__setWayParamsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__setWayParamsRequest() { _ns4__setWayParamsRequest::soap_default(NULL); }
	virtual ~_ns4__setWayParamsRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns4__setWayParamsResponse
#define SOAP_TYPE__ns4__setWayParamsResponse (80)
/* ns4:setWayParamsResponse */
class SOAP_CMAC _ns4__setWayParamsResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique type id SOAP_TYPE__ns4__setWayParamsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__setWayParamsResponse() { _ns4__setWayParamsResponse::soap_default(NULL); }
	virtual ~_ns4__setWayParamsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getWayParamsRequest
#define SOAP_TYPE__ns4__getWayParamsRequest (81)
/* ns4:getWayParamsRequest */
class SOAP_CMAC _ns4__getWayParamsRequest
{
public:
	std::string channel;	/* required element of type xsd:integer */
	std::string way;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique type id SOAP_TYPE__ns4__getWayParamsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getWayParamsRequest() { _ns4__getWayParamsRequest::soap_default(NULL); }
	virtual ~_ns4__getWayParamsRequest() { }
};
#endif

#ifndef SOAP_TYPE___ns4__getWayParamsResponse_sequence
#define SOAP_TYPE___ns4__getWayParamsResponse_sequence (138)
/* Operation wrapper: */
class SOAP_CMAC __ns4__getWayParamsResponse_sequence
{
public:
	float gainDB;	/* required element of type xsd:float */
	float delayMs;	/* required element of type xsd:float */
	enum ns2__polarity polarity;	/* required element of type ns2:polarity */
public:
	virtual int soap_type() const { return 138; } /* = unique type id SOAP_TYPE___ns4__getWayParamsResponse_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns4__getWayParamsResponse_sequence() { __ns4__getWayParamsResponse_sequence::soap_default(NULL); }
	virtual ~__ns4__getWayParamsResponse_sequence() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getWayParamsResponse
#define SOAP_TYPE__ns4__getWayParamsResponse (82)
/* ns4:getWayParamsResponse */
class SOAP_CMAC _ns4__getWayParamsResponse
{
public:
	__ns4__getWayParamsResponse_sequence *__getWayParamsResponse_sequence;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique type id SOAP_TYPE__ns4__getWayParamsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getWayParamsResponse() { _ns4__getWayParamsResponse::soap_default(NULL); }
	virtual ~_ns4__getWayParamsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getWayFiltersRequest
#define SOAP_TYPE__ns4__getWayFiltersRequest (83)
/* ns4:getWayFiltersRequest */
class SOAP_CMAC _ns4__getWayFiltersRequest
{
public:
	std::string channel;	/* required element of type xsd:integer */
	std::string way;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique type id SOAP_TYPE__ns4__getWayFiltersRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getWayFiltersRequest() { _ns4__getWayFiltersRequest::soap_default(NULL); }
	virtual ~_ns4__getWayFiltersRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getWayFiltersResponse
#define SOAP_TYPE__ns4__getWayFiltersResponse (84)
/* ns4:getWayFiltersResponse */
class SOAP_CMAC _ns4__getWayFiltersResponse
{
public:
	std::vector<ns2__crossoverFilter * >crossover;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:crossoverFilter */
	std::vector<ns2__shelfFilter * >shelf;	/* optional element of type ns2:shelfFilter */
	std::vector<ns2__parametricFilter * >parametric;	/* optional element of type ns2:parametricFilter */
	std::vector<ns2__allPassFilter * >allPass;	/* optional element of type ns2:allPassFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique type id SOAP_TYPE__ns4__getWayFiltersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getWayFiltersResponse() { _ns4__getWayFiltersResponse::soap_default(NULL); }
	virtual ~_ns4__getWayFiltersResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__setWayFilterRequest
#define SOAP_TYPE__ns4__setWayFilterRequest (85)
/* ns4:setWayFilterRequest */
class SOAP_CMAC _ns4__setWayFilterRequest
{
public:
	std::string channel;	/* required element of type xsd:integer */
	std::string way;	/* required element of type xsd:integer */
	ns2__crossoverFilter *crossover;	/* optional element of type ns2:crossoverFilter */
	ns2__shelfFilter *shelf;	/* optional element of type ns2:shelfFilter */
	ns2__parametricFilter *parametric;	/* optional element of type ns2:parametricFilter */
	ns2__allPassFilter *allPass;	/* optional element of type ns2:allPassFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique type id SOAP_TYPE__ns4__setWayFilterRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__setWayFilterRequest() { _ns4__setWayFilterRequest::soap_default(NULL); }
	virtual ~_ns4__setWayFilterRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns4__setWayFilterResponse
#define SOAP_TYPE__ns4__setWayFilterResponse (86)
/* ns4:setWayFilterResponse */
class SOAP_CMAC _ns4__setWayFilterResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique type id SOAP_TYPE__ns4__setWayFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__setWayFilterResponse() { _ns4__setWayFilterResponse::soap_default(NULL); }
	virtual ~_ns4__setWayFilterResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__deleteWayFilterRequest
#define SOAP_TYPE__ns4__deleteWayFilterRequest (87)
/* ns4:deleteWayFilterRequest */
class SOAP_CMAC _ns4__deleteWayFilterRequest
{
public:
	std::string channel;	/* required element of type xsd:integer */
	std::string way;	/* required element of type xsd:integer */
	std::string id;	/* required element of type ns2:filterID */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique type id SOAP_TYPE__ns4__deleteWayFilterRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__deleteWayFilterRequest() { _ns4__deleteWayFilterRequest::soap_default(NULL); }
	virtual ~_ns4__deleteWayFilterRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns4__deleteWayFilterResponse
#define SOAP_TYPE__ns4__deleteWayFilterResponse (88)
/* ns4:deleteWayFilterResponse */
class SOAP_CMAC _ns4__deleteWayFilterResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique type id SOAP_TYPE__ns4__deleteWayFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__deleteWayFilterResponse() { _ns4__deleteWayFilterResponse::soap_default(NULL); }
	virtual ~_ns4__deleteWayFilterResponse() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (148)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns2__fault *ns3__fault;	/* optional element of type ns2:fault */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
public:
	int soap_type() const { return 148; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef SOAP_TYPE___ns1__listMacros
#define SOAP_TYPE___ns1__listMacros (155)
/* Operation wrapper: */
struct __ns1__listMacros
{
public:
	_ns3__listMacrosRequest *ns3__listMacrosRequest;	/* optional element of type ns3:listMacrosRequest */
public:
	int soap_type() const { return 155; } /* = unique type id SOAP_TYPE___ns1__listMacros */
};
#endif

#ifndef SOAP_TYPE___ns1__getCurrentMacro
#define SOAP_TYPE___ns1__getCurrentMacro (159)
/* Operation wrapper: */
struct __ns1__getCurrentMacro
{
public:
	_ns3__getCurrentMacroRequest *ns3__getCurrentMacroRequest;	/* optional element of type ns3:getCurrentMacroRequest */
public:
	int soap_type() const { return 159; } /* = unique type id SOAP_TYPE___ns1__getCurrentMacro */
};
#endif

#ifndef SOAP_TYPE___ns1__setCurrentMacro
#define SOAP_TYPE___ns1__setCurrentMacro (163)
/* Operation wrapper: */
struct __ns1__setCurrentMacro
{
public:
	_ns3__setCurrentMacroRequest *ns3__setCurrentMacroRequest;	/* optional element of type ns3:setCurrentMacroRequest */
public:
	int soap_type() const { return 163; } /* = unique type id SOAP_TYPE___ns1__setCurrentMacro */
};
#endif

#ifndef SOAP_TYPE___ns1__getGain
#define SOAP_TYPE___ns1__getGain (167)
/* Operation wrapper: */
struct __ns1__getGain
{
public:
	_ns3__getGainRequest *ns3__getGainRequest;	/* optional element of type ns3:getGainRequest */
public:
	int soap_type() const { return 167; } /* = unique type id SOAP_TYPE___ns1__getGain */
};
#endif

#ifndef SOAP_TYPE___ns1__setGain
#define SOAP_TYPE___ns1__setGain (171)
/* Operation wrapper: */
struct __ns1__setGain
{
public:
	_ns3__setGainRequest *ns3__setGainRequest;	/* optional element of type ns3:setGainRequest */
public:
	int soap_type() const { return 171; } /* = unique type id SOAP_TYPE___ns1__setGain */
};
#endif

#ifndef SOAP_TYPE___ns1__getMute
#define SOAP_TYPE___ns1__getMute (175)
/* Operation wrapper: */
struct __ns1__getMute
{
public:
	_ns3__getMuteRequest *ns3__getMuteRequest;	/* optional element of type ns3:getMuteRequest */
public:
	int soap_type() const { return 175; } /* = unique type id SOAP_TYPE___ns1__getMute */
};
#endif

#ifndef SOAP_TYPE___ns1__setMute
#define SOAP_TYPE___ns1__setMute (179)
/* Operation wrapper: */
struct __ns1__setMute
{
public:
	_ns3__setMuteRequest *ns3__setMuteRequest;	/* optional element of type ns3:setMuteRequest */
public:
	int soap_type() const { return 179; } /* = unique type id SOAP_TYPE___ns1__setMute */
};
#endif

#ifndef SOAP_TYPE___ns1__isAtmosContent
#define SOAP_TYPE___ns1__isAtmosContent (183)
/* Operation wrapper: */
struct __ns1__isAtmosContent
{
public:
	_ns3__isAtmosContentRequest *ns3__isAtmosContentRequest;	/* optional element of type ns3:isAtmosContentRequest */
public:
	int soap_type() const { return 183; } /* = unique type id SOAP_TYPE___ns1__isAtmosContent */
};
#endif

#ifndef SOAP_TYPE___ns1__getAudioStreamInfo
#define SOAP_TYPE___ns1__getAudioStreamInfo (187)
/* Operation wrapper: */
struct __ns1__getAudioStreamInfo
{
public:
	_ns3__getAudioStreamInfoRequest *ns3__getAudioStreamInfoRequest;	/* optional element of type ns3:getAudioStreamInfoRequest */
public:
	int soap_type() const { return 187; } /* = unique type id SOAP_TYPE___ns1__getAudioStreamInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__getAtmosConfigInfo
#define SOAP_TYPE___ns1__getAtmosConfigInfo (191)
/* Operation wrapper: */
struct __ns1__getAtmosConfigInfo
{
public:
	_ns3__getAtmosConfigInfoRequest *ns3__getAtmosConfigInfoRequest;	/* optional element of type ns3:getAtmosConfigInfoRequest */
public:
	int soap_type() const { return 191; } /* = unique type id SOAP_TYPE___ns1__getAtmosConfigInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__getAtmosConfig
#define SOAP_TYPE___ns1__getAtmosConfig (195)
/* Operation wrapper: */
struct __ns1__getAtmosConfig
{
public:
	_ns3__getAtmosConfigRequest *ns3__getAtmosConfigRequest;	/* optional element of type ns3:getAtmosConfigRequest */
public:
	int soap_type() const { return 195; } /* = unique type id SOAP_TYPE___ns1__getAtmosConfig */
};
#endif

#ifndef SOAP_TYPE___ns1__setAtmosConfig
#define SOAP_TYPE___ns1__setAtmosConfig (199)
/* Operation wrapper: */
struct __ns1__setAtmosConfig
{
public:
	_ns3__setAtmosConfigRequest *ns3__setAtmosConfigRequest;	/* optional element of type ns3:setAtmosConfigRequest */
public:
	int soap_type() const { return 199; } /* = unique type id SOAP_TYPE___ns1__setAtmosConfig */
};
#endif

#ifndef SOAP_TYPE___ns1__getTestSignalOutput
#define SOAP_TYPE___ns1__getTestSignalOutput (203)
/* Operation wrapper: */
struct __ns1__getTestSignalOutput
{
public:
	_ns3__getTestSignalOutputRequest *ns3__getTestSignalOutputRequest;	/* optional element of type ns3:getTestSignalOutputRequest */
public:
	int soap_type() const { return 203; } /* = unique type id SOAP_TYPE___ns1__getTestSignalOutput */
};
#endif

#ifndef SOAP_TYPE___ns1__setTestSignalOutput
#define SOAP_TYPE___ns1__setTestSignalOutput (207)
/* Operation wrapper: */
struct __ns1__setTestSignalOutput
{
public:
	_ns3__setTestSignalOutputRequest *ns3__setTestSignalOutputRequest;	/* optional element of type ns3:setTestSignalOutputRequest */
public:
	int soap_type() const { return 207; } /* = unique type id SOAP_TYPE___ns1__setTestSignalOutput */
};
#endif

#ifndef SOAP_TYPE___ns1__getTestSignalMode
#define SOAP_TYPE___ns1__getTestSignalMode (211)
/* Operation wrapper: */
struct __ns1__getTestSignalMode
{
public:
	_ns3__getTestSignalModeRequest *ns3__getTestSignalModeRequest;	/* optional element of type ns3:getTestSignalModeRequest */
public:
	int soap_type() const { return 211; } /* = unique type id SOAP_TYPE___ns1__getTestSignalMode */
};
#endif

#ifndef SOAP_TYPE___ns1__setTestSignalMode
#define SOAP_TYPE___ns1__setTestSignalMode (215)
/* Operation wrapper: */
struct __ns1__setTestSignalMode
{
public:
	_ns3__setTestSignalModeRequest *ns3__setTestSignalModeRequest;	/* optional element of type ns3:setTestSignalModeRequest */
public:
	int soap_type() const { return 215; } /* = unique type id SOAP_TYPE___ns1__setTestSignalMode */
};
#endif

#ifndef SOAP_TYPE___ns1__isBassManagementEnabled
#define SOAP_TYPE___ns1__isBassManagementEnabled (219)
/* Operation wrapper: */
struct __ns1__isBassManagementEnabled
{
public:
	_ns3__isBassManagementEnabledRequest *ns3__isBassManagementEnabledRequest;	/* optional element of type ns3:isBassManagementEnabledRequest */
public:
	int soap_type() const { return 219; } /* = unique type id SOAP_TYPE___ns1__isBassManagementEnabled */
};
#endif

#ifndef SOAP_TYPE___ns1__enableBassManagement
#define SOAP_TYPE___ns1__enableBassManagement (223)
/* Operation wrapper: */
struct __ns1__enableBassManagement
{
public:
	_ns3__enableBassManagementRequest *ns3__enableBassManagementRequest;	/* optional element of type ns3:enableBassManagementRequest */
public:
	int soap_type() const { return 223; } /* = unique type id SOAP_TYPE___ns1__enableBassManagement */
};
#endif

#ifndef SOAP_TYPE___ns1__isGlobalEqEnabled
#define SOAP_TYPE___ns1__isGlobalEqEnabled (227)
/* Operation wrapper: */
struct __ns1__isGlobalEqEnabled
{
public:
	_ns3__isGlobalEqEnabledRequest *ns3__isGlobalEqEnabledRequest;	/* optional element of type ns3:isGlobalEqEnabledRequest */
public:
	int soap_type() const { return 227; } /* = unique type id SOAP_TYPE___ns1__isGlobalEqEnabled */
};
#endif

#ifndef SOAP_TYPE___ns1__enableGlobalEq
#define SOAP_TYPE___ns1__enableGlobalEq (231)
/* Operation wrapper: */
struct __ns1__enableGlobalEq
{
public:
	_ns3__enableGlobalEqRequest *ns3__enableGlobalEqRequest;	/* optional element of type ns3:enableGlobalEqRequest */
public:
	int soap_type() const { return 231; } /* = unique type id SOAP_TYPE___ns1__enableGlobalEq */
};
#endif

#ifndef SOAP_TYPE___ns1__getDeviceInfo
#define SOAP_TYPE___ns1__getDeviceInfo (235)
/* Operation wrapper: */
struct __ns1__getDeviceInfo
{
public:
	_ns3__getDeviceInfoRequest *ns3__getDeviceInfoRequest;	/* optional element of type ns3:getDeviceInfoRequest */
public:
	int soap_type() const { return 235; } /* = unique type id SOAP_TYPE___ns1__getDeviceInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__getDeviceAlarms
#define SOAP_TYPE___ns1__getDeviceAlarms (239)
/* Operation wrapper: */
struct __ns1__getDeviceAlarms
{
public:
	_ns3__getDeviceAlarmsRequest *ns3__getDeviceAlarmsRequest;	/* optional element of type ns3:getDeviceAlarmsRequest */
public:
	int soap_type() const { return 239; } /* = unique type id SOAP_TYPE___ns1__getDeviceAlarms */
};
#endif

#ifndef SOAP_TYPE___ns1__getTimeZone
#define SOAP_TYPE___ns1__getTimeZone (243)
/* Operation wrapper: */
struct __ns1__getTimeZone
{
public:
	_ns3__getTimeZoneRequest *ns3__getTimeZoneRequest;	/* optional element of type ns3:getTimeZoneRequest */
public:
	int soap_type() const { return 243; } /* = unique type id SOAP_TYPE___ns1__getTimeZone */
};
#endif

#ifndef SOAP_TYPE___ns1__setTimeZone
#define SOAP_TYPE___ns1__setTimeZone (247)
/* Operation wrapper: */
struct __ns1__setTimeZone
{
public:
	_ns3__setTimeZoneRequest *ns3__setTimeZoneRequest;	/* optional element of type ns3:setTimeZoneRequest */
public:
	int soap_type() const { return 247; } /* = unique type id SOAP_TYPE___ns1__setTimeZone */
};
#endif

#ifndef SOAP_TYPE___ns1__isAutoEqModeEnabled
#define SOAP_TYPE___ns1__isAutoEqModeEnabled (251)
/* Operation wrapper: */
struct __ns1__isAutoEqModeEnabled
{
public:
	_ns3__isAutoEqModeEnabledRequest *ns3__isAutoEqModeEnabledRequest;	/* optional element of type ns3:isAutoEqModeEnabledRequest */
public:
	int soap_type() const { return 251; } /* = unique type id SOAP_TYPE___ns1__isAutoEqModeEnabled */
};
#endif

#ifndef SOAP_TYPE___ns1__enableAutoEqMode
#define SOAP_TYPE___ns1__enableAutoEqMode (255)
/* Operation wrapper: */
struct __ns1__enableAutoEqMode
{
public:
	_ns3__enableAutoEqModeRequest *ns3__enableAutoEqModeRequest;	/* optional element of type ns3:enableAutoEqModeRequest */
public:
	int soap_type() const { return 255; } /* = unique type id SOAP_TYPE___ns1__enableAutoEqMode */
};
#endif

#ifndef SOAP_TYPE___ns1__performSystemUpgrade
#define SOAP_TYPE___ns1__performSystemUpgrade (259)
/* Operation wrapper: */
struct __ns1__performSystemUpgrade
{
public:
	_ns3__performSystemUpgradeRequest *ns3__performSystemUpgradeRequest;	/* optional element of type ns3:performSystemUpgradeRequest */
public:
	int soap_type() const { return 259; } /* = unique type id SOAP_TYPE___ns1__performSystemUpgrade */
};
#endif

#ifndef SOAP_TYPE___ns1__listMacros_
#define SOAP_TYPE___ns1__listMacros_ (261)
/* Operation wrapper: */
struct __ns1__listMacros_
{
public:
	_ns3__listMacrosRequest *ns3__listMacrosRequest;	/* optional element of type ns3:listMacrosRequest */
public:
	int soap_type() const { return 261; } /* = unique type id SOAP_TYPE___ns1__listMacros_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getCurrentMacro_
#define SOAP_TYPE___ns1__getCurrentMacro_ (263)
/* Operation wrapper: */
struct __ns1__getCurrentMacro_
{
public:
	_ns3__getCurrentMacroRequest *ns3__getCurrentMacroRequest;	/* optional element of type ns3:getCurrentMacroRequest */
public:
	int soap_type() const { return 263; } /* = unique type id SOAP_TYPE___ns1__getCurrentMacro_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setCurrentMacro_
#define SOAP_TYPE___ns1__setCurrentMacro_ (265)
/* Operation wrapper: */
struct __ns1__setCurrentMacro_
{
public:
	_ns3__setCurrentMacroRequest *ns3__setCurrentMacroRequest;	/* optional element of type ns3:setCurrentMacroRequest */
public:
	int soap_type() const { return 265; } /* = unique type id SOAP_TYPE___ns1__setCurrentMacro_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getGain_
#define SOAP_TYPE___ns1__getGain_ (267)
/* Operation wrapper: */
struct __ns1__getGain_
{
public:
	_ns3__getGainRequest *ns3__getGainRequest;	/* optional element of type ns3:getGainRequest */
public:
	int soap_type() const { return 267; } /* = unique type id SOAP_TYPE___ns1__getGain_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setGain_
#define SOAP_TYPE___ns1__setGain_ (269)
/* Operation wrapper: */
struct __ns1__setGain_
{
public:
	_ns3__setGainRequest *ns3__setGainRequest;	/* optional element of type ns3:setGainRequest */
public:
	int soap_type() const { return 269; } /* = unique type id SOAP_TYPE___ns1__setGain_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getMute_
#define SOAP_TYPE___ns1__getMute_ (271)
/* Operation wrapper: */
struct __ns1__getMute_
{
public:
	_ns3__getMuteRequest *ns3__getMuteRequest;	/* optional element of type ns3:getMuteRequest */
public:
	int soap_type() const { return 271; } /* = unique type id SOAP_TYPE___ns1__getMute_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setMute_
#define SOAP_TYPE___ns1__setMute_ (273)
/* Operation wrapper: */
struct __ns1__setMute_
{
public:
	_ns3__setMuteRequest *ns3__setMuteRequest;	/* optional element of type ns3:setMuteRequest */
public:
	int soap_type() const { return 273; } /* = unique type id SOAP_TYPE___ns1__setMute_ */
};
#endif

#ifndef SOAP_TYPE___ns1__isAtmosContent_
#define SOAP_TYPE___ns1__isAtmosContent_ (275)
/* Operation wrapper: */
struct __ns1__isAtmosContent_
{
public:
	_ns3__isAtmosContentRequest *ns3__isAtmosContentRequest;	/* optional element of type ns3:isAtmosContentRequest */
public:
	int soap_type() const { return 275; } /* = unique type id SOAP_TYPE___ns1__isAtmosContent_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getAudioStreamInfo_
#define SOAP_TYPE___ns1__getAudioStreamInfo_ (277)
/* Operation wrapper: */
struct __ns1__getAudioStreamInfo_
{
public:
	_ns3__getAudioStreamInfoRequest *ns3__getAudioStreamInfoRequest;	/* optional element of type ns3:getAudioStreamInfoRequest */
public:
	int soap_type() const { return 277; } /* = unique type id SOAP_TYPE___ns1__getAudioStreamInfo_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getAtmosConfigInfo_
#define SOAP_TYPE___ns1__getAtmosConfigInfo_ (279)
/* Operation wrapper: */
struct __ns1__getAtmosConfigInfo_
{
public:
	_ns3__getAtmosConfigInfoRequest *ns3__getAtmosConfigInfoRequest;	/* optional element of type ns3:getAtmosConfigInfoRequest */
public:
	int soap_type() const { return 279; } /* = unique type id SOAP_TYPE___ns1__getAtmosConfigInfo_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getAtmosConfig_
#define SOAP_TYPE___ns1__getAtmosConfig_ (281)
/* Operation wrapper: */
struct __ns1__getAtmosConfig_
{
public:
	_ns3__getAtmosConfigRequest *ns3__getAtmosConfigRequest;	/* optional element of type ns3:getAtmosConfigRequest */
public:
	int soap_type() const { return 281; } /* = unique type id SOAP_TYPE___ns1__getAtmosConfig_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setAtmosConfig_
#define SOAP_TYPE___ns1__setAtmosConfig_ (283)
/* Operation wrapper: */
struct __ns1__setAtmosConfig_
{
public:
	_ns3__setAtmosConfigRequest *ns3__setAtmosConfigRequest;	/* optional element of type ns3:setAtmosConfigRequest */
public:
	int soap_type() const { return 283; } /* = unique type id SOAP_TYPE___ns1__setAtmosConfig_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getTestSignalOutput_
#define SOAP_TYPE___ns1__getTestSignalOutput_ (285)
/* Operation wrapper: */
struct __ns1__getTestSignalOutput_
{
public:
	_ns3__getTestSignalOutputRequest *ns3__getTestSignalOutputRequest;	/* optional element of type ns3:getTestSignalOutputRequest */
public:
	int soap_type() const { return 285; } /* = unique type id SOAP_TYPE___ns1__getTestSignalOutput_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setTestSignalOutput_
#define SOAP_TYPE___ns1__setTestSignalOutput_ (287)
/* Operation wrapper: */
struct __ns1__setTestSignalOutput_
{
public:
	_ns3__setTestSignalOutputRequest *ns3__setTestSignalOutputRequest;	/* optional element of type ns3:setTestSignalOutputRequest */
public:
	int soap_type() const { return 287; } /* = unique type id SOAP_TYPE___ns1__setTestSignalOutput_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getTestSignalMode_
#define SOAP_TYPE___ns1__getTestSignalMode_ (289)
/* Operation wrapper: */
struct __ns1__getTestSignalMode_
{
public:
	_ns3__getTestSignalModeRequest *ns3__getTestSignalModeRequest;	/* optional element of type ns3:getTestSignalModeRequest */
public:
	int soap_type() const { return 289; } /* = unique type id SOAP_TYPE___ns1__getTestSignalMode_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setTestSignalMode_
#define SOAP_TYPE___ns1__setTestSignalMode_ (291)
/* Operation wrapper: */
struct __ns1__setTestSignalMode_
{
public:
	_ns3__setTestSignalModeRequest *ns3__setTestSignalModeRequest;	/* optional element of type ns3:setTestSignalModeRequest */
public:
	int soap_type() const { return 291; } /* = unique type id SOAP_TYPE___ns1__setTestSignalMode_ */
};
#endif

#ifndef SOAP_TYPE___ns1__isBassManagementEnabled_
#define SOAP_TYPE___ns1__isBassManagementEnabled_ (293)
/* Operation wrapper: */
struct __ns1__isBassManagementEnabled_
{
public:
	_ns3__isBassManagementEnabledRequest *ns3__isBassManagementEnabledRequest;	/* optional element of type ns3:isBassManagementEnabledRequest */
public:
	int soap_type() const { return 293; } /* = unique type id SOAP_TYPE___ns1__isBassManagementEnabled_ */
};
#endif

#ifndef SOAP_TYPE___ns1__enableBassManagement_
#define SOAP_TYPE___ns1__enableBassManagement_ (295)
/* Operation wrapper: */
struct __ns1__enableBassManagement_
{
public:
	_ns3__enableBassManagementRequest *ns3__enableBassManagementRequest;	/* optional element of type ns3:enableBassManagementRequest */
public:
	int soap_type() const { return 295; } /* = unique type id SOAP_TYPE___ns1__enableBassManagement_ */
};
#endif

#ifndef SOAP_TYPE___ns1__isGlobalEqEnabled_
#define SOAP_TYPE___ns1__isGlobalEqEnabled_ (297)
/* Operation wrapper: */
struct __ns1__isGlobalEqEnabled_
{
public:
	_ns3__isGlobalEqEnabledRequest *ns3__isGlobalEqEnabledRequest;	/* optional element of type ns3:isGlobalEqEnabledRequest */
public:
	int soap_type() const { return 297; } /* = unique type id SOAP_TYPE___ns1__isGlobalEqEnabled_ */
};
#endif

#ifndef SOAP_TYPE___ns1__enableGlobalEq_
#define SOAP_TYPE___ns1__enableGlobalEq_ (299)
/* Operation wrapper: */
struct __ns1__enableGlobalEq_
{
public:
	_ns3__enableGlobalEqRequest *ns3__enableGlobalEqRequest;	/* optional element of type ns3:enableGlobalEqRequest */
public:
	int soap_type() const { return 299; } /* = unique type id SOAP_TYPE___ns1__enableGlobalEq_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getDeviceInfo_
#define SOAP_TYPE___ns1__getDeviceInfo_ (301)
/* Operation wrapper: */
struct __ns1__getDeviceInfo_
{
public:
	_ns3__getDeviceInfoRequest *ns3__getDeviceInfoRequest;	/* optional element of type ns3:getDeviceInfoRequest */
public:
	int soap_type() const { return 301; } /* = unique type id SOAP_TYPE___ns1__getDeviceInfo_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getDeviceAlarms_
#define SOAP_TYPE___ns1__getDeviceAlarms_ (303)
/* Operation wrapper: */
struct __ns1__getDeviceAlarms_
{
public:
	_ns3__getDeviceAlarmsRequest *ns3__getDeviceAlarmsRequest;	/* optional element of type ns3:getDeviceAlarmsRequest */
public:
	int soap_type() const { return 303; } /* = unique type id SOAP_TYPE___ns1__getDeviceAlarms_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getTimeZone_
#define SOAP_TYPE___ns1__getTimeZone_ (305)
/* Operation wrapper: */
struct __ns1__getTimeZone_
{
public:
	_ns3__getTimeZoneRequest *ns3__getTimeZoneRequest;	/* optional element of type ns3:getTimeZoneRequest */
public:
	int soap_type() const { return 305; } /* = unique type id SOAP_TYPE___ns1__getTimeZone_ */
};
#endif

#ifndef SOAP_TYPE___ns1__setTimeZone_
#define SOAP_TYPE___ns1__setTimeZone_ (307)
/* Operation wrapper: */
struct __ns1__setTimeZone_
{
public:
	_ns3__setTimeZoneRequest *ns3__setTimeZoneRequest;	/* optional element of type ns3:setTimeZoneRequest */
public:
	int soap_type() const { return 307; } /* = unique type id SOAP_TYPE___ns1__setTimeZone_ */
};
#endif

#ifndef SOAP_TYPE___ns1__isAutoEqModeEnabled_
#define SOAP_TYPE___ns1__isAutoEqModeEnabled_ (309)
/* Operation wrapper: */
struct __ns1__isAutoEqModeEnabled_
{
public:
	_ns3__isAutoEqModeEnabledRequest *ns3__isAutoEqModeEnabledRequest;	/* optional element of type ns3:isAutoEqModeEnabledRequest */
public:
	int soap_type() const { return 309; } /* = unique type id SOAP_TYPE___ns1__isAutoEqModeEnabled_ */
};
#endif

#ifndef SOAP_TYPE___ns1__enableAutoEqMode_
#define SOAP_TYPE___ns1__enableAutoEqMode_ (311)
/* Operation wrapper: */
struct __ns1__enableAutoEqMode_
{
public:
	_ns3__enableAutoEqModeRequest *ns3__enableAutoEqModeRequest;	/* optional element of type ns3:enableAutoEqModeRequest */
public:
	int soap_type() const { return 311; } /* = unique type id SOAP_TYPE___ns1__enableAutoEqMode_ */
};
#endif

#ifndef SOAP_TYPE___ns1__performSystemUpgrade_
#define SOAP_TYPE___ns1__performSystemUpgrade_ (313)
/* Operation wrapper: */
struct __ns1__performSystemUpgrade_
{
public:
	_ns3__performSystemUpgradeRequest *ns3__performSystemUpgradeRequest;	/* optional element of type ns3:performSystemUpgradeRequest */
public:
	int soap_type() const { return 313; } /* = unique type id SOAP_TYPE___ns1__performSystemUpgrade_ */
};
#endif

#ifndef SOAP_TYPE___ns1__getCertificate
#define SOAP_TYPE___ns1__getCertificate (317)
/* Operation wrapper: */
struct __ns1__getCertificate
{
public:
	_ns4__getCertificateRequest *ns4__getCertificateRequest;	/* optional element of type ns4:getCertificateRequest */
public:
	int soap_type() const { return 317; } /* = unique type id SOAP_TYPE___ns1__getCertificate */
};
#endif

#ifndef SOAP_TYPE___ns1__getSystemVersions
#define SOAP_TYPE___ns1__getSystemVersions (321)
/* Operation wrapper: */
struct __ns1__getSystemVersions
{
public:
	_ns4__getSystemVersionsRequest *ns4__getSystemVersionsRequest;	/* optional element of type ns4:getSystemVersionsRequest */
public:
	int soap_type() const { return 321; } /* = unique type id SOAP_TYPE___ns1__getSystemVersions */
};
#endif

#ifndef SOAP_TYPE___ns1__setWayParams
#define SOAP_TYPE___ns1__setWayParams (325)
/* Operation wrapper: */
struct __ns1__setWayParams
{
public:
	_ns4__setWayParamsRequest *ns4__setWayParamsRequest;	/* optional element of type ns4:setWayParamsRequest */
public:
	int soap_type() const { return 325; } /* = unique type id SOAP_TYPE___ns1__setWayParams */
};
#endif

#ifndef SOAP_TYPE___ns1__getWayParams
#define SOAP_TYPE___ns1__getWayParams (329)
/* Operation wrapper: */
struct __ns1__getWayParams
{
public:
	_ns4__getWayParamsRequest *ns4__getWayParamsRequest;	/* optional element of type ns4:getWayParamsRequest */
public:
	int soap_type() const { return 329; } /* = unique type id SOAP_TYPE___ns1__getWayParams */
};
#endif

#ifndef SOAP_TYPE___ns1__getWayFilters
#define SOAP_TYPE___ns1__getWayFilters (333)
/* Operation wrapper: */
struct __ns1__getWayFilters
{
public:
	_ns4__getWayFiltersRequest *ns4__getWayFiltersRequest;	/* optional element of type ns4:getWayFiltersRequest */
public:
	int soap_type() const { return 333; } /* = unique type id SOAP_TYPE___ns1__getWayFilters */
};
#endif

#ifndef SOAP_TYPE___ns1__setWayFilter
#define SOAP_TYPE___ns1__setWayFilter (337)
/* Operation wrapper: */
struct __ns1__setWayFilter
{
public:
	_ns4__setWayFilterRequest *ns4__setWayFilterRequest;	/* optional element of type ns4:setWayFilterRequest */
public:
	int soap_type() const { return 337; } /* = unique type id SOAP_TYPE___ns1__setWayFilter */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteWayFilter
#define SOAP_TYPE___ns1__deleteWayFilter (341)
/* Operation wrapper: */
struct __ns1__deleteWayFilter
{
public:
	_ns4__deleteWayFilterRequest *ns4__deleteWayFilterRequest;	/* optional element of type ns4:deleteWayFilterRequest */
public:
	int soap_type() const { return 341; } /* = unique type id SOAP_TYPE___ns1__deleteWayFilter */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (342)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 342; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (343)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 343; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (345)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 345; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (346)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 346; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (9)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (10)
typedef std::string xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (11)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_ns2__UUID
#define SOAP_TYPE_ns2__UUID (89)
typedef std::string ns2__UUID;
#endif

#ifndef SOAP_TYPE_ns2__Duration
#define SOAP_TYPE_ns2__Duration (93)
typedef LONG64 ns2__Duration;
#endif

#ifndef SOAP_TYPE_ns2__filterID
#define SOAP_TYPE_ns2__filterID (104)
typedef std::string ns2__filterID;
#endif

#ifndef SOAP_TYPE_ns2__timeZone
#define SOAP_TYPE_ns2__timeZone (114)
typedef std::string ns2__timeZone;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
